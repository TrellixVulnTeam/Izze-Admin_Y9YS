{"ast":null,"code":"import { Node } from '@tiptap/core';\nimport { textblockTypeInputRule } from 'prosemirror-inputrules';\nconst backtickInputRegex = /^```(?<language>[a-z]*)? $/;\nconst tildeInputRegex = /^~~~(?<language>[a-z]*)? $/;\nconst CodeBlock = Node.create({\n  name: 'codeBlock',\n  defaultOptions: {\n    languageClassPrefix: 'language-',\n    HTMLAttributes: {}\n  },\n  content: 'text*',\n  marks: '',\n  group: 'block',\n  code: true,\n  defining: true,\n\n  addAttributes() {\n    return {\n      language: {\n        default: null,\n        parseHTML: element => {\n          var _a;\n\n          const classAttribute = (_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.getAttribute('class');\n\n          if (!classAttribute) {\n            return null;\n          }\n\n          const regexLanguageClassPrefix = new RegExp(`^(${this.options.languageClassPrefix})`);\n          return {\n            language: classAttribute.replace(regexLanguageClassPrefix, '')\n          };\n        },\n        renderHTML: attributes => {\n          if (!attributes.language) {\n            return null;\n          }\n\n          return {\n            class: this.options.languageClassPrefix + attributes.language\n          };\n        }\n      }\n    };\n  },\n\n  parseHTML() {\n    return [{\n      tag: 'pre',\n      preserveWhitespace: 'full'\n    }];\n  },\n\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return ['pre', this.options.HTMLAttributes, ['code', HTMLAttributes, 0]];\n  },\n\n  addCommands() {\n    return {\n      setCodeBlock: attributes => ({\n        commands\n      }) => {\n        return commands.setNode('codeBlock', attributes);\n      },\n      toggleCodeBlock: attributes => ({\n        commands\n      }) => {\n        return commands.toggleNode('codeBlock', 'paragraph', attributes);\n      }\n    };\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const {\n          empty,\n          $anchor\n        } = this.editor.state.selection;\n        const isAtStart = $anchor.pos === 1;\n\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false;\n        }\n\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes();\n        }\n\n        return false;\n      }\n    };\n  },\n\n  addInputRules() {\n    return [textblockTypeInputRule(backtickInputRegex, this.type, ({\n      groups\n    }) => groups), textblockTypeInputRule(tildeInputRegex, this.type, ({\n      groups\n    }) => groups)];\n  }\n\n});\nexport default CodeBlock;\nexport { CodeBlock, backtickInputRegex, tildeInputRegex };","map":{"version":3,"sources":["../src/code-block.ts"],"names":[],"mappings":"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","sourcesContent":["import { Command, Node } from '@tiptap/core'\nimport { textblockTypeInputRule } from 'prosemirror-inputrules'\n\nexport interface CodeBlockOptions {\n  languageClassPrefix: string,\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    codeBlock: {\n      /**\n       * Set a code block\n       */\n      setCodeBlock: (attributes?: { language: string }) => Command,\n      /**\n       * Toggle a code block\n       */\n      toggleCodeBlock: (attributes?: { language: string }) => Command,\n    }\n  }\n}\n\nexport const backtickInputRegex = /^```(?<language>[a-z]*)? $/\nexport const tildeInputRegex = /^~~~(?<language>[a-z]*)? $/\n\nexport const CodeBlock = Node.create<CodeBlockOptions>({\n  name: 'codeBlock',\n\n  defaultOptions: {\n    languageClassPrefix: 'language-',\n    HTMLAttributes: {},\n  },\n\n  content: 'text*',\n\n  marks: '',\n\n  group: 'block',\n\n  code: true,\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      language: {\n        default: null,\n        parseHTML: element => {\n          const classAttribute = element.firstElementChild?.getAttribute('class')\n\n          if (!classAttribute) {\n            return null\n          }\n\n          const regexLanguageClassPrefix = new RegExp(`^(${this.options.languageClassPrefix})`)\n\n          return {\n            language: classAttribute.replace(regexLanguageClassPrefix, ''),\n          }\n        },\n        renderHTML: attributes => {\n          if (!attributes.language) {\n            return null\n          }\n\n          return {\n            class: this.options.languageClassPrefix + attributes.language,\n          }\n        },\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'pre',\n        preserveWhitespace: 'full',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['pre', this.options.HTMLAttributes, ['code', HTMLAttributes, 0]]\n  },\n\n  addCommands() {\n    return {\n      setCodeBlock: attributes => ({ commands }) => {\n        return commands.setNode('codeBlock', attributes)\n      },\n      toggleCodeBlock: attributes => ({ commands }) => {\n        return commands.toggleNode('codeBlock', 'paragraph', attributes)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const { empty, $anchor } = this.editor.state.selection\n        const isAtStart = $anchor.pos === 1\n\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false\n        }\n\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes()\n        }\n\n        return false\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      textblockTypeInputRule(backtickInputRegex, this.type, ({ groups }: any) => groups),\n      textblockTypeInputRule(tildeInputRegex, this.type, ({ groups }: any) => groups),\n    ]\n  },\n})\n"]},"metadata":{},"sourceType":"module"}