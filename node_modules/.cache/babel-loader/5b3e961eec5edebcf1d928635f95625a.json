{"ast":null,"code":"import { Editor as Editor$1, NodeView } from '@tiptap/core';\nexport * from '@tiptap/core';\nimport React, { useRef, useEffect, useState, createContext, useContext } from 'react';\nimport { BubbleMenuPlugin, BubbleMenuPluginKey } from '@tiptap/extension-bubble-menu';\nimport { FloatingMenuPlugin, FloatingMenuPluginKey } from '@tiptap/extension-floating-menu';\nimport ReactDOM from 'react-dom';\n\nconst BubbleMenu = props => {\n  const element = useRef(null);\n  useEffect(() => {\n    const {\n      editor,\n      tippyOptions\n    } = props;\n    editor.registerPlugin(BubbleMenuPlugin({\n      editor,\n      element: element.current,\n      tippyOptions\n    }));\n    return () => {\n      editor.unregisterPlugin(BubbleMenuPluginKey);\n    };\n  }, []);\n  return React.createElement(\"div\", {\n    ref: element,\n    className: props.className,\n    style: {\n      visibility: 'hidden'\n    }\n  }, props.children);\n};\n\nclass Editor extends Editor$1 {\n  constructor() {\n    super(...arguments);\n    this.contentComponent = null;\n  }\n\n}\n\nconst FloatingMenu = props => {\n  const element = useRef(null);\n  useEffect(() => {\n    const {\n      editor,\n      tippyOptions\n    } = props;\n    editor.registerPlugin(FloatingMenuPlugin({\n      editor,\n      element: element.current,\n      tippyOptions\n    }));\n    return () => {\n      editor.unregisterPlugin(FloatingMenuPluginKey);\n    };\n  }, []);\n  return React.createElement(\"div\", {\n    ref: element,\n    className: props.className,\n    style: {\n      visibility: 'hidden'\n    }\n  }, props.children);\n};\n\nfunction useForceUpdate() {\n  const [, setValue] = useState(0);\n  return () => setValue(value => value + 1);\n}\n\nconst useEditor = (options = {}, deps = []) => {\n  const [editor, setEditor] = useState(null);\n  const forceUpdate = useForceUpdate();\n  useEffect(() => {\n    const instance = new Editor(options);\n    setEditor(instance);\n    instance.on('transaction', forceUpdate);\n    return () => {\n      instance.destroy();\n    };\n  }, deps);\n  return editor;\n};\n\nfunction isClassComponent(Component) {\n  return !!(typeof Component === 'function' && Component.prototype && Component.prototype.isReactComponent);\n}\n\nclass ReactRenderer {\n  constructor(component, {\n    editor,\n    props = {},\n    as = 'div'\n  }) {\n    this.ref = null;\n    this.id = Math.floor(Math.random() * 0xFFFFFFFF).toString();\n    this.component = component;\n    this.editor = editor;\n    this.props = props;\n    this.element = document.createElement(as);\n    this.element.classList.add('react-renderer');\n    this.render();\n  }\n\n  render() {\n    var _a;\n\n    const Component = this.component;\n    const props = this.props;\n\n    if (isClassComponent(Component)) {\n      props.ref = ref => {\n        this.ref = ref;\n      };\n    }\n\n    this.reactElement = React.createElement(Component, { ...props\n    });\n\n    if ((_a = this.editor) === null || _a === void 0 ? void 0 : _a.contentComponent) {\n      this.editor.contentComponent.setState({\n        renderers: this.editor.contentComponent.state.renderers.set(this.id, this)\n      });\n    }\n  }\n\n  updateProps(props = {}) {\n    this.props = { ...this.props,\n      ...props\n    };\n    this.render();\n  }\n\n  destroy() {\n    var _a;\n\n    if ((_a = this.editor) === null || _a === void 0 ? void 0 : _a.contentComponent) {\n      const {\n        renderers\n      } = this.editor.contentComponent.state;\n      renderers.delete(this.id);\n      this.editor.contentComponent.setState({\n        renderers\n      });\n    }\n  }\n\n}\n\nconst ReactNodeViewContext = createContext({\n  onDragStart: undefined\n});\n\nconst useReactNodeView = () => useContext(ReactNodeViewContext);\n\nclass ReactNodeView extends NodeView {\n  mount() {\n    const props = {\n      editor: this.editor,\n      node: this.node,\n      decorations: this.decorations,\n      selected: false,\n      extension: this.extension,\n      getPos: () => this.getPos(),\n      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n      deleteNode: () => this.deleteNode()\n    };\n\n    if (!this.component.displayName) {\n      const capitalizeFirstChar = string => {\n        return string.charAt(0).toUpperCase() + string.substring(1);\n      };\n\n      this.component.displayName = capitalizeFirstChar(this.extension.name);\n    }\n\n    const ReactNodeViewProvider = componentProps => {\n      const onDragStart = this.onDragStart.bind(this);\n      const Component = this.component;\n      return React.createElement(ReactNodeViewContext.Provider, {\n        value: {\n          onDragStart\n        }\n      }, React.createElement(Component, { ...componentProps\n      }));\n    };\n\n    ReactNodeViewProvider.displayName = 'ReactNodeView';\n    this.contentDOMElement = this.node.isLeaf ? null : document.createElement(this.node.isInline ? 'span' : 'div');\n\n    if (this.contentDOMElement) {\n      // For some reason the whiteSpace prop is not inherited properly in Chrome and Safari\n      // With this fix it seems to work fine\n      // See: https://github.com/ueberdosis/tiptap/issues/1197\n      this.contentDOMElement.style.whiteSpace = 'inherit';\n    }\n\n    this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n      editor: this.editor,\n      props,\n      as: this.node.isInline ? 'span' : 'div'\n    });\n  }\n\n  get dom() {\n    var _a;\n\n    if (this.renderer.element.firstElementChild && !((_a = this.renderer.element.firstElementChild) === null || _a === void 0 ? void 0 : _a.hasAttribute('data-node-view-wrapper'))) {\n      throw Error('Please use the NodeViewWrapper component for your node view.');\n    }\n\n    return this.renderer.element;\n  }\n\n  get contentDOM() {\n    if (this.node.isLeaf) {\n      return null;\n    }\n\n    this.maybeMoveContentDOM();\n    return this.contentDOMElement;\n  }\n\n  maybeMoveContentDOM() {\n    const contentElement = this.dom.querySelector('[data-node-view-content]');\n\n    if (this.contentDOMElement && contentElement && !contentElement.contains(this.contentDOMElement)) {\n      contentElement.appendChild(this.contentDOMElement);\n    }\n  }\n\n  update(node, decorations) {\n    if (typeof this.options.update === 'function') {\n      return this.options.update(node, decorations);\n    }\n\n    if (node.type !== this.node.type) {\n      return false;\n    }\n\n    if (node === this.node && this.decorations === decorations) {\n      return true;\n    }\n\n    this.node = node;\n    this.decorations = decorations;\n    this.renderer.updateProps({\n      node,\n      decorations\n    });\n    this.maybeMoveContentDOM();\n    return true;\n  }\n\n  selectNode() {\n    this.renderer.updateProps({\n      selected: true\n    });\n  }\n\n  deselectNode() {\n    this.renderer.updateProps({\n      selected: false\n    });\n  }\n\n  destroy() {\n    this.renderer.destroy();\n    this.contentDOMElement = null;\n  }\n\n}\n\nfunction ReactNodeViewRenderer(component, options) {\n  return props => {\n    // try to get the parent component\n    // this is important for vue devtools to show the component hierarchy correctly\n    // maybe it’s `undefined` because <editor-content> isn’t rendered yet\n    if (!props.editor.contentComponent) {\n      return {};\n    }\n\n    return new ReactNodeView(component, props, options);\n  };\n}\n\nconst Portals = ({\n  renderers\n}) => {\n  return React.createElement(React.Fragment, null, Array.from(renderers).map(([key, renderer]) => {\n    return ReactDOM.createPortal(renderer.reactElement, renderer.element, key);\n  }));\n};\n\nclass PureEditorContent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.editorContentRef = React.createRef();\n    this.state = {\n      renderers: new Map()\n    };\n  }\n\n  componentDidMount() {\n    this.init();\n  }\n\n  componentDidUpdate() {\n    this.init();\n  }\n\n  init() {\n    const {\n      editor\n    } = this.props;\n\n    if (editor && editor.options.element) {\n      if (editor.contentComponent) {\n        return;\n      }\n\n      const element = this.editorContentRef.current;\n      element.append(...editor.options.element.childNodes);\n      editor.setOptions({\n        element\n      });\n      editor.contentComponent = this; // TODO: alternative to setTimeout?\n\n      setTimeout(() => editor.createNodeViews(), 0);\n    }\n  }\n\n  componentWillUnmount() {\n    const {\n      editor\n    } = this.props;\n\n    if (!editor) {\n      return;\n    }\n\n    if (!editor.isDestroyed) {\n      editor.view.setProps({\n        nodeViews: {}\n      });\n    }\n\n    editor.contentComponent = null;\n\n    if (!editor.options.element.firstChild) {\n      return;\n    }\n\n    const newElement = document.createElement('div');\n    newElement.append(...editor.options.element.childNodes);\n    editor.setOptions({\n      element: newElement\n    });\n  }\n\n  render() {\n    const {\n      editor,\n      ...rest\n    } = this.props;\n    return React.createElement(React.Fragment, null, React.createElement(\"div\", {\n      ref: this.editorContentRef,\n      ...rest\n    }), React.createElement(Portals, {\n      renderers: this.state.renderers\n    }));\n  }\n\n}\n\nconst EditorContent = React.memo(PureEditorContent);\n\nconst NodeViewWrapper = props => {\n  const {\n    onDragStart\n  } = useReactNodeView();\n  const Tag = props.as || 'div';\n  return React.createElement(Tag, { ...props,\n    \"data-node-view-wrapper\": \"\",\n    onDragStart: onDragStart,\n    style: { ...props.style,\n      whiteSpace: 'normal'\n    }\n  });\n};\n\nconst NodeViewContent = props => {\n  const Tag = props.as || 'div';\n  return React.createElement(Tag, { ...props,\n    \"data-node-view-content\": \"\",\n    style: { ...props.style,\n      whiteSpace: 'pre-wrap'\n    }\n  });\n};\n\nexport { BubbleMenu, Editor, EditorContent, FloatingMenu, NodeViewContent, NodeViewWrapper, PureEditorContent, ReactNodeViewRenderer, ReactRenderer, useEditor };","map":null,"metadata":{},"sourceType":"module"}