{"ast":null,"code":"import _assertThisInitialized from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _objectSpread from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { Plugin, PluginKey, TextSelection, Selection, NodeSelection, EditorState } from 'prosemirror-state';\nimport { EditorView } from 'prosemirror-view';\nimport { Fragment, DOMParser, DOMSerializer, Schema, Slice, Node as Node$1 } from 'prosemirror-model';\nimport { keymap } from 'prosemirror-keymap';\nimport { inputRules, undoInputRule as undoInputRule$2, InputRule } from 'prosemirror-inputrules';\nimport { liftTarget, ReplaceStep, ReplaceAroundStep, canSplit } from 'prosemirror-transform';\nimport { createParagraphNear as createParagraphNear$2, deleteSelection as deleteSelection$2, exitCode as exitCode$2, joinBackward as joinBackward$2, joinForward as joinForward$2, lift as lift$2, liftEmptyBlock as liftEmptyBlock$2, newlineInCode as newlineInCode$2, selectAll as selectAll$2, selectNodeBackward as selectNodeBackward$2, selectNodeForward as selectNodeForward$2, selectParentNode as selectParentNode$2, setBlockType, wrapIn as wrapIn$2 } from 'prosemirror-commands';\nimport { liftListItem as liftListItem$2, sinkListItem as sinkListItem$2, wrapInList as wrapInList$2 } from 'prosemirror-schema-list';\n\nfunction getSchemaTypeNameByName(name, schema) {\n  if (schema.nodes[name]) {\n    return 'node';\n  }\n\n  if (schema.marks[name]) {\n    return 'mark';\n  }\n\n  return null;\n}\n\nfunction getNodeType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(\"There is no node type named '\".concat(nameOrType, \"'. Maybe you forgot to add the extension?\"));\n    }\n\n    return schema.nodes[nameOrType];\n  }\n\n  return nameOrType;\n}\n\nfunction _getNodeAttributes(state, typeOrName) {\n  var type = getNodeType(typeOrName, state.schema);\n  var _state$selection = state.selection,\n      from = _state$selection.from,\n      to = _state$selection.to;\n  var nodes = [];\n  state.doc.nodesBetween(from, to, function (node) {\n    nodes = [].concat(_toConsumableArray(nodes), [node]);\n  });\n  var node = nodes.reverse().find(function (nodeItem) {\n    return nodeItem.type.name === type.name;\n  });\n\n  if (node) {\n    return _objectSpread({}, node.attrs);\n  }\n\n  return {};\n}\n\nfunction getMarkType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(\"There is no mark type named '\".concat(nameOrType, \"'. Maybe you forgot to add the extension?\"));\n    }\n\n    return schema.marks[nameOrType];\n  }\n\n  return nameOrType;\n}\n\nfunction _getMarkAttributes(state, typeOrName) {\n  var type = getMarkType(typeOrName, state.schema);\n  var _state$selection2 = state.selection,\n      from = _state$selection2.from,\n      to = _state$selection2.to,\n      empty = _state$selection2.empty;\n  var marks = [];\n\n  if (empty) {\n    marks = state.selection.$head.marks();\n  } else {\n    state.doc.nodesBetween(from, to, function (node) {\n      marks = [].concat(_toConsumableArray(marks), _toConsumableArray(node.marks));\n    });\n  }\n\n  var mark = marks.find(function (markItem) {\n    return markItem.type.name === type.name;\n  });\n\n  if (mark) {\n    return _objectSpread({}, mark.attrs);\n  }\n\n  return {};\n}\n\nfunction _getAttributes(state, typeOrName) {\n  var schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n\n  if (schemaType === 'node') {\n    return _getNodeAttributes(state, typeOrName);\n  }\n\n  if (schemaType === 'mark') {\n    return _getMarkAttributes(state, typeOrName);\n  }\n\n  return {};\n}\n/**\r\n * Check if object1 includes object2\r\n * @param object1 Object\r\n * @param object2 Object\r\n */\n\n\nfunction objectIncludes(object1, object2) {\n  var keys = Object.keys(object2);\n\n  if (!keys.length) {\n    return true;\n  }\n\n  return !!keys.filter(function (key) {\n    return object2[key] === object1[key];\n  }).length;\n}\n\nfunction isNodeActive(state, typeOrName) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _state$selection3 = state.selection,\n      from = _state$selection3.from,\n      to = _state$selection3.to,\n      empty = _state$selection3.empty;\n  var type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n  var nodeRanges = [];\n  state.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isText) {\n      var relativeFrom = Math.max(from, pos);\n      var relativeTo = Math.min(to, pos + node.nodeSize);\n      nodeRanges = [].concat(_toConsumableArray(nodeRanges), [{\n        node: node,\n        from: relativeFrom,\n        to: relativeTo\n      }]);\n    }\n  });\n\n  if (empty) {\n    return !!nodeRanges.filter(function (nodeRange) {\n      if (!type) {\n        return true;\n      }\n\n      return type.name === nodeRange.node.type.name;\n    }).find(function (nodeRange) {\n      return objectIncludes(nodeRange.node.attrs, attributes);\n    });\n  }\n\n  var selectionRange = to - from;\n  var range = nodeRanges.filter(function (nodeRange) {\n    if (!type) {\n      return true;\n    }\n\n    return type.name === nodeRange.node.type.name;\n  }).filter(function (nodeRange) {\n    return objectIncludes(nodeRange.node.attrs, attributes);\n  }).reduce(function (sum, nodeRange) {\n    var size = nodeRange.to - nodeRange.from;\n    return sum + size;\n  }, 0);\n  return range >= selectionRange;\n}\n\nfunction isMarkActive(state, typeOrName) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _state$selection4 = state.selection,\n      from = _state$selection4.from,\n      to = _state$selection4.to,\n      empty = _state$selection4.empty;\n  var type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks()).filter(function (mark) {\n      if (!type) {\n        return true;\n      }\n\n      return type.name === mark.type.name;\n    }).find(function (mark) {\n      return objectIncludes(mark.attrs, attributes);\n    });\n  }\n\n  var selectionRange = 0;\n  var markRanges = [];\n  state.doc.nodesBetween(from, to, function (node, pos) {\n    if (node.isText) {\n      var relativeFrom = Math.max(from, pos);\n      var relativeTo = Math.min(to, pos + node.nodeSize);\n\n      var _range = relativeTo - relativeFrom;\n\n      selectionRange += _range;\n      markRanges = [].concat(_toConsumableArray(markRanges), _toConsumableArray(node.marks.map(function (mark) {\n        return {\n          mark: mark,\n          from: relativeFrom,\n          to: relativeTo\n        };\n      })));\n    }\n  });\n\n  if (selectionRange === 0) {\n    return false;\n  } // calculate range of matched mark\n\n\n  var matchedRange = markRanges.filter(function (markRange) {\n    if (!type) {\n      return true;\n    }\n\n    return type.name === markRange.mark.type.name;\n  }).filter(function (markRange) {\n    return objectIncludes(markRange.mark.attrs, attributes);\n  }).reduce(function (sum, markRange) {\n    var size = markRange.to - markRange.from;\n    return sum + size;\n  }, 0); // calculate range of marks that excludes the searched mark\n  // for example `code` doesnâ€™t allow any other marks\n\n  var excludedRange = markRanges.filter(function (markRange) {\n    if (!type) {\n      return true;\n    }\n\n    return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n  }).reduce(function (sum, markRange) {\n    var size = markRange.to - markRange.from;\n    return sum + size;\n  }, 0); // we only include the result of `excludedRange`\n  // if there is a match at all\n\n  var range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n  return range >= selectionRange;\n}\n\nfunction _isActive(state, name) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n  }\n\n  var schemaType = getSchemaTypeNameByName(name, state.schema);\n\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes);\n  }\n\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes);\n  }\n\n  return false;\n}\n\nfunction removeElement(element) {\n  if (element && element.parentNode) {\n    element.parentNode.removeChild(element);\n  }\n}\n\nfunction elementFromString(value) {\n  // add a wrapper to preserve leading and trailing whitespace\n  var wrappedValue = \"<body>\".concat(value, \"</body>\");\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;\n}\n\nfunction createNodeFromContent(content, schema, options) {\n  options = _objectSpread({\n    slice: true,\n    parseOptions: {}\n  }, options);\n\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content)) {\n        return Fragment.fromArray(content.map(function (item) {\n          return schema.nodeFromJSON(item);\n        }));\n      }\n\n      return schema.nodeFromJSON(content);\n    } catch (error) {\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);\n      return createNodeFromContent('', schema, options);\n    }\n  }\n\n  if (typeof content === 'string') {\n    var parser = DOMParser.fromSchema(schema);\n    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);\n  }\n\n  return createNodeFromContent('', schema, options);\n}\n\nfunction createDocument(content, schema) {\n  var parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return createNodeFromContent(content, schema, {\n    slice: false,\n    parseOptions: parseOptions\n  });\n}\n\nfunction getHTMLFromFragment(doc, schema) {\n  var fragment = DOMSerializer.fromSchema(schema).serializeFragment(doc.content);\n  var temporaryDocument = document.implementation.createHTMLDocument();\n  var container = temporaryDocument.createElement('div');\n  container.appendChild(fragment);\n  return container.innerHTML;\n}\n\nfunction isNodeEmpty(node) {\n  var _a;\n\n  var defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();\n  var content = node.toJSON();\n  return JSON.stringify(defaultContent) === JSON.stringify(content);\n}\n\nfunction createStyleTag(style) {\n  var tipTapStyleTag = document.querySelector('style[data-tiptap-style]');\n\n  if (tipTapStyleTag !== null) {\n    return tipTapStyleTag;\n  }\n\n  var styleNode = document.createElement('style');\n  styleNode.setAttribute('data-tiptap-style', '');\n  styleNode.innerHTML = style;\n  document.getElementsByTagName('head')[0].appendChild(styleNode);\n  return styleNode;\n}\n\nvar CommandManager = /*#__PURE__*/function () {\n  function CommandManager(editor, commands) {\n    _classCallCheck(this, CommandManager);\n\n    this.editor = editor;\n    this.commands = commands;\n  }\n\n  _createClass(CommandManager, [{\n    key: \"createCommands\",\n    value: function createCommands() {\n      var commands = this.commands,\n          editor = this.editor;\n      var state = editor.state,\n          view = editor.view;\n      var tr = state.tr;\n      var props = this.buildProps(tr);\n      return Object.fromEntries(Object.entries(commands).map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            name = _ref2[0],\n            command = _ref2[1];\n\n        var method = function method() {\n          var callback = command.apply(void 0, arguments)(props);\n\n          if (!tr.getMeta('preventDispatch')) {\n            view.dispatch(tr);\n          }\n\n          return callback;\n        };\n\n        return [name, method];\n      }));\n    }\n  }, {\n    key: \"createChain\",\n    value: function createChain(startTr) {\n      var _this = this;\n\n      var shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var commands = this.commands,\n          editor = this.editor;\n      var state = editor.state,\n          view = editor.view;\n      var callbacks = [];\n      var hasStartTransaction = !!startTr;\n      var tr = startTr || state.tr;\n\n      var run = function run() {\n        if (!hasStartTransaction && shouldDispatch && !tr.getMeta('preventDispatch')) {\n          view.dispatch(tr);\n        }\n\n        return callbacks.every(function (callback) {\n          return callback === true;\n        });\n      };\n\n      var chain = _objectSpread(_objectSpread({}, Object.fromEntries(Object.entries(commands).map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            name = _ref4[0],\n            command = _ref4[1];\n\n        var chainedCommand = function chainedCommand() {\n          var props = _this.buildProps(tr, shouldDispatch);\n\n          var callback = command.apply(void 0, arguments)(props);\n          callbacks.push(callback);\n          return chain;\n        };\n\n        return [name, chainedCommand];\n      }))), {}, {\n        run: run\n      });\n\n      return chain;\n    }\n  }, {\n    key: \"createCan\",\n    value: function createCan(startTr) {\n      var _this2 = this;\n\n      var commands = this.commands,\n          editor = this.editor;\n      var state = editor.state;\n      var dispatch = undefined;\n      var tr = startTr || state.tr;\n      var props = this.buildProps(tr, dispatch);\n      var formattedCommands = Object.fromEntries(Object.entries(commands).map(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            name = _ref6[0],\n            command = _ref6[1];\n\n        return [name, function () {\n          return command.apply(void 0, arguments)(_objectSpread(_objectSpread({}, props), {}, {\n            dispatch: dispatch\n          }));\n        }];\n      }));\n      return _objectSpread(_objectSpread({}, formattedCommands), {}, {\n        chain: function chain() {\n          return _this2.createChain(tr, dispatch);\n        }\n      });\n    }\n  }, {\n    key: \"buildProps\",\n    value: function buildProps(tr) {\n      var _this3 = this;\n\n      var shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var editor = this.editor,\n          commands = this.commands;\n      var state = editor.state,\n          view = editor.view;\n\n      if (state.storedMarks) {\n        tr.setStoredMarks(state.storedMarks);\n      }\n\n      var props = {\n        tr: tr,\n        editor: editor,\n        view: view,\n        state: this.chainableState(tr, state),\n        dispatch: shouldDispatch ? function () {\n          return undefined;\n        } : undefined,\n        chain: function chain() {\n          return _this3.createChain(tr);\n        },\n        can: function can() {\n          return _this3.createCan(tr);\n        },\n\n        get commands() {\n          return Object.fromEntries(Object.entries(commands).map(function (_ref7) {\n            var _ref8 = _slicedToArray(_ref7, 2),\n                name = _ref8[0],\n                command = _ref8[1];\n\n            return [name, function () {\n              return command.apply(void 0, arguments)(props);\n            }];\n          }));\n        }\n\n      };\n      return props;\n    }\n  }, {\n    key: \"chainableState\",\n    value: function chainableState(tr, state) {\n      var selection = tr.selection;\n      var doc = tr.doc;\n      var storedMarks = tr.storedMarks;\n      return _objectSpread(_objectSpread({}, state), {}, {\n        schema: state.schema,\n        plugins: state.plugins,\n        apply: state.apply.bind(state),\n        applyTransaction: state.applyTransaction.bind(state),\n        reconfigure: state.reconfigure.bind(state),\n        toJSON: state.toJSON.bind(state),\n\n        get storedMarks() {\n          return storedMarks;\n        },\n\n        get selection() {\n          return selection;\n        },\n\n        get doc() {\n          return doc;\n        },\n\n        get tr() {\n          selection = tr.selection;\n          doc = tr.doc;\n          storedMarks = tr.storedMarks;\n          return tr;\n        }\n\n      });\n    }\n  }]);\n\n  return CommandManager;\n}();\n\nfunction getExtensionField(extension, field) {\n  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context);\n  }\n\n  if (typeof extension.config[field] === 'function') {\n    var value = extension.config[field].bind(_objectSpread(_objectSpread({}, context), {}, {\n      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n    }));\n    return value;\n  }\n\n  return extension.config[field];\n}\n\nfunction splitExtensions(extensions) {\n  var baseExtensions = extensions.filter(function (extension) {\n    return extension.type === 'extension';\n  });\n  var nodeExtensions = extensions.filter(function (extension) {\n    return extension.type === 'node';\n  });\n  var markExtensions = extensions.filter(function (extension) {\n    return extension.type === 'mark';\n  });\n  return {\n    baseExtensions: baseExtensions,\n    nodeExtensions: nodeExtensions,\n    markExtensions: markExtensions\n  };\n}\n/**\r\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\r\n * @param extensions List of extensions\r\n */\n\n\nfunction getAttributesFromExtensions(extensions) {\n  var extensionAttributes = [];\n\n  var _splitExtensions = splitExtensions(extensions),\n      nodeExtensions = _splitExtensions.nodeExtensions,\n      markExtensions = _splitExtensions.markExtensions;\n\n  var nodeAndMarkExtensions = [].concat(_toConsumableArray(nodeExtensions), _toConsumableArray(markExtensions));\n  var defaultAttribute = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true\n  };\n  extensions.forEach(function (extension) {\n    var context = {\n      name: extension.name,\n      options: extension.options\n    };\n    var addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);\n\n    if (!addGlobalAttributes) {\n      return;\n    } // TODO: remove `as GlobalAttributes`\n\n\n    var globalAttributes = addGlobalAttributes();\n    globalAttributes.forEach(function (globalAttribute) {\n      globalAttribute.types.forEach(function (type) {\n        Object.entries(globalAttribute.attributes).forEach(function (_ref9) {\n          var _ref10 = _slicedToArray(_ref9, 2),\n              name = _ref10[0],\n              attribute = _ref10[1];\n\n          extensionAttributes.push({\n            type: type,\n            name: name,\n            attribute: _objectSpread(_objectSpread({}, defaultAttribute), attribute)\n          });\n        });\n      });\n    });\n  });\n  nodeAndMarkExtensions.forEach(function (extension) {\n    var context = {\n      name: extension.name,\n      options: extension.options\n    };\n    var addAttributes = getExtensionField(extension, 'addAttributes', context);\n\n    if (!addAttributes) {\n      return;\n    } // TODO: remove `as Attributes`\n\n\n    var attributes = addAttributes();\n    Object.entries(attributes).forEach(function (_ref11) {\n      var _ref12 = _slicedToArray(_ref11, 2),\n          name = _ref12[0],\n          attribute = _ref12[1];\n\n      extensionAttributes.push({\n        type: extension.name,\n        name: name,\n        attribute: _objectSpread(_objectSpread({}, defaultAttribute), attribute)\n      });\n    });\n  });\n  return extensionAttributes;\n}\n\nfunction mergeAttributes() {\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  return objects.filter(function (item) {\n    return !!item;\n  }).reduce(function (items, item) {\n    var mergedAttributes = _objectSpread({}, items);\n\n    Object.entries(item).forEach(function (_ref13) {\n      var _ref14 = _slicedToArray(_ref13, 2),\n          key = _ref14[0],\n          value = _ref14[1];\n\n      var exists = mergedAttributes[key];\n\n      if (!exists) {\n        mergedAttributes[key] = value;\n        return;\n      }\n\n      if (key === 'class') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join(' ');\n      } else if (key === 'style') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join('; ');\n      } else {\n        mergedAttributes[key] = value;\n      }\n    });\n    return mergedAttributes;\n  }, {});\n}\n\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n  return extensionAttributes.filter(function (item) {\n    return item.attribute.rendered;\n  }).map(function (item) {\n    if (!item.attribute.renderHTML) {\n      return _defineProperty({}, item.name, nodeOrMark.attrs[item.name]);\n    }\n\n    return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n  }).reduce(function (attributes, attribute) {\n    return mergeAttributes(attributes, attribute);\n  }, {});\n}\n\nfunction isEmptyObject() {\n  var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return Object.keys(object).length === 0 && object.constructor === Object;\n}\n\nfunction fromString(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  if (value.match(/^\\d*(\\.\\d+)?$/)) {\n    return Number(value);\n  }\n\n  if (value === 'true') {\n    return true;\n  }\n\n  if (value === 'false') {\n    return false;\n  }\n\n  return value;\n}\n/**\r\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\r\n * Cancels when `getAttrs` returned `false`.\r\n * @param parseRule ProseMirror ParseRule\r\n * @param extensionAttributes List of attributes to inject\r\n */\n\n\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n  if (parseRule.style) {\n    return parseRule;\n  }\n\n  return _objectSpread(_objectSpread({}, parseRule), {}, {\n    getAttrs: function getAttrs(node) {\n      var oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n\n      if (oldAttributes === false) {\n        return false;\n      }\n\n      var newAttributes = extensionAttributes.filter(function (item) {\n        return item.attribute.rendered;\n      }).reduce(function (items, item) {\n        var attributes = item.attribute.parseHTML ? item.attribute.parseHTML(node) || {} : _defineProperty({}, item.name, fromString(node.getAttribute(item.name)));\n        var filteredAttributes = Object.fromEntries(Object.entries(attributes).filter(function (_ref17) {\n          var _ref18 = _slicedToArray(_ref17, 2),\n              value = _ref18[1];\n\n          return value !== undefined && value !== null;\n        }));\n        return _objectSpread(_objectSpread({}, items), filteredAttributes);\n      }, {});\n      return _objectSpread(_objectSpread({}, oldAttributes), newAttributes);\n    }\n  });\n}\n/**\r\n * Optionally calls `value` as a function.\r\n * Otherwise it is returned directly.\r\n * @param value Function or any value.\r\n * @param context Optional context to bind to function.\r\n * @param props Optional props to pass to function.\r\n */\n\n\nfunction callOrReturn(value) {\n  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n  if (typeof value === 'function') {\n    for (var _len2 = arguments.length, props = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      props[_key2 - 2] = arguments[_key2];\n    }\n\n    if (context) {\n      return value.bind(context).apply(void 0, props);\n    }\n\n    return value.apply(void 0, props);\n  }\n\n  return value;\n}\n\nfunction cleanUpSchemaItem(data) {\n  return Object.fromEntries(Object.entries(data).filter(function (_ref19) {\n    var _ref20 = _slicedToArray(_ref19, 2),\n        key = _ref20[0],\n        value = _ref20[1];\n\n    if (key === 'attrs' && isEmptyObject(value)) {\n      return false;\n    }\n\n    return value !== null && value !== undefined;\n  }));\n}\n\nfunction getSchemaByResolvedExtensions(extensions) {\n  var _a;\n\n  var allAttributes = getAttributesFromExtensions(extensions);\n\n  var _splitExtensions2 = splitExtensions(extensions),\n      nodeExtensions = _splitExtensions2.nodeExtensions,\n      markExtensions = _splitExtensions2.markExtensions;\n\n  var topNode = (_a = nodeExtensions.find(function (extension) {\n    return getExtensionField(extension, 'topNode');\n  })) === null || _a === void 0 ? void 0 : _a.name;\n  var nodes = Object.fromEntries(nodeExtensions.map(function (extension) {\n    var extensionAttributes = allAttributes.filter(function (attribute) {\n      return attribute.type === extension.name;\n    });\n    var context = {\n      name: extension.name,\n      options: extension.options\n    };\n    var extraNodeFields = extensions.reduce(function (fields, e) {\n      var extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);\n      return _objectSpread(_objectSpread({}, fields), extendNodeSchema ? extendNodeSchema(extension) : {});\n    }, {});\n    var schema = cleanUpSchemaItem(_objectSpread(_objectSpread({}, extraNodeFields), {}, {\n      content: callOrReturn(getExtensionField(extension, 'content', context)),\n      marks: callOrReturn(getExtensionField(extension, 'marks', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      inline: callOrReturn(getExtensionField(extension, 'inline', context)),\n      atom: callOrReturn(getExtensionField(extension, 'atom', context)),\n      selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),\n      draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      defining: callOrReturn(getExtensionField(extension, 'defining', context)),\n      isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(function (extensionAttribute) {\n        var _a;\n\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    }));\n    var parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(function (parseRule) {\n        return injectExtensionAttributesToParseRule(parseRule, extensionAttributes);\n      });\n    }\n\n    var renderHTML = getExtensionField(extension, 'renderHTML', context);\n\n    if (renderHTML) {\n      schema.toDOM = function (node) {\n        return renderHTML({\n          node: node,\n          HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n        });\n      };\n    }\n\n    return [extension.name, schema];\n  }));\n  var marks = Object.fromEntries(markExtensions.map(function (extension) {\n    var extensionAttributes = allAttributes.filter(function (attribute) {\n      return attribute.type === extension.name;\n    });\n    var context = {\n      name: extension.name,\n      options: extension.options\n    };\n    var extraMarkFields = extensions.reduce(function (fields, e) {\n      var extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);\n      return _objectSpread(_objectSpread({}, fields), extendMarkSchema ? extendMarkSchema(extension) : {});\n    }, {});\n    var schema = cleanUpSchemaItem(_objectSpread(_objectSpread({}, extraMarkFields), {}, {\n      inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),\n      excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(function (extensionAttribute) {\n        var _a;\n\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    }));\n    var parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(function (parseRule) {\n        return injectExtensionAttributesToParseRule(parseRule, extensionAttributes);\n      });\n    }\n\n    var renderHTML = getExtensionField(extension, 'renderHTML', context);\n\n    if (renderHTML) {\n      schema.toDOM = function (mark) {\n        return renderHTML({\n          mark: mark,\n          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n        });\n      };\n    }\n\n    return [extension.name, schema];\n  }));\n  return new Schema({\n    topNode: topNode,\n    nodes: nodes,\n    marks: marks\n  });\n}\n\nfunction getSchemaTypeByName(name, schema) {\n  if (schema.nodes[name]) {\n    return schema.nodes[name];\n  }\n\n  if (schema.marks[name]) {\n    return schema.marks[name];\n  }\n\n  return null;\n}\n\nvar ExtensionManager = /*#__PURE__*/function () {\n  function ExtensionManager(extensions, editor) {\n    var _this4 = this;\n\n    _classCallCheck(this, ExtensionManager);\n\n    this.splittableMarks = [];\n    this.editor = editor;\n    this.extensions = ExtensionManager.resolve(extensions);\n    this.schema = getSchemaByResolvedExtensions(this.extensions);\n    this.extensions.forEach(function (extension) {\n      var _a;\n\n      var context = {\n        name: extension.name,\n        options: extension.options,\n        editor: _this4.editor,\n        type: getSchemaTypeByName(extension.name, _this4.schema)\n      };\n\n      if (extension.type === 'mark') {\n        var keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;\n\n        if (keepOnSplit) {\n          _this4.splittableMarks.push(extension.name);\n        }\n      }\n\n      var onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);\n\n      if (onBeforeCreate) {\n        _this4.editor.on('beforeCreate', onBeforeCreate);\n      }\n\n      var onCreate = getExtensionField(extension, 'onCreate', context);\n\n      if (onCreate) {\n        _this4.editor.on('create', onCreate);\n      }\n\n      var onUpdate = getExtensionField(extension, 'onUpdate', context);\n\n      if (onUpdate) {\n        _this4.editor.on('update', onUpdate);\n      }\n\n      var onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);\n\n      if (onSelectionUpdate) {\n        _this4.editor.on('selectionUpdate', onSelectionUpdate);\n      }\n\n      var onTransaction = getExtensionField(extension, 'onTransaction', context);\n\n      if (onTransaction) {\n        _this4.editor.on('transaction', onTransaction);\n      }\n\n      var onFocus = getExtensionField(extension, 'onFocus', context);\n\n      if (onFocus) {\n        _this4.editor.on('focus', onFocus);\n      }\n\n      var onBlur = getExtensionField(extension, 'onBlur', context);\n\n      if (onBlur) {\n        _this4.editor.on('blur', onBlur);\n      }\n\n      var onDestroy = getExtensionField(extension, 'onDestroy', context);\n\n      if (onDestroy) {\n        _this4.editor.on('destroy', onDestroy);\n      }\n    });\n  }\n\n  _createClass(ExtensionManager, [{\n    key: \"commands\",\n    get: function get() {\n      var _this5 = this;\n\n      return this.extensions.reduce(function (commands, extension) {\n        var context = {\n          name: extension.name,\n          options: extension.options,\n          editor: _this5.editor,\n          type: getSchemaTypeByName(extension.name, _this5.schema)\n        };\n        var addCommands = getExtensionField(extension, 'addCommands', context);\n\n        if (!addCommands) {\n          return commands;\n        }\n\n        return _objectSpread(_objectSpread({}, commands), addCommands());\n      }, {});\n    }\n  }, {\n    key: \"plugins\",\n    get: function get() {\n      var _this6 = this;\n\n      return _toConsumableArray(this.extensions).reverse().map(function (extension) {\n        var context = {\n          name: extension.name,\n          options: extension.options,\n          editor: _this6.editor,\n          type: getSchemaTypeByName(extension.name, _this6.schema)\n        };\n        var plugins = [];\n        var addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);\n\n        if (addKeyboardShortcuts) {\n          var bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(function (_ref21) {\n            var _ref22 = _slicedToArray(_ref21, 2),\n                shortcut = _ref22[0],\n                method = _ref22[1];\n\n            return [shortcut, function () {\n              return method({\n                editor: _this6.editor\n              });\n            }];\n          }));\n          var keyMapPlugin = keymap(bindings);\n          plugins.push(keyMapPlugin);\n        }\n\n        var addInputRules = getExtensionField(extension, 'addInputRules', context);\n\n        if (_this6.editor.options.enableInputRules && addInputRules) {\n          var inputRules$1 = addInputRules();\n          var inputRulePlugins = inputRules$1.length ? [inputRules({\n            rules: inputRules$1\n          })] : [];\n          plugins.push.apply(plugins, inputRulePlugins);\n        }\n\n        var addPasteRules = getExtensionField(extension, 'addPasteRules', context);\n\n        if (_this6.editor.options.enablePasteRules && addPasteRules) {\n          var pasteRulePlugins = addPasteRules();\n          plugins.push.apply(plugins, _toConsumableArray(pasteRulePlugins));\n        }\n\n        var addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);\n\n        if (addProseMirrorPlugins) {\n          var proseMirrorPlugins = addProseMirrorPlugins();\n          plugins.push.apply(plugins, _toConsumableArray(proseMirrorPlugins));\n        }\n\n        return plugins;\n      }).flat();\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      return getAttributesFromExtensions(this.extensions);\n    }\n  }, {\n    key: \"nodeViews\",\n    get: function get() {\n      var _this7 = this;\n\n      var editor = this.editor;\n\n      var _splitExtensions3 = splitExtensions(this.extensions),\n          nodeExtensions = _splitExtensions3.nodeExtensions;\n\n      return Object.fromEntries(nodeExtensions.filter(function (extension) {\n        return !!getExtensionField(extension, 'addNodeView');\n      }).map(function (extension) {\n        var extensionAttributes = _this7.attributes.filter(function (attribute) {\n          return attribute.type === extension.name;\n        });\n\n        var context = {\n          name: extension.name,\n          options: extension.options,\n          editor: editor,\n          type: getNodeType(extension.name, _this7.schema)\n        };\n        var addNodeView = getExtensionField(extension, 'addNodeView', context);\n\n        if (!addNodeView) {\n          return [];\n        }\n\n        var nodeview = function nodeview(node, view, getPos, decorations) {\n          var HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n          return addNodeView()({\n            editor: editor,\n            node: node,\n            getPos: getPos,\n            decorations: decorations,\n            HTMLAttributes: HTMLAttributes,\n            extension: extension\n          });\n        };\n\n        return [extension.name, nodeview];\n      }));\n    }\n  }, {\n    key: \"textSerializers\",\n    get: function get() {\n      var _this8 = this;\n\n      var editor = this.editor;\n\n      var _splitExtensions4 = splitExtensions(this.extensions),\n          nodeExtensions = _splitExtensions4.nodeExtensions;\n\n      return Object.fromEntries(nodeExtensions.filter(function (extension) {\n        return !!getExtensionField(extension, 'renderText');\n      }).map(function (extension) {\n        var context = {\n          name: extension.name,\n          options: extension.options,\n          editor: editor,\n          type: getNodeType(extension.name, _this8.schema)\n        };\n        var renderText = getExtensionField(extension, 'renderText', context);\n\n        if (!renderText) {\n          return [];\n        }\n\n        var textSerializer = function textSerializer(props) {\n          return renderText(props);\n        };\n\n        return [extension.name, textSerializer];\n      }));\n    }\n  }], [{\n    key: \"resolve\",\n    value: function resolve(extensions) {\n      return ExtensionManager.sort(ExtensionManager.flatten(extensions));\n    }\n  }, {\n    key: \"flatten\",\n    value: function flatten(extensions) {\n      var _this9 = this;\n\n      return extensions.map(function (extension) {\n        var context = {\n          name: extension.name,\n          options: extension.options\n        };\n        var addExtensions = getExtensionField(extension, 'addExtensions', context);\n\n        if (addExtensions) {\n          return [extension].concat(_toConsumableArray(_this9.flatten(addExtensions())));\n        }\n\n        return extension;\n      }) // `Infinity` will break TypeScript so we set a number that is probably high enough\n      .flat(10);\n    }\n  }, {\n    key: \"sort\",\n    value: function sort(extensions) {\n      var defaultPriority = 100;\n      return extensions.sort(function (a, b) {\n        var priorityA = getExtensionField(a, 'priority') || defaultPriority;\n        var priorityB = getExtensionField(b, 'priority') || defaultPriority;\n\n        if (priorityA > priorityB) {\n          return -1;\n        }\n\n        if (priorityA < priorityB) {\n          return 1;\n        }\n\n        return 0;\n      });\n    }\n  }]);\n\n  return ExtensionManager;\n}();\n\nvar EventEmitter = /*#__PURE__*/function () {\n  function EventEmitter() {\n    _classCallCheck(this, EventEmitter);\n\n    this.callbacks = {};\n  }\n\n  _createClass(EventEmitter, [{\n    key: \"on\",\n    value: function on(event, fn) {\n      if (!this.callbacks[event]) {\n        this.callbacks[event] = [];\n      }\n\n      this.callbacks[event].push(fn);\n      return this;\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      var _this10 = this;\n\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      var callbacks = this.callbacks[event];\n\n      if (callbacks) {\n        callbacks.forEach(function (callback) {\n          return callback.apply(_this10, args);\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, fn) {\n      var callbacks = this.callbacks[event];\n\n      if (callbacks) {\n        if (fn) {\n          this.callbacks[event] = callbacks.filter(function (callback) {\n            return callback !== fn;\n          });\n        } else {\n          delete this.callbacks[event];\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners() {\n      this.callbacks = {};\n    }\n  }]);\n\n  return EventEmitter;\n}(); // see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\n\n\nfunction getType(payload) {\n  return Object.prototype.toString.call(payload).slice(8, -1);\n}\n\nfunction isPlainObject(payload) {\n  if (getType(payload) !== 'Object') return false;\n  return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;\n}\n\nfunction mergeDeep(target, source) {\n  var output = _objectSpread({}, target);\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(function (key) {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, _defineProperty({}, key, source[key]));\n        } else {\n          output[key] = mergeDeep(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, _defineProperty({}, key, source[key]));\n      }\n    });\n  }\n\n  return output;\n}\n\nvar Extension = /*#__PURE__*/function () {\n  function Extension() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Extension);\n\n    this.type = 'extension';\n    this.name = 'extension';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = _objectSpread(_objectSpread({}, this.config), config);\n    this.name = this.config.name;\n    this.options = this.config.defaultOptions;\n  }\n\n  _createClass(Extension, [{\n    key: \"configure\",\n    value: function configure() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // return a new instance so we can use the same extension\n      // with different calls of `configure`\n      var extension = this.extend();\n      extension.options = mergeDeep(this.options, options);\n      return extension;\n    }\n  }, {\n    key: \"extend\",\n    value: function extend() {\n      var extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var extension = new Extension(extendedConfig);\n      extension.parent = this;\n      this.child = extension;\n      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n      extension.options = extendedConfig.defaultOptions ? extendedConfig.defaultOptions : extension.parent.options;\n      return extension;\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new Extension(config);\n    }\n  }]);\n\n  return Extension;\n}();\n\nvar textBetween = function textBetween(editor, from, to, blockSeparator, leafText) {\n  var text = '';\n  var separated = true;\n  editor.state.doc.nodesBetween(from, to, function (node, pos) {\n    var _a;\n\n    var textSerializer = editor.extensionManager.textSerializers[node.type.name];\n\n    if (textSerializer) {\n      text += textSerializer({\n        node: node\n      });\n      separated = !blockSeparator;\n    } else if (node.isText) {\n      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);\n      separated = !blockSeparator;\n    } else if (node.isLeaf && leafText) {\n      text += leafText;\n      separated = !blockSeparator;\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator;\n      separated = true;\n    }\n  }, 0);\n  return text;\n};\n\nvar ClipboardTextSerializer = Extension.create({\n  name: 'editable',\n  addProseMirrorPlugins: function addProseMirrorPlugins() {\n    var _this11 = this;\n\n    return [new Plugin({\n      key: new PluginKey('clipboardTextSerializer'),\n      props: {\n        clipboardTextSerializer: function clipboardTextSerializer() {\n          var editor = _this11.editor;\n          var _editor$state$selecti = editor.state.selection,\n              from = _editor$state$selecti.from,\n              to = _editor$state$selecti.to;\n          return textBetween(editor, from, to, '\\n');\n        }\n      }\n    })];\n  }\n});\n\nvar blur = function blur() {\n  return function (_ref23) {\n    var view = _ref23.view;\n    var element = view.dom;\n    element.blur();\n    return true;\n  };\n};\n\nvar blur$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  blur: blur\n});\n\nvar clearContent = function clearContent() {\n  var emitUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return function (_ref24) {\n    var commands = _ref24.commands;\n    return commands.setContent('', emitUpdate);\n  };\n};\n\nvar clearContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  clearContent: clearContent\n});\n\nvar clearNodes = function clearNodes() {\n  return function (_ref25) {\n    var state = _ref25.state,\n        tr = _ref25.tr,\n        dispatch = _ref25.dispatch;\n    var selection = tr.selection;\n    var ranges = selection.ranges;\n    ranges.forEach(function (range) {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, function (node, pos) {\n        if (node.type.isText) {\n          return;\n        }\n\n        var $fromPos = tr.doc.resolve(tr.mapping.map(pos));\n        var $toPos = tr.doc.resolve(tr.mapping.map(pos + node.nodeSize));\n        var nodeRange = $fromPos.blockRange($toPos);\n\n        if (!nodeRange) {\n          return;\n        }\n\n        var targetLiftDepth = liftTarget(nodeRange);\n\n        if (node.type.isTextblock && dispatch) {\n          var _$fromPos$parent$cont = $fromPos.parent.contentMatchAt($fromPos.index()),\n              defaultType = _$fromPos$parent$cont.defaultType;\n\n          tr.setNodeMarkup(nodeRange.start, defaultType);\n        }\n\n        if ((targetLiftDepth || targetLiftDepth === 0) && dispatch) {\n          tr.lift(nodeRange, targetLiftDepth);\n        }\n      });\n    });\n    return true;\n  };\n};\n\nvar clearNodes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  clearNodes: clearNodes\n});\n\nvar command = function command(fn) {\n  return function (props) {\n    return fn(props);\n  };\n};\n\nvar command$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  command: command\n});\n\nvar createParagraphNear = function createParagraphNear() {\n  return function (_ref26) {\n    var state = _ref26.state,\n        dispatch = _ref26.dispatch;\n    return createParagraphNear$2(state, dispatch);\n  };\n};\n\nvar createParagraphNear$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createParagraphNear: createParagraphNear\n});\n\nvar deleteRange = function deleteRange(range) {\n  return function (_ref27) {\n    var tr = _ref27.tr,\n        dispatch = _ref27.dispatch;\n    var from = range.from,\n        to = range.to;\n\n    if (dispatch) {\n      tr.delete(from, to);\n    }\n\n    return true;\n  };\n};\n\nvar deleteRange$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  deleteRange: deleteRange\n});\n\nvar deleteSelection = function deleteSelection() {\n  return function (_ref28) {\n    var state = _ref28.state,\n        dispatch = _ref28.dispatch;\n    return deleteSelection$2(state, dispatch);\n  };\n};\n\nvar deleteSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  deleteSelection: deleteSelection\n});\n\nvar enter = function enter() {\n  return function (_ref29) {\n    var commands = _ref29.commands;\n    return commands.keyboardShortcut('Enter');\n  };\n};\n\nvar enter$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  enter: enter\n});\n\nvar exitCode = function exitCode() {\n  return function (_ref30) {\n    var state = _ref30.state,\n        dispatch = _ref30.dispatch;\n    return exitCode$2(state, dispatch);\n  };\n};\n\nvar exitCode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  exitCode: exitCode\n});\n\nfunction findMarkInSet(marks, type) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return marks.find(function (item) {\n    return item.type === type && objectIncludes(item.attrs, attributes);\n  });\n}\n\nfunction isMarkInSet(marks, type) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return !!findMarkInSet(marks, type, attributes);\n}\n\nfunction getMarkRange($pos, type) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!$pos || !type) {\n    return;\n  }\n\n  var start = $pos.parent.childAfter($pos.parentOffset);\n\n  if (!start.node) {\n    return;\n  }\n\n  var mark = findMarkInSet(start.node.marks, type, attributes);\n\n  if (!mark) {\n    return;\n  }\n\n  var startIndex = $pos.index();\n  var startPos = $pos.start() + start.offset;\n  var endIndex = startIndex + 1;\n  var endPos = startPos + start.node.nodeSize;\n  findMarkInSet(start.node.marks, type, attributes);\n\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n\n  while (endIndex < $pos.parent.childCount && isMarkInSet($pos.parent.child(endIndex).marks, type, attributes)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\n\nvar extendMarkRange = function extendMarkRange(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref31) {\n    var tr = _ref31.tr,\n        state = _ref31.state,\n        dispatch = _ref31.dispatch;\n    var type = getMarkType(typeOrName, state.schema);\n    var doc = tr.doc,\n        selection = tr.selection;\n    var $from = selection.$from,\n        from = selection.from,\n        to = selection.to;\n\n    if (dispatch) {\n      var range = getMarkRange($from, type, attributes);\n\n      if (range && range.from <= from && range.to >= to) {\n        var newSelection = TextSelection.create(doc, range.from, range.to);\n        tr.setSelection(newSelection);\n      }\n    }\n\n    return true;\n  };\n};\n\nvar extendMarkRange$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  extendMarkRange: extendMarkRange\n});\n\nvar first = function first(commands) {\n  return function (props) {\n    var items = typeof commands === 'function' ? commands(props) : commands;\n\n    for (var i = 0; i < items.length; i += 1) {\n      if (items[i](props)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n};\n\nvar first$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  first: first\n});\n\nfunction minMax() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return Math.min(Math.max(value, min), max);\n}\n\nfunction isClass(item) {\n  var _a;\n\n  if (((_a = item.constructor) === null || _a === void 0 ? void 0 : _a.toString().substring(0, 5)) !== 'class') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item) && !isClass(item);\n}\n\nfunction isTextSelection(value) {\n  return isObject(value) && value instanceof TextSelection;\n}\n\nfunction resolveSelection(state) {\n  var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (!position) {\n    return null;\n  }\n\n  if (position === 'start' || position === true) {\n    return {\n      from: 0,\n      to: 0\n    };\n  }\n\n  if (position === 'end') {\n    var size = state.doc.content.size;\n    return {\n      from: size,\n      to: size\n    };\n  }\n\n  return {\n    from: position,\n    to: position\n  };\n}\n\nvar focus = function focus() {\n  var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return function (_ref32) {\n    var editor = _ref32.editor,\n        view = _ref32.view,\n        tr = _ref32.tr,\n        dispatch = _ref32.dispatch;\n\n    if (view.hasFocus() && position === null || position === false) {\n      return true;\n    } // we donâ€™t try to resolve a NodeSelection or CellSelection\n\n\n    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n      view.focus();\n      return true;\n    }\n\n    var _ref33 = resolveSelection(editor.state, position) || editor.state.selection,\n        from = _ref33.from,\n        to = _ref33.to;\n\n    var doc = tr.doc,\n        storedMarks = tr.storedMarks;\n    var resolvedFrom = minMax(from, 0, doc.content.size);\n    var resolvedEnd = minMax(to, 0, doc.content.size);\n    var selection = TextSelection.create(doc, resolvedFrom, resolvedEnd);\n    var isSameSelection = editor.state.selection.eq(selection);\n\n    if (dispatch) {\n      tr.setSelection(selection); // `tr.setSelection` resets the stored marks\n      // so weâ€™ll restore them if the selection is the same as before\n\n      if (isSameSelection && storedMarks) {\n        tr.setStoredMarks(storedMarks);\n      }\n\n      view.focus();\n    }\n\n    return true;\n  };\n};\n\nvar focus$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  focus: focus\n});\n\nvar insertContent = function insertContent(value) {\n  return function (_ref34) {\n    var tr = _ref34.tr,\n        commands = _ref34.commands;\n    return commands.insertContentAt({\n      from: tr.selection.from,\n      to: tr.selection.to\n    }, value);\n  };\n};\n\nvar insertContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  insertContent: insertContent\n}); // source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  var last = tr.steps.length - 1;\n\n  if (last < startLen) {\n    return;\n  }\n\n  var step = tr.steps[last];\n\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return;\n  }\n\n  var map = tr.mapping.maps[last];\n  var end = 0;\n  map.forEach(function (_from, _to, _newFrom, newTo) {\n    if (end === 0) {\n      end = newTo;\n    }\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nvar insertContentAt = function insertContentAt(position, value) {\n  return function (_ref35) {\n    var tr = _ref35.tr,\n        dispatch = _ref35.dispatch,\n        editor = _ref35.editor;\n\n    if (dispatch) {\n      var content = createNodeFromContent(value, editor.schema, {\n        parseOptions: {\n          preserveWhitespace: 'full'\n        }\n      }); // donâ€™t dispatch an empty fragment because this can lead to strange errors\n\n      if (content.toString() === '<>') {\n        return true;\n      }\n\n      var _ref36 = typeof position === 'number' ? {\n        from: position,\n        to: position\n      } : position,\n          from = _ref36.from,\n          to = _ref36.to;\n\n      tr.replaceWith(from, to, content); // set cursor at end of inserted content\n\n      selectionToInsertionEnd(tr, tr.steps.length - 1, 1);\n    }\n\n    return true;\n  };\n};\n\nvar insertContentAt$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  insertContentAt: insertContentAt\n});\n\nvar joinBackward = function joinBackward() {\n  return function (_ref37) {\n    var state = _ref37.state,\n        dispatch = _ref37.dispatch;\n    return joinBackward$2(state, dispatch);\n  };\n};\n\nvar joinBackward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  joinBackward: joinBackward\n});\n\nvar joinForward = function joinForward() {\n  return function (_ref38) {\n    var state = _ref38.state,\n        dispatch = _ref38.dispatch;\n    return joinForward$2(state, dispatch);\n  };\n};\n\nvar joinForward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  joinForward: joinForward\n});\nvar mac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/);\n  var result = parts[parts.length - 1];\n\n  if (result === 'Space') {\n    result = ' ';\n  }\n\n  var alt;\n  var ctrl;\n  var shift;\n  var meta;\n\n  for (var i = 0; i < parts.length - 1; i += 1) {\n    var mod = parts[i];\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (mac) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(\"Unrecognized modifier name: \".concat(mod));\n    }\n  }\n\n  if (alt) {\n    result = \"Alt-\".concat(result);\n  }\n\n  if (ctrl) {\n    result = \"Ctrl-\".concat(result);\n  }\n\n  if (meta) {\n    result = \"Meta-\".concat(result);\n  }\n\n  if (shift) {\n    result = \"Shift-\".concat(result);\n  }\n\n  return result;\n}\n\nvar keyboardShortcut = function keyboardShortcut(name) {\n  return function (_ref39) {\n    var editor = _ref39.editor,\n        view = _ref39.view,\n        tr = _ref39.tr,\n        dispatch = _ref39.dispatch;\n    var keys = normalizeKeyName(name).split(/-(?!$)/);\n    var key = keys.find(function (item) {\n      return !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item);\n    });\n    var event = new KeyboardEvent('keydown', {\n      key: key === 'Space' ? ' ' : key,\n      altKey: keys.includes('Alt'),\n      ctrlKey: keys.includes('Ctrl'),\n      metaKey: keys.includes('Meta'),\n      shiftKey: keys.includes('Shift'),\n      bubbles: true,\n      cancelable: true\n    });\n    var capturedTransaction = editor.captureTransaction(function () {\n      view.someProp('handleKeyDown', function (f) {\n        return f(view, event);\n      });\n    });\n    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(function (step) {\n      var newStep = step.map(tr.mapping);\n\n      if (newStep && dispatch) {\n        tr.maybeStep(newStep);\n      }\n    });\n    return true;\n  };\n};\n\nvar keyboardShortcut$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  keyboardShortcut: keyboardShortcut\n});\n\nvar lift = function lift(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref40) {\n    var state = _ref40.state,\n        dispatch = _ref40.dispatch;\n    var type = getNodeType(typeOrName, state.schema);\n    var isActive = isNodeActive(state, type, attributes);\n\n    if (!isActive) {\n      return false;\n    }\n\n    return lift$2(state, dispatch);\n  };\n};\n\nvar lift$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  lift: lift\n});\n\nvar liftEmptyBlock = function liftEmptyBlock() {\n  return function (_ref41) {\n    var state = _ref41.state,\n        dispatch = _ref41.dispatch;\n    return liftEmptyBlock$2(state, dispatch);\n  };\n};\n\nvar liftEmptyBlock$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  liftEmptyBlock: liftEmptyBlock\n});\n\nvar liftListItem = function liftListItem(typeOrName) {\n  return function (_ref42) {\n    var state = _ref42.state,\n        dispatch = _ref42.dispatch;\n    var type = getNodeType(typeOrName, state.schema);\n    return liftListItem$2(type)(state, dispatch);\n  };\n};\n\nvar liftListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  liftListItem: liftListItem\n});\n\nvar newlineInCode = function newlineInCode() {\n  return function (_ref43) {\n    var state = _ref43.state,\n        dispatch = _ref43.dispatch;\n    return newlineInCode$2(state, dispatch);\n  };\n};\n\nvar newlineInCode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  newlineInCode: newlineInCode\n});\n\nvar replace = function replace(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref44) {\n    var state = _ref44.state,\n        commands = _ref44.commands;\n    console.warn('[tiptap warn]: replace() is deprecated. please use insertContent() instead.');\n    var _state$selection5 = state.selection,\n        from = _state$selection5.from,\n        to = _state$selection5.to;\n    var range = {\n      from: from,\n      to: to\n    };\n    return commands.replaceRange(range, typeOrName, attributes);\n  };\n};\n\nvar replace$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  replace: replace\n});\n\nvar replaceRange = function replaceRange(range, typeOrName) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return function (_ref45) {\n    var tr = _ref45.tr,\n        state = _ref45.state,\n        dispatch = _ref45.dispatch;\n    console.warn('[tiptap warn]: replaceRange() is deprecated. please use insertContent() instead.');\n    var type = getNodeType(typeOrName, state.schema);\n    var from = range.from,\n        to = range.to; // const $from = tr.doc.resolve(from)\n    // const index = $from.index()\n    // if (!$from.parent.canReplaceWith(index, index, type)) {\n    //   return false\n    // }\n\n    if (dispatch) {\n      tr.replaceRangeWith(from, to, type.create(attributes));\n    }\n\n    return true;\n  };\n};\n\nvar replaceRange$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  replaceRange: replaceRange\n});\n/**\r\n * Remove a property or an array of properties from an object\r\n * @param obj Object\r\n * @param key Key to remove\r\n */\n\nfunction deleteProps(obj, propOrProps) {\n  var props = typeof propOrProps === 'string' ? [propOrProps] : propOrProps;\n  return Object.keys(obj).reduce(function (newObj, prop) {\n    if (!props.includes(prop)) {\n      newObj[prop] = obj[prop];\n    }\n\n    return newObj;\n  }, {});\n}\n\nvar resetAttributes = function resetAttributes(typeOrName, attributes) {\n  return function (_ref46) {\n    var tr = _ref46.tr,\n        state = _ref46.state,\n        dispatch = _ref46.dispatch;\n    var nodeType = null;\n    var markType = null;\n    var schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n\n    if (!schemaType) {\n      return false;\n    }\n\n    if (schemaType === 'node') {\n      nodeType = getNodeType(typeOrName, state.schema);\n    }\n\n    if (schemaType === 'mark') {\n      markType = getMarkType(typeOrName, state.schema);\n    }\n\n    if (dispatch) {\n      tr.selection.ranges.forEach(function (range) {\n        state.doc.nodesBetween(range.$from.pos, range.$to.pos, function (node, pos) {\n          if (nodeType && nodeType === node.type) {\n            tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\n          }\n\n          if (markType && node.marks.length) {\n            node.marks.forEach(function (mark) {\n              if (markType === mark.type) {\n                tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n              }\n            });\n          }\n        });\n      });\n    }\n\n    return true;\n  };\n};\n\nvar resetAttributes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  resetAttributes: resetAttributes\n});\n\nvar scrollIntoView = function scrollIntoView() {\n  return function (_ref47) {\n    var tr = _ref47.tr,\n        dispatch = _ref47.dispatch;\n\n    if (dispatch) {\n      tr.scrollIntoView();\n    }\n\n    return true;\n  };\n};\n\nvar scrollIntoView$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  scrollIntoView: scrollIntoView\n});\n\nvar selectAll = function selectAll() {\n  return function (_ref48) {\n    var state = _ref48.state,\n        dispatch = _ref48.dispatch;\n    return selectAll$2(state, dispatch);\n  };\n};\n\nvar selectAll$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectAll: selectAll\n});\n\nvar selectNodeBackward = function selectNodeBackward() {\n  return function (_ref49) {\n    var state = _ref49.state,\n        dispatch = _ref49.dispatch;\n    return selectNodeBackward$2(state, dispatch);\n  };\n};\n\nvar selectNodeBackward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectNodeBackward: selectNodeBackward\n});\n\nvar selectNodeForward = function selectNodeForward() {\n  return function (_ref50) {\n    var state = _ref50.state,\n        dispatch = _ref50.dispatch;\n    return selectNodeForward$2(state, dispatch);\n  };\n};\n\nvar selectNodeForward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectNodeForward: selectNodeForward\n});\n\nvar selectParentNode = function selectParentNode() {\n  return function (_ref51) {\n    var state = _ref51.state,\n        dispatch = _ref51.dispatch;\n    return selectParentNode$2(state, dispatch);\n  };\n};\n\nvar selectParentNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectParentNode: selectParentNode\n});\n\nvar setContent = function setContent(content) {\n  var emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return function (_ref52) {\n    var tr = _ref52.tr,\n        editor = _ref52.editor,\n        dispatch = _ref52.dispatch;\n    var doc = tr.doc;\n    var document = createDocument(content, editor.schema, parseOptions);\n    var selection = TextSelection.create(doc, 0, doc.content.size);\n\n    if (dispatch) {\n      tr.setSelection(selection).replaceSelectionWith(document, false).setMeta('preventUpdate', !emitUpdate);\n    }\n\n    return true;\n  };\n};\n\nvar setContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setContent: setContent\n});\n\nvar setMark = function setMark(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref53) {\n    var tr = _ref53.tr,\n        state = _ref53.state,\n        dispatch = _ref53.dispatch;\n    var selection = tr.selection;\n    var empty = selection.empty,\n        ranges = selection.ranges;\n    var type = getMarkType(typeOrName, state.schema);\n\n    if (dispatch) {\n      if (empty) {\n        var oldAttributes = _getMarkAttributes(state, type);\n\n        tr.addStoredMark(type.create(_objectSpread(_objectSpread({}, oldAttributes), attributes)));\n      } else {\n        ranges.forEach(function (range) {\n          var from = range.$from.pos;\n          var to = range.$to.pos;\n          state.doc.nodesBetween(from, to, function (node, pos) {\n            var trimmedFrom = Math.max(pos, from);\n            var trimmedTo = Math.min(pos + node.nodeSize, to);\n            var someHasMark = node.marks.find(function (mark) {\n              return mark.type === type;\n            }); // if there is already a mark of this type\n            // we know that we have to merge its attributes\n            // otherwise we add a fresh new mark\n\n            if (someHasMark) {\n              node.marks.forEach(function (mark) {\n                if (type === mark.type) {\n                  tr.addMark(trimmedFrom, trimmedTo, type.create(_objectSpread(_objectSpread({}, mark.attrs), attributes)));\n                }\n              });\n            } else {\n              tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n            }\n          });\n        });\n      }\n    }\n\n    return true;\n  };\n};\n\nvar setMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setMark: setMark\n});\n\nvar setMeta = function setMeta(key, value) {\n  return function (_ref54) {\n    var tr = _ref54.tr;\n    tr.setMeta(key, value);\n    return true;\n  };\n};\n\nvar setMeta$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setMeta: setMeta\n});\n\nvar setNode = function setNode(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref55) {\n    var state = _ref55.state,\n        dispatch = _ref55.dispatch;\n    var type = getNodeType(typeOrName, state.schema);\n    return setBlockType(type, attributes)(state, dispatch);\n  };\n};\n\nvar setNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setNode: setNode\n});\n\nvar setNodeSelection = function setNodeSelection(position) {\n  return function (_ref56) {\n    var tr = _ref56.tr,\n        dispatch = _ref56.dispatch;\n\n    if (dispatch) {\n      var doc = tr.doc;\n      var from = minMax(position, 0, doc.content.size);\n      var selection = NodeSelection.create(doc, from);\n      tr.setSelection(selection);\n    }\n\n    return true;\n  };\n};\n\nvar setNodeSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setNodeSelection: setNodeSelection\n});\n\nvar setTextSelection = function setTextSelection(position) {\n  return function (_ref57) {\n    var tr = _ref57.tr,\n        dispatch = _ref57.dispatch;\n\n    if (dispatch) {\n      var doc = tr.doc;\n\n      var _ref58 = typeof position === 'number' ? {\n        from: position,\n        to: position\n      } : position,\n          from = _ref58.from,\n          to = _ref58.to;\n\n      var boundedFrom = minMax(from, 0, doc.content.size);\n      var boundedTo = minMax(to, 0, doc.content.size);\n      var selection = TextSelection.create(doc, boundedFrom, boundedTo);\n      tr.setSelection(selection);\n    }\n\n    return true;\n  };\n};\n\nvar setTextSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setTextSelection: setTextSelection\n});\n\nvar sinkListItem = function sinkListItem(typeOrName) {\n  return function (_ref59) {\n    var state = _ref59.state,\n        dispatch = _ref59.dispatch;\n    var type = getNodeType(typeOrName, state.schema);\n    return sinkListItem$2(type)(state, dispatch);\n  };\n};\n\nvar sinkListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  sinkListItem: sinkListItem\n});\n\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n  return Object.fromEntries(Object.entries(attributes).filter(function (_ref60) {\n    var _ref61 = _slicedToArray(_ref60, 1),\n        name = _ref61[0];\n\n    var extensionAttribute = extensionAttributes.find(function (item) {\n      return item.type === typeName && item.name === name;\n    });\n\n    if (!extensionAttribute) {\n      return false;\n    }\n\n    return extensionAttribute.attribute.keepOnSplit;\n  }));\n}\n\nfunction defaultBlockAt(match) {\n  for (var i = 0; i < match.edgeCount; i += 1) {\n    var _match$edge = match.edge(i),\n        type = _match$edge.type;\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n\n  return null;\n}\n\nfunction ensureMarks(state, splittableMarks) {\n  var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n\n  if (marks) {\n    var filteredMarks = marks.filter(function (mark) {\n      return splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name);\n    });\n    state.tr.ensureMarks(filteredMarks);\n  }\n}\n\nvar splitBlock = function splitBlock() {\n  var _ref62 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref62$keepMarks = _ref62.keepMarks,\n      keepMarks = _ref62$keepMarks === void 0 ? true : _ref62$keepMarks;\n\n  return function (_ref63) {\n    var tr = _ref63.tr,\n        state = _ref63.state,\n        dispatch = _ref63.dispatch,\n        editor = _ref63.editor;\n    var selection = tr.selection,\n        doc = tr.doc;\n    var $from = selection.$from,\n        $to = selection.$to;\n    var extensionAttributes = editor.extensionManager.attributes;\n    var newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\n      if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n        return false;\n      }\n\n      if (dispatch) {\n        if (keepMarks) {\n          ensureMarks(state, editor.extensionManager.splittableMarks);\n        }\n\n        tr.split($from.pos).scrollIntoView();\n      }\n\n      return true;\n    }\n\n    if (!$from.parent.isBlock) {\n      return false;\n    }\n\n    if (dispatch) {\n      var atEnd = $to.parentOffset === $to.parent.content.size;\n\n      if (selection instanceof TextSelection) {\n        tr.deleteSelection();\n      }\n\n      var deflt = $from.depth === 0 ? undefined : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n      var types = atEnd && deflt ? [{\n        type: deflt,\n        attrs: newAttributes\n      }] : undefined;\n      var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n\n      if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{\n        type: deflt\n      }] : undefined)) {\n        can = true;\n        types = deflt ? [{\n          type: deflt,\n          attrs: newAttributes\n        }] : undefined;\n      }\n\n      if (can) {\n        tr.split(tr.mapping.map($from.pos), 1, types);\n\n        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n          var _first = tr.mapping.map($from.before());\n\n          var $first = tr.doc.resolve(_first);\n\n          if ($from.parent.canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n          }\n        }\n      }\n\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks);\n      }\n\n      tr.scrollIntoView();\n    }\n\n    return true;\n  };\n};\n\nvar splitBlock$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  splitBlock: splitBlock\n});\n\nvar splitListItem = function splitListItem(typeOrName) {\n  return function (_ref64) {\n    var tr = _ref64.tr,\n        state = _ref64.state,\n        dispatch = _ref64.dispatch,\n        editor = _ref64.editor;\n\n    var _a;\n\n    var type = getNodeType(typeOrName, state.schema);\n    var _state$selection6 = state.selection,\n        $from = _state$selection6.$from,\n        $to = _state$selection6.$to; // @ts-ignore\n    // eslint-disable-next-line\n\n    var node = state.selection.node;\n\n    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n      return false;\n    }\n\n    var grandParent = $from.node(-1);\n\n    if (grandParent.type !== type) {\n      return false;\n    }\n\n    var extensionAttributes = editor.extensionManager.attributes;\n\n    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n        return false;\n      }\n\n      if (dispatch) {\n        var wrap = Fragment.empty;\n        var keepItem = $from.index(-1) > 0; // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n\n        for (var d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d -= 1) {\n          wrap = Fragment.from($from.node(d).copy(wrap));\n        } // Add a second list item with an empty default start node\n\n\n        var _newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n\n        var _nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(_newNextTypeAttributes)) || undefined;\n\n        wrap = wrap.append(Fragment.from(type.createAndFill(null, _nextType) || undefined));\n        tr.replace($from.before(keepItem ? undefined : -1), $from.after(-3), new Slice(wrap, keepItem ? 3 : 2, 2)).setSelection(TextSelection.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2)))).scrollIntoView();\n      }\n\n      return true;\n    }\n\n    var nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n    var newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);\n    var newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n    tr.delete($from.pos, $to.pos);\n    var types = nextType ? [{\n      type: type,\n      attrs: newTypeAttributes\n    }, {\n      type: nextType,\n      attrs: newNextTypeAttributes\n    }] : [{\n      type: type,\n      attrs: newTypeAttributes\n    }];\n\n    if (!canSplit(tr.doc, $from.pos, 2)) {\n      return false;\n    }\n\n    if (dispatch) {\n      tr.split($from.pos, 2, types).scrollIntoView();\n    }\n\n    return true;\n  };\n};\n\nvar splitListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  splitListItem: splitListItem\n});\n\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (var i = $pos.depth; i > 0; i -= 1) {\n    var node = $pos.node(i);\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node: node\n      };\n    }\n  }\n}\n\nfunction findParentNode(predicate) {\n  return function (selection) {\n    return findParentNodeClosestToPos(selection.$from, predicate);\n  };\n}\n\nfunction isList(name, extensions) {\n  var _splitExtensions5 = splitExtensions(extensions),\n      nodeExtensions = _splitExtensions5.nodeExtensions;\n\n  var extension = nodeExtensions.find(function (item) {\n    return item.name === name;\n  });\n\n  if (!extension) {\n    return false;\n  }\n\n  var context = {\n    name: extension.name,\n    options: extension.options\n  };\n  var group = callOrReturn(getExtensionField(extension, 'group', context));\n\n  if (typeof group !== 'string') {\n    return false;\n  }\n\n  return group.split(' ').includes('list');\n}\n\nvar toggleList = function toggleList(listTypeOrName, itemTypeOrName) {\n  return function (_ref65) {\n    var editor = _ref65.editor,\n        tr = _ref65.tr,\n        state = _ref65.state,\n        dispatch = _ref65.dispatch,\n        chain = _ref65.chain,\n        commands = _ref65.commands,\n        can = _ref65.can;\n    var extensions = editor.extensionManager.extensions;\n    var listType = getNodeType(listTypeOrName, state.schema);\n    var itemType = getNodeType(itemTypeOrName, state.schema);\n    var selection = state.selection;\n    var $from = selection.$from,\n        $to = selection.$to;\n    var range = $from.blockRange($to);\n\n    if (!range) {\n      return false;\n    }\n\n    var parentList = findParentNode(function (node) {\n      return isList(node.type.name, extensions);\n    })(selection);\n\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n      // remove list\n      if (parentList.node.type === listType) {\n        return commands.liftListItem(itemType);\n      } // change list type\n\n\n      if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n        tr.setNodeMarkup(parentList.pos, listType);\n        return true;\n      }\n    }\n\n    var canWrapInList = can().wrapInList(listType); // try to convert node to paragraph if needed\n\n    if (!canWrapInList) {\n      return chain().clearNodes().wrapInList(listType).run();\n    }\n\n    return commands.wrapInList(listType);\n  };\n};\n\nvar toggleList$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleList: toggleList\n});\n\nvar toggleMark = function toggleMark(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref66) {\n    var state = _ref66.state,\n        commands = _ref66.commands;\n    var type = getMarkType(typeOrName, state.schema);\n    var isActive = isMarkActive(state, type, attributes);\n\n    if (isActive) {\n      return commands.unsetMark(type);\n    }\n\n    return commands.setMark(type, attributes);\n  };\n};\n\nvar toggleMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleMark: toggleMark\n});\n\nvar toggleNode = function toggleNode(typeOrName, toggleTypeOrName) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return function (_ref67) {\n    var state = _ref67.state,\n        commands = _ref67.commands;\n    var type = getNodeType(typeOrName, state.schema);\n    var toggleType = getNodeType(toggleTypeOrName, state.schema);\n    var isActive = isNodeActive(state, type, attributes);\n\n    if (isActive) {\n      return commands.setNode(toggleType);\n    }\n\n    return commands.setNode(type, attributes);\n  };\n};\n\nvar toggleNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleNode: toggleNode\n});\n\nvar toggleWrap = function toggleWrap(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref68) {\n    var state = _ref68.state,\n        dispatch = _ref68.dispatch;\n    var type = getNodeType(typeOrName, state.schema);\n    var isActive = isNodeActive(state, type, attributes);\n\n    if (isActive) {\n      return lift$2(state, dispatch);\n    }\n\n    return wrapIn$2(type, attributes)(state, dispatch);\n  };\n};\n\nvar toggleWrap$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleWrap: toggleWrap\n});\n\nvar undoInputRule = function undoInputRule() {\n  return function (_ref69) {\n    var state = _ref69.state,\n        dispatch = _ref69.dispatch;\n    return undoInputRule$2(state, dispatch);\n  };\n};\n\nvar undoInputRule$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  undoInputRule: undoInputRule\n});\n\nvar unsetAllMarks = function unsetAllMarks() {\n  return function (_ref70) {\n    var tr = _ref70.tr,\n        state = _ref70.state,\n        dispatch = _ref70.dispatch;\n    var selection = tr.selection;\n    var empty = selection.empty,\n        ranges = selection.ranges;\n\n    if (empty) {\n      return true;\n    }\n\n    if (dispatch) {\n      Object.entries(state.schema.marks).forEach(function (_ref71) {\n        var _ref72 = _slicedToArray(_ref71, 2),\n            mark = _ref72[1];\n\n        ranges.forEach(function (range) {\n          tr.removeMark(range.$from.pos, range.$to.pos, mark);\n        });\n      });\n    }\n\n    return true;\n  };\n};\n\nvar unsetAllMarks$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unsetAllMarks: unsetAllMarks\n});\n\nvar unsetMark = function unsetMark(typeOrName) {\n  return function (_ref73) {\n    var tr = _ref73.tr,\n        state = _ref73.state,\n        dispatch = _ref73.dispatch;\n    var selection = tr.selection;\n    var type = getMarkType(typeOrName, state.schema);\n    var $from = selection.$from,\n        empty = selection.empty,\n        ranges = selection.ranges;\n\n    if (dispatch) {\n      if (empty) {\n        var from = selection.from,\n            to = selection.to;\n        var range = getMarkRange($from, type);\n\n        if (range) {\n          from = range.from;\n          to = range.to;\n        }\n\n        tr.removeMark(from, to, type);\n      } else {\n        ranges.forEach(function (range) {\n          tr.removeMark(range.$from.pos, range.$to.pos, type);\n        });\n      }\n\n      tr.removeStoredMark(type);\n    }\n\n    return true;\n  };\n};\n\nvar unsetMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unsetMark: unsetMark\n});\n\nvar updateAttributes = function updateAttributes(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref74) {\n    var tr = _ref74.tr,\n        state = _ref74.state,\n        dispatch = _ref74.dispatch;\n    var nodeType = null;\n    var markType = null;\n    var schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n\n    if (!schemaType) {\n      return false;\n    }\n\n    if (schemaType === 'node') {\n      nodeType = getNodeType(typeOrName, state.schema);\n    }\n\n    if (schemaType === 'mark') {\n      markType = getMarkType(typeOrName, state.schema);\n    }\n\n    if (dispatch) {\n      tr.selection.ranges.forEach(function (range) {\n        var from = range.$from.pos;\n        var to = range.$to.pos;\n        state.doc.nodesBetween(from, to, function (node, pos) {\n          if (nodeType && nodeType === node.type) {\n            tr.setNodeMarkup(pos, undefined, _objectSpread(_objectSpread({}, node.attrs), attributes));\n          }\n\n          if (markType && node.marks.length) {\n            node.marks.forEach(function (mark) {\n              if (markType === mark.type) {\n                var trimmedFrom = Math.max(pos, from);\n                var trimmedTo = Math.min(pos + node.nodeSize, to);\n                tr.addMark(trimmedFrom, trimmedTo, markType.create(_objectSpread(_objectSpread({}, mark.attrs), attributes)));\n              }\n            });\n          }\n        });\n      });\n    }\n\n    return true;\n  };\n};\n\nvar updateAttributes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  updateAttributes: updateAttributes\n});\n\nvar wrapIn = function wrapIn(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref75) {\n    var state = _ref75.state,\n        dispatch = _ref75.dispatch;\n    var type = getNodeType(typeOrName, state.schema);\n    var isActive = isNodeActive(state, type, attributes);\n\n    if (isActive) {\n      return false;\n    }\n\n    return wrapIn$2(type, attributes)(state, dispatch);\n  };\n};\n\nvar wrapIn$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  wrapIn: wrapIn\n});\n\nvar wrapInList = function wrapInList(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref76) {\n    var state = _ref76.state,\n        dispatch = _ref76.dispatch;\n    var type = getNodeType(typeOrName, state.schema);\n    return wrapInList$2(type, attributes)(state, dispatch);\n  };\n};\n\nvar wrapInList$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  wrapInList: wrapInList\n});\nvar Commands = Extension.create({\n  name: 'commands',\n  addCommands: function addCommands() {\n    return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, blur$1), clearContent$1), clearNodes$1), command$1), createParagraphNear$1), deleteRange$1), deleteSelection$1), enter$1), exitCode$1), extendMarkRange$1), first$1), focus$1), insertContent$1), insertContentAt$1), joinBackward$1), joinForward$1), keyboardShortcut$1), lift$1), liftEmptyBlock$1), liftListItem$1), newlineInCode$1), replace$1), replaceRange$1), resetAttributes$1), scrollIntoView$1), selectAll$1), selectNodeBackward$1), selectNodeForward$1), selectParentNode$1), setContent$1), setMark$1), setMeta$1), setNode$1), setNodeSelection$1), setTextSelection$1), sinkListItem$1), splitBlock$1), splitListItem$1), toggleList$1), toggleMark$1), toggleNode$1), toggleWrap$1), undoInputRule$1), unsetAllMarks$1), unsetMark$1), updateAttributes$1), wrapIn$1), wrapInList$1);\n  }\n});\nvar Editable = Extension.create({\n  name: 'editable',\n  addProseMirrorPlugins: function addProseMirrorPlugins() {\n    var _this12 = this;\n\n    return [new Plugin({\n      key: new PluginKey('editable'),\n      props: {\n        editable: function editable() {\n          return _this12.editor.options.editable;\n        }\n      }\n    })];\n  }\n});\nvar FocusEvents = Extension.create({\n  name: 'focusEvents',\n  addProseMirrorPlugins: function addProseMirrorPlugins() {\n    var editor = this.editor;\n    return [new Plugin({\n      key: new PluginKey('focusEvents'),\n      props: {\n        attributes: {\n          tabindex: '0'\n        },\n        handleDOMEvents: {\n          focus: function focus(view, event) {\n            editor.isFocused = true;\n            var transaction = editor.state.tr.setMeta('focus', {\n              event: event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          },\n          blur: function blur(view, event) {\n            editor.isFocused = false;\n            var transaction = editor.state.tr.setMeta('blur', {\n              event: event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          }\n        }\n      }\n    })];\n  }\n});\nvar Keymap = Extension.create({\n  name: 'keymap',\n  addKeyboardShortcuts: function addKeyboardShortcuts() {\n    var _this13 = this;\n\n    var handleBackspace = function handleBackspace() {\n      return _this13.editor.commands.first(function (_ref77) {\n        var commands = _ref77.commands;\n        return [function () {\n          return commands.undoInputRule();\n        }, function () {\n          return commands.deleteSelection();\n        }, function () {\n          return commands.joinBackward();\n        }, function () {\n          return commands.selectNodeBackward();\n        }];\n      });\n    };\n\n    var handleDelete = function handleDelete() {\n      return _this13.editor.commands.first(function (_ref78) {\n        var commands = _ref78.commands;\n        return [function () {\n          return commands.deleteSelection();\n        }, function () {\n          return commands.joinForward();\n        }, function () {\n          return commands.selectNodeForward();\n        }];\n      });\n    };\n\n    return {\n      Enter: function Enter() {\n        return _this13.editor.commands.first(function (_ref79) {\n          var commands = _ref79.commands;\n          return [function () {\n            return commands.newlineInCode();\n          }, function () {\n            return commands.createParagraphNear();\n          }, function () {\n            return commands.liftEmptyBlock();\n          }, function () {\n            return commands.splitBlock();\n          }];\n        });\n      },\n      'Mod-Enter': function ModEnter() {\n        return _this13.editor.commands.exitCode();\n      },\n      Backspace: function Backspace() {\n        return handleBackspace();\n      },\n      'Mod-Backspace': function ModBackspace() {\n        return handleBackspace();\n      },\n      Delete: function Delete() {\n        return handleDelete();\n      },\n      'Mod-Delete': function ModDelete() {\n        return handleDelete();\n      } // we donâ€™t need a custom `selectAll` for now\n      // 'Mod-a': () => this.editor.commands.selectAll(),\n\n    };\n  }\n});\nvar extensions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer: ClipboardTextSerializer,\n  Commands: Commands,\n  Editable: Editable,\n  FocusEvents: FocusEvents,\n  Keymap: Keymap\n});\nvar style = \".ProseMirror {\\n  position: relative;\\n}\\n\\n.ProseMirror {\\n  word-wrap: break-word;\\n  white-space: pre-wrap;\\n  -webkit-font-variant-ligatures: none;\\n  font-variant-ligatures: none;\\n}\\n\\n.ProseMirror [contenteditable=\\\"false\\\"] {\\n  white-space: normal;\\n}\\n\\n.ProseMirror [contenteditable=\\\"false\\\"] [contenteditable=\\\"true\\\"] {\\n  white-space: pre-wrap;\\n}\\n\\n.ProseMirror pre {\\n  white-space: pre-wrap;\\n}\\n\\n.ProseMirror-gapcursor {\\n  display: none;\\n  pointer-events: none;\\n  position: absolute;\\n}\\n\\n.ProseMirror-gapcursor:after {\\n  content: \\\"\\\";\\n  display: block;\\n  position: absolute;\\n  top: -2px;\\n  width: 20px;\\n  border-top: 1px solid black;\\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\\n}\\n\\n@keyframes ProseMirror-cursor-blink {\\n  to {\\n    visibility: hidden;\\n  }\\n}\\n\\n.ProseMirror-hideselection *::selection {\\n  background: transparent;\\n}\\n\\n.ProseMirror-hideselection *::-moz-selection {\\n  background: transparent;\\n}\\n\\n.ProseMirror-hideselection * {\\n  caret-color: transparent;\\n}\\n\\n.ProseMirror-focused .ProseMirror-gapcursor {\\n  display: block;\\n}\\n\\n.tippy-box[data-animation=fade][data-state=hidden] {\\n  opacity: 0\\n}\";\n\nvar Editor = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Editor, _EventEmitter);\n\n  var _super = _createSuper(Editor);\n\n  function Editor() {\n    var _this14;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Editor);\n\n    _this14 = _super.call(this);\n    _this14.isFocused = false;\n    _this14.options = {\n      element: document.createElement('div'),\n      content: '',\n      injectCSS: true,\n      extensions: [],\n      autofocus: false,\n      editable: true,\n      editorProps: {},\n      parseOptions: {},\n      enableInputRules: true,\n      enablePasteRules: true,\n      onBeforeCreate: function onBeforeCreate() {\n        return null;\n      },\n      onCreate: function onCreate() {\n        return null;\n      },\n      onUpdate: function onUpdate() {\n        return null;\n      },\n      onSelectionUpdate: function onSelectionUpdate() {\n        return null;\n      },\n      onTransaction: function onTransaction() {\n        return null;\n      },\n      onFocus: function onFocus() {\n        return null;\n      },\n      onBlur: function onBlur() {\n        return null;\n      },\n      onDestroy: function onDestroy() {\n        return null;\n      }\n    };\n    _this14.isCapturingTransaction = false;\n    _this14.capturedTransaction = null;\n\n    _this14.setOptions(options);\n\n    _this14.createExtensionManager();\n\n    _this14.createCommandManager();\n\n    _this14.createSchema();\n\n    _this14.on('beforeCreate', _this14.options.onBeforeCreate);\n\n    _this14.emit('beforeCreate', {\n      editor: _assertThisInitialized(_this14)\n    });\n\n    _this14.createView();\n\n    _this14.injectCSS();\n\n    _this14.on('create', _this14.options.onCreate);\n\n    _this14.on('update', _this14.options.onUpdate);\n\n    _this14.on('selectionUpdate', _this14.options.onSelectionUpdate);\n\n    _this14.on('transaction', _this14.options.onTransaction);\n\n    _this14.on('focus', _this14.options.onFocus);\n\n    _this14.on('blur', _this14.options.onBlur);\n\n    _this14.on('destroy', _this14.options.onDestroy);\n\n    window.setTimeout(function () {\n      if (_this14.isDestroyed) {\n        return;\n      }\n\n      _this14.commands.focus(_this14.options.autofocus);\n\n      _this14.emit('create', {\n        editor: _assertThisInitialized(_this14)\n      });\n    }, 0);\n    return _this14;\n  }\n  /**\r\n   * An object of all registered commands.\r\n   */\n\n\n  _createClass(Editor, [{\n    key: \"commands\",\n    get: function get() {\n      return this.commandManager.createCommands();\n    }\n    /**\r\n     * Create a command chain to call multiple commands at once.\r\n     */\n\n  }, {\n    key: \"chain\",\n    value: function chain() {\n      return this.commandManager.createChain();\n    }\n    /**\r\n     * Check if a command or a command chain can be executed. Without executing it.\r\n     */\n\n  }, {\n    key: \"can\",\n    value: function can() {\n      return this.commandManager.createCan();\n    }\n    /**\r\n     * Inject CSS styles.\r\n     */\n\n  }, {\n    key: \"injectCSS\",\n    value: function injectCSS() {\n      if (this.options.injectCSS && document) {\n        this.css = createStyleTag(style);\n      }\n    }\n    /**\r\n     * Update editor options.\r\n     *\r\n     * @param options A list of options\r\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.options = _objectSpread(_objectSpread({}, this.options), options);\n    }\n    /**\r\n     * Update editable state of the editor.\r\n     */\n\n  }, {\n    key: \"setEditable\",\n    value: function setEditable(editable) {\n      this.setOptions({\n        editable: editable\n      });\n\n      if (this.view && this.state && !this.isDestroyed) {\n        this.view.updateState(this.state);\n      }\n    }\n    /**\r\n     * Returns whether the editor is editable.\r\n     */\n\n  }, {\n    key: \"isEditable\",\n    get: function get() {\n      return this.view && this.view.editable;\n    }\n    /**\r\n     * Returns the editor state.\r\n     */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.view.state;\n    }\n    /**\r\n     * Register a ProseMirror plugin.\r\n     *\r\n     * @param plugin A ProseMirror plugin\r\n     * @param handlePlugins Control how to merge the plugin into the existing plugins.\r\n     */\n\n  }, {\n    key: \"registerPlugin\",\n    value: function registerPlugin(plugin, handlePlugins) {\n      var plugins = typeof handlePlugins === 'function' ? handlePlugins(plugin, this.state.plugins) : [].concat(_toConsumableArray(this.state.plugins), [plugin]);\n      var state = this.state.reconfigure({\n        plugins: plugins\n      });\n      this.view.updateState(state);\n    }\n    /**\r\n     * Unregister a ProseMirror plugin.\r\n     *\r\n     * @param name The plugins name\r\n     */\n\n  }, {\n    key: \"unregisterPlugin\",\n    value: function unregisterPlugin(nameOrPluginKey) {\n      if (this.isDestroyed) {\n        return;\n      }\n\n      var name = typeof nameOrPluginKey === 'string' ? \"\".concat(nameOrPluginKey, \"$\") // @ts-ignore\n      : nameOrPluginKey.key;\n      var state = this.state.reconfigure({\n        // @ts-ignore\n        plugins: this.state.plugins.filter(function (plugin) {\n          return !plugin.key.startsWith(name);\n        })\n      });\n      this.view.updateState(state);\n    }\n    /**\r\n     * Creates an extension manager.\r\n     */\n\n  }, {\n    key: \"createExtensionManager\",\n    value: function createExtensionManager() {\n      var coreExtensions = Object.entries(extensions).map(function (_ref80) {\n        var _ref81 = _slicedToArray(_ref80, 2),\n            extension = _ref81[1];\n\n        return extension;\n      });\n      var allExtensions = [].concat(_toConsumableArray(coreExtensions), _toConsumableArray(this.options.extensions)).filter(function (extension) {\n        return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n      });\n      this.extensionManager = new ExtensionManager(allExtensions, this);\n    }\n    /**\r\n     * Creates an command manager.\r\n     */\n\n  }, {\n    key: \"createCommandManager\",\n    value: function createCommandManager() {\n      this.commandManager = new CommandManager(this, this.extensionManager.commands);\n    }\n    /**\r\n     * Creates a ProseMirror schema.\r\n     */\n\n  }, {\n    key: \"createSchema\",\n    value: function createSchema() {\n      this.schema = this.extensionManager.schema;\n    }\n    /**\r\n     * Creates a ProseMirror view.\r\n     */\n\n  }, {\n    key: \"createView\",\n    value: function createView() {\n      this.view = new EditorView(this.options.element, _objectSpread(_objectSpread({}, this.options.editorProps), {}, {\n        dispatchTransaction: this.dispatchTransaction.bind(this),\n        state: EditorState.create({\n          doc: createDocument(this.options.content, this.schema, this.options.parseOptions)\n        })\n      })); // `editor.view` is not yet available at this time.\n      // Therefore we will add all plugins and node views directly afterwards.\n\n      var newState = this.state.reconfigure({\n        plugins: this.extensionManager.plugins\n      });\n      this.view.updateState(newState);\n      this.createNodeViews(); // Letâ€™s store the editor instance in the DOM element.\n      // So weâ€™ll have access to it for tests.\n\n      var dom = this.view.dom;\n      dom.editor = this;\n    }\n    /**\r\n     * Creates all node views.\r\n     */\n\n  }, {\n    key: \"createNodeViews\",\n    value: function createNodeViews() {\n      this.view.setProps({\n        nodeViews: this.extensionManager.nodeViews\n      });\n    }\n  }, {\n    key: \"captureTransaction\",\n    value: function captureTransaction(fn) {\n      this.isCapturingTransaction = true;\n      fn();\n      this.isCapturingTransaction = false;\n      var tr = this.capturedTransaction;\n      this.capturedTransaction = null;\n      return tr;\n    }\n    /**\r\n     * The callback over which to send transactions (state updates) produced by the view.\r\n     *\r\n     * @param transaction An editor state transaction\r\n     */\n\n  }, {\n    key: \"dispatchTransaction\",\n    value: function dispatchTransaction(transaction) {\n      var _this15 = this;\n\n      if (this.isCapturingTransaction) {\n        if (!this.capturedTransaction) {\n          this.capturedTransaction = transaction;\n          return;\n        }\n\n        transaction.steps.forEach(function (step) {\n          var _a;\n\n          return (_a = _this15.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);\n        });\n        return;\n      }\n\n      var state = this.state.apply(transaction);\n      var selectionHasChanged = !this.state.selection.eq(state.selection);\n      this.view.updateState(state);\n      this.emit('transaction', {\n        editor: this,\n        transaction: transaction\n      });\n\n      if (selectionHasChanged) {\n        this.emit('selectionUpdate', {\n          editor: this\n        });\n      }\n\n      var focus = transaction.getMeta('focus');\n      var blur = transaction.getMeta('blur');\n\n      if (focus) {\n        this.emit('focus', {\n          editor: this,\n          event: focus.event\n        });\n      }\n\n      if (blur) {\n        this.emit('blur', {\n          editor: this,\n          event: blur.event\n        });\n      }\n\n      if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n        return;\n      }\n\n      this.emit('update', {\n        editor: this,\n        transaction: transaction\n      });\n    }\n    /**\r\n     * Get attributes of the currently selected node or mark.\r\n     */\n\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes(nameOrType) {\n      return _getAttributes(this.state, nameOrType);\n    }\n    /**\r\n     * Get attributes of the currently selected node.\r\n     *\r\n     * @param name Name of the node\r\n     */\n\n  }, {\n    key: \"getNodeAttributes\",\n    value: function getNodeAttributes(name) {\n      console.warn('[tiptap warn]: editor.getNodeAttributes() is deprecated. please use editor.getAttributes() instead.');\n      return _getNodeAttributes(this.state, name);\n    }\n    /**\r\n     * Get attributes of the currently selected mark.\r\n     *\r\n     * @param name Name of the mark\r\n     */\n\n  }, {\n    key: \"getMarkAttributes\",\n    value: function getMarkAttributes(name) {\n      console.warn('[tiptap warn]: editor.getMarkAttributes() is deprecated. please use editor.getAttributes() instead.');\n      return _getMarkAttributes(this.state, name);\n    }\n  }, {\n    key: \"isActive\",\n    value: function isActive(nameOrAttributes, attributesOrUndefined) {\n      var name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null;\n      var attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes;\n      return _isActive(this.state, name, attributes);\n    }\n    /**\r\n     * Get the document as JSON.\r\n     */\n\n  }, {\n    key: \"getJSON\",\n    value: function getJSON() {\n      return this.state.doc.toJSON();\n    }\n    /**\r\n     * Get the document as HTML.\r\n     */\n\n  }, {\n    key: \"getHTML\",\n    value: function getHTML() {\n      return getHTMLFromFragment(this.state.doc, this.schema);\n    }\n    /**\r\n     * Check if there is no content.\r\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return isNodeEmpty(this.state.doc);\n    }\n    /**\r\n     * Get the number of characters for the current document.\r\n     */\n\n  }, {\n    key: \"getCharacterCount\",\n    value: function getCharacterCount() {\n      return this.state.doc.content.size - 2;\n    }\n    /**\r\n     * Destroy the editor.\r\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.emit('destroy');\n\n      if (this.view) {\n        this.view.destroy();\n      }\n\n      this.removeAllListeners();\n      removeElement(this.css);\n    }\n    /**\r\n     * Check if the editor is already destroyed.\r\n     */\n\n  }, {\n    key: \"isDestroyed\",\n    get: function get() {\n      var _a; // @ts-ignore\n\n\n      return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n    }\n  }]);\n\n  return Editor;\n}(EventEmitter);\n\nvar Node = /*#__PURE__*/function () {\n  function Node() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Node);\n\n    this.type = 'node';\n    this.name = 'node';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = _objectSpread(_objectSpread({}, this.config), config);\n    this.name = this.config.name;\n    this.options = this.config.defaultOptions;\n  }\n\n  _createClass(Node, [{\n    key: \"configure\",\n    value: function configure() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // return a new instance so we can use the same extension\n      // with different calls of `configure`\n      var extension = this.extend();\n      extension.options = mergeDeep(this.options, options);\n      return extension;\n    }\n  }, {\n    key: \"extend\",\n    value: function extend() {\n      var extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var extension = new Node(extendedConfig);\n      extension.parent = this;\n      this.child = extension;\n      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n      extension.options = extendedConfig.defaultOptions ? extendedConfig.defaultOptions : extension.parent.options;\n      return extension;\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new Node(config);\n    }\n  }]);\n\n  return Node;\n}();\n\nvar Mark = /*#__PURE__*/function () {\n  function Mark() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Mark);\n\n    this.type = 'mark';\n    this.name = 'mark';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = _objectSpread(_objectSpread({}, this.config), config);\n    this.name = this.config.name;\n    this.options = this.config.defaultOptions;\n  }\n\n  _createClass(Mark, [{\n    key: \"configure\",\n    value: function configure() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // return a new instance so we can use the same extension\n      // with different calls of `configure`\n      var extension = this.extend();\n      extension.options = mergeDeep(this.options, options);\n      return extension;\n    }\n  }, {\n    key: \"extend\",\n    value: function extend() {\n      var extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var extension = new Mark(extendedConfig);\n      extension.parent = this;\n      this.child = extension;\n      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n      extension.options = extendedConfig.defaultOptions ? extendedConfig.defaultOptions : extension.parent.options;\n      return extension;\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new Mark(config);\n    }\n  }]);\n\n  return Mark;\n}();\n\nfunction isiOS() {\n  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform) // iPad on iOS 13 detection\n  || navigator.userAgent.includes('Mac') && 'ontouchend' in document;\n}\n\nvar NodeView = /*#__PURE__*/function () {\n  function NodeView(component, props, options) {\n    _classCallCheck(this, NodeView);\n\n    this.isDragging = false;\n    this.options = {\n      stopEvent: null,\n      update: null\n    };\n    this.component = component;\n    this.options = _objectSpread(_objectSpread({}, this.options), options);\n    this.editor = props.editor;\n    this.extension = props.extension;\n    this.node = props.node;\n    this.decorations = props.decorations;\n    this.getPos = props.getPos;\n    this.mount();\n  }\n\n  _createClass(NodeView, [{\n    key: \"mount\",\n    value: function mount() {\n      // eslint-disable-next-line\n      return;\n    }\n  }, {\n    key: \"dom\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"contentDOM\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"onDragStart\",\n    value: function onDragStart(event) {\n      var _a, _b, _c;\n\n      var view = this.editor.view;\n      var target = event.target; // get the drag handle element\n      // `closest` is not available for text nodes so we may have to use its parent\n\n      var dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]') : target.closest('[data-drag-handle]');\n\n      if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n        return;\n      }\n\n      var x = 0;\n      var y = 0; // calculate offset for drag element if we use a different drag handle element\n\n      if (this.dom !== dragHandle) {\n        var domBox = this.dom.getBoundingClientRect();\n        var handleBox = dragHandle.getBoundingClientRect();\n        x = handleBox.x - domBox.x + event.offsetX;\n        y = handleBox.y - domBox.y + event.offsetY;\n      }\n\n      (_c = event.dataTransfer) === null || _c === void 0 ? void 0 : _c.setDragImage(this.dom, x, y); // we need to tell ProseMirror that we want to move the whole node\n      // so we create a NodeSelection\n\n      var selection = NodeSelection.create(view.state.doc, this.getPos());\n      var transaction = view.state.tr.setSelection(selection);\n      view.dispatch(transaction);\n    }\n  }, {\n    key: \"stopEvent\",\n    value: function stopEvent(event) {\n      var _this16 = this;\n\n      var _a;\n\n      if (!this.dom) {\n        return false;\n      }\n\n      if (typeof this.options.stopEvent === 'function') {\n        return this.options.stopEvent(event);\n      }\n\n      var target = event.target;\n      var isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target)); // any event from child nodes should be handled by ProseMirror\n\n      if (!isInElement) {\n        return false;\n      }\n\n      var isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable; // any input event within node views should be ignored by ProseMirror\n\n      if (isInput) {\n        return true;\n      }\n\n      var isEditable = this.editor.isEditable;\n      var isDragging = this.isDragging;\n      var isDraggable = !!this.node.type.spec.draggable;\n      var isSelectable = NodeSelection.isSelectable(this.node);\n      var isCopyEvent = event.type === 'copy';\n      var isPasteEvent = event.type === 'paste';\n      var isCutEvent = event.type === 'cut';\n      var isClickEvent = event.type === 'mousedown';\n      var isDragEvent = event.type.startsWith('drag') || event.type === 'drop'; // ProseMirror tries to drag selectable nodes\n      // even if `draggable` is set to `false`\n      // this fix prevents that\n\n      if (!isDraggable && isSelectable && isDragEvent) {\n        event.preventDefault();\n      }\n\n      if (isDraggable && isDragEvent && !isDragging) {\n        event.preventDefault();\n        return false;\n      } // we have to store that dragging started\n\n\n      if (isDraggable && isEditable && !isDragging && isClickEvent) {\n        var dragHandle = target.closest('[data-drag-handle]');\n        var isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n\n        if (isValidDragHandle) {\n          this.isDragging = true;\n          document.addEventListener('dragend', function () {\n            _this16.isDragging = false;\n          }, {\n            once: true\n          });\n          document.addEventListener('mouseup', function () {\n            _this16.isDragging = false;\n          }, {\n            once: true\n          });\n        }\n      } // these events are handled by prosemirror\n\n\n      if (isDragging || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"ignoreMutation\",\n    value: function ignoreMutation(mutation) {\n      if (!this.dom || !this.contentDOM) {\n        return true;\n      } // a leaf/atom node is like a black box for ProseMirror\n      // and should be fully handled by the node view\n\n\n      if (this.node.isLeaf) {\n        return true;\n      } // ProseMirror should handle any selections\n\n\n      if (mutation.type === 'selection') {\n        return false;\n      } // try to prevent a bug on iOS that will break node views on enter\n      // this is because ProseMirror canâ€™t preventDispatch on enter\n      // this will lead to a re-render of the node view on enter\n      // see: https://github.com/ueberdosis/tiptap/issues/1214\n\n\n      if (this.dom.contains(mutation.target) && mutation.type === 'childList' && isiOS()) {\n        var changedNodes = [].concat(_toConsumableArray(Array.from(mutation.addedNodes)), _toConsumableArray(Array.from(mutation.removedNodes))); // weâ€™ll check if every changed node is contentEditable\n        // to make sure itâ€™s probably mutated by ProseMirror\n\n        if (changedNodes.every(function (node) {\n          return node.isContentEditable;\n        })) {\n          return false;\n        }\n      } // we will allow mutation contentDOM with attributes\n      // so we can for example adding classes within our node view\n\n\n      if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n        return true;\n      } // ProseMirror should handle any changes within contentDOM\n\n\n      if (this.contentDOM.contains(mutation.target)) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"updateAttributes\",\n    value: function updateAttributes(attributes) {\n      if (!this.editor.view.editable) {\n        return;\n      }\n\n      var state = this.editor.view.state;\n      var pos = this.getPos();\n      var transaction = state.tr.setNodeMarkup(pos, undefined, _objectSpread(_objectSpread({}, this.node.attrs), attributes));\n      this.editor.view.dispatch(transaction);\n    }\n  }, {\n    key: \"deleteNode\",\n    value: function deleteNode() {\n      var from = this.getPos();\n      var to = from + this.node.nodeSize;\n      this.editor.commands.deleteRange({\n        from: from,\n        to: to\n      });\n    }\n  }]);\n\n  return NodeView;\n}();\n\nfunction nodeInputRule(regexp, type, getAttributes) {\n  return new InputRule(regexp, function (state, match, start, end) {\n    var attributes = getAttributes instanceof Function ? getAttributes(match) : getAttributes;\n    var tr = state.tr;\n\n    if (match[0]) {\n      tr.replaceWith(start - 1, end, type.create(attributes));\n    }\n\n    return tr;\n  });\n}\n\nfunction getMarksBetween(from, to, state) {\n  var marks = [];\n  state.doc.nodesBetween(from, to, function (node, pos) {\n    marks = [].concat(_toConsumableArray(marks), _toConsumableArray(node.marks.map(function (mark) {\n      return {\n        from: pos,\n        to: pos + node.nodeSize,\n        mark: mark\n      };\n    })));\n  });\n  return marks;\n}\n\nfunction markInputRule(regexp, markType, getAttributes) {\n  return new InputRule(regexp, function (state, match, start, end) {\n    var attributes = getAttributes instanceof Function ? getAttributes(match) : getAttributes;\n    var tr = state.tr;\n    var captureGroup = match[match.length - 1];\n    var fullMatch = match[0];\n    var markEnd = end;\n\n    if (captureGroup) {\n      var startSpaces = fullMatch.search(/\\S/);\n      var textStart = start + fullMatch.indexOf(captureGroup);\n      var textEnd = textStart + captureGroup.length;\n      var excludedMarks = getMarksBetween(start, end, state).filter(function (item) {\n        // TODO: PR to add excluded to MarkType\n        // @ts-ignore\n        var excluded = item.mark.type.excluded;\n        return excluded.find(function (type) {\n          return type.name === markType.name;\n        });\n      }).filter(function (item) {\n        return item.to > textStart;\n      });\n\n      if (excludedMarks.length) {\n        return null;\n      }\n\n      if (textEnd < end) {\n        tr.delete(textEnd, end);\n      }\n\n      if (textStart > start) {\n        tr.delete(start + startSpaces, textStart);\n      }\n\n      markEnd = start + startSpaces + captureGroup.length;\n      tr.addMark(start + startSpaces, markEnd, markType.create(attributes));\n      tr.removeStoredMark(markType);\n    }\n\n    return tr;\n  });\n}\n\nfunction markPasteRule(regexp, type, getAttributes) {\n  var handler = function handler(fragment, parent) {\n    var nodes = [];\n    fragment.forEach(function (child) {\n      if (child.isText && child.text) {\n        var text = child.text;\n        var pos = 0;\n        var match; // eslint-disable-next-line\n\n        while ((match = regexp.exec(text)) !== null) {\n          var outerMatch = Math.max(match.length - 2, 0);\n          var innerMatch = Math.max(match.length - 1, 0);\n\n          if (parent === null || parent === void 0 ? void 0 : parent.type.allowsMarkType(type)) {\n            var start = match.index;\n            var matchStart = start + match[0].indexOf(match[outerMatch]);\n            var matchEnd = matchStart + match[outerMatch].length;\n            var textStart = matchStart + match[outerMatch].lastIndexOf(match[innerMatch]);\n            var textEnd = textStart + match[innerMatch].length;\n            var attrs = getAttributes instanceof Function ? getAttributes(match) : getAttributes; // adding text before markdown to nodes\n\n            if (matchStart > 0) {\n              nodes.push(child.cut(pos, matchStart));\n            } // adding the markdown part to nodes\n\n\n            nodes.push(child.cut(textStart, textEnd).mark(type.create(attrs).addToSet(child.marks)));\n            pos = matchEnd;\n          }\n        } // adding rest of text to nodes\n\n\n        if (pos < text.length) {\n          nodes.push(child.cut(pos));\n        }\n      } else {\n        nodes.push(child.copy(handler(child.content, child)));\n      }\n    });\n    return Fragment.fromArray(nodes);\n  };\n\n  return new Plugin({\n    key: new PluginKey('markPasteRule'),\n    props: {\n      transformPasted: function transformPasted(slice) {\n        return new Slice(handler(slice.content), slice.openStart, slice.openEnd);\n      }\n    }\n  });\n}\n\nfunction findChildren(node, predicate) {\n  var nodesWithPos = [];\n  node.descendants(function (child, pos) {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos: pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n/**\r\n * Same as `findChildren` but searches only within a `range`.\r\n */\n\n\nfunction findChildrenInRange(node, range, predicate) {\n  var nodesWithPos = []; // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n\n  node.nodesBetween(range.from, range.to, function (child, pos) {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos: pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\nfunction getSchema(extensions) {\n  var resolvedExtensions = ExtensionManager.resolve(extensions);\n  return getSchemaByResolvedExtensions(resolvedExtensions);\n}\n\nfunction generateHTML(doc, extensions) {\n  var schema = getSchema(extensions);\n  var contentNode = Node$1.fromJSON(schema, doc);\n  return getHTMLFromFragment(contentNode, schema);\n}\n\nfunction generateJSON(html, extensions) {\n  var schema = getSchema(extensions);\n  var dom = elementFromString(html);\n  return DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\n/**\r\n * Returns a node tree with node positions.\r\n */\n\n\nfunction getDebugJSON(node) {\n  var startOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var nodes = [];\n  node.forEach(function (n, offset) {\n    var from = startOffset + offset;\n    var to = from + n.nodeSize;\n    var marks = n.marks.map(function (mark) {\n      return {\n        type: mark.type.name,\n        attrs: _objectSpread({}, mark.attrs)\n      };\n    });\n\n    var attrs = _objectSpread({}, n.attrs);\n\n    var content = getDebugJSON(n, from + 1);\n    var output = {\n      type: n.type.name,\n      from: from,\n      to: to\n    };\n\n    if (Object.keys(attrs).length) {\n      output.attrs = attrs;\n    }\n\n    if (marks.length) {\n      output.marks = marks;\n    }\n\n    if (content.length) {\n      output.content = content;\n    }\n\n    if (n.text) {\n      output.text = n.text;\n    }\n\n    nodes.push(output);\n  });\n  return nodes;\n}\n\nfunction isNodeSelection(value) {\n  return isObject(value) && value instanceof NodeSelection;\n}\n\nfunction posToDOMRect(view, from, to) {\n  var start = view.coordsAtPos(from);\n  var end = view.coordsAtPos(to, -1);\n  var top = Math.min(start.top, end.top);\n  var bottom = Math.max(start.bottom, end.bottom);\n  var left = Math.min(start.left, end.left);\n  var right = Math.max(start.right, end.right);\n  var width = right - left;\n  var height = bottom - top;\n  var x = left;\n  var y = top;\n  var data = {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right,\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n  return _objectSpread(_objectSpread({}, data), {}, {\n    toJSON: function toJSON() {\n      return data;\n    }\n  });\n}\n\nexport { Editor, Extension, Mark, Node, NodeView, callOrReturn, extensions, findChildren, findChildrenInRange, findParentNode, findParentNodeClosestToPos, generateHTML, generateJSON, _getAttributes as getAttributes, getDebugJSON, getExtensionField, getHTMLFromFragment, _getMarkAttributes as getMarkAttributes, getMarkRange, getMarkType, getMarksBetween, _getNodeAttributes as getNodeAttributes, getNodeType, getSchema, _isActive as isActive, isList, isMarkActive, isNodeActive, isNodeEmpty, isNodeSelection, isTextSelection, markInputRule, markPasteRule, mergeAttributes, nodeInputRule, posToDOMRect };","map":null,"metadata":{},"sourceType":"module"}