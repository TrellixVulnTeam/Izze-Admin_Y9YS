{"ast":null,"code":"import { Node, mergeAttributes, nodeInputRule } from '@tiptap/core';\nimport { TextSelection } from 'prosemirror-state';\nconst HorizontalRule = Node.create({\n  name: 'horizontalRule',\n  defaultOptions: {\n    HTMLAttributes: {}\n  },\n  group: 'block',\n\n  parseHTML() {\n    return [{\n      tag: 'hr'\n    }];\n  },\n\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({\n        chain\n      }) => {\n        return chain().insertContent({\n          type: this.name\n        }).command(({\n          tr,\n          dispatch\n        }) => {\n          var _a;\n\n          if (dispatch) {\n            const {\n              parent,\n              pos\n            } = tr.selection.$from;\n            const posAfter = pos + 1;\n            const nodeAfter = tr.doc.nodeAt(posAfter); // end of document\n\n            if (!nodeAfter) {\n              const node = (_a = parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n\n              if (node) {\n                tr.insert(posAfter, node);\n                tr.setSelection(TextSelection.create(tr.doc, posAfter));\n              }\n            }\n\n            tr.scrollIntoView();\n          }\n\n          return true;\n        }).run();\n      }\n    };\n  },\n\n  addInputRules() {\n    return [nodeInputRule(/^(?:---|—-|___\\s|\\*\\*\\*\\s)$/, this.type)];\n  }\n\n});\nexport default HorizontalRule;\nexport { HorizontalRule };","map":{"version":3,"sources":["../src/horizontal-rule.ts"],"names":[],"mappings":";;MAuBa,cAAc,GAAG,IAAI,CAAC,MAAL,CAAmC;AAC/D,EAAA,IAAI,EAAE,gBADyD;AAG/D,EAAA,cAAc,EAAE;AACd,IAAA,cAAc,EAAE;AADF,GAH+C;AAO/D,EAAA,KAAK,EAAE,OAPwD;;AAS/D,EAAA,SAAS,GAAA;AACP,WAAO,CACL;AAAE,MAAA,GAAG,EAAE;AAAP,KADK,CAAP;AAGD,GAb8D;;AAe/D,EAAA,UAAU,CAAC;AAAE,IAAA;AAAF,GAAD,EAAmB;AAC3B,WAAO,CAAC,IAAD,EAAO,eAAe,CAAC,KAAK,OAAL,CAAa,cAAd,EAA8B,cAA9B,CAAtB,CAAP;AACD,GAjB8D;;AAmB/D,EAAA,WAAW,GAAA;AACT,WAAO;AACL,MAAA,iBAAiB,EAAE,MAAM,CAAC;AAAE,QAAA;AAAF,OAAD,KAAU;AACjC,eAAO,KAAK,GACT,aADI,CACU;AAAE,UAAA,IAAI,EAAE,KAAK;AAAb,SADV,EAEJ,OAFI,CAEI,CAAC;AAAE,UAAA,EAAF;AAAM,UAAA;AAAN,SAAD,KAAiB;;;AACxB,cAAI,QAAJ,EAAc;AACZ,kBAAM;AAAE,cAAA,MAAF;AAAU,cAAA;AAAV,gBAAkB,EAAE,CAAC,SAAH,CAAa,KAArC;AACA,kBAAM,QAAQ,GAAG,GAAG,GAAG,CAAvB;AACA,kBAAM,SAAS,GAAG,EAAE,CAAC,GAAH,CAAO,MAAP,CAAc,QAAd,CAAlB,CAHY,C;;AAMZ,gBAAI,CAAC,SAAL,EAAgB;AACd,oBAAM,IAAI,GAAG,CAAA,EAAA,GAAA,MAAM,CAAC,IAAP,CAAY,YAAZ,CAAyB,WAAzB,MAAoC,IAApC,IAAoC,EAAA,KAAA,KAAA,CAApC,GAAoC,KAAA,CAApC,GAAoC,EAAA,CAAE,MAAF,EAAjD;;AAEA,kBAAI,IAAJ,EAAU;AACR,gBAAA,EAAE,CAAC,MAAH,CAAU,QAAV,EAAoB,IAApB;AACA,gBAAA,EAAE,CAAC,YAAH,CAAgB,aAAa,CAAC,MAAd,CAAqB,EAAE,CAAC,GAAxB,EAA6B,QAA7B,CAAhB;AACD;AACF;;AAED,YAAA,EAAE,CAAC,cAAH;AACD;;AAED,iBAAO,IAAP;AACD,SAtBI,EAuBJ,GAvBI,EAAP;AAwBD;AA1BI,KAAP;AA4BD,GAhD8D;;AAkD/D,EAAA,aAAa,GAAA;AACX,WAAO,CACL,aAAa,CAAC,6BAAD,EAAgC,KAAK,IAArC,CADR,CAAP;AAGD;;AAtD8D,CAAnC,C","sourcesContent":["import {\n  Command,\n  Node,\n  nodeInputRule,\n  mergeAttributes,\n} from '@tiptap/core'\nimport { TextSelection } from 'prosemirror-state'\n\nexport interface HorizontalRuleOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       */\n      setHorizontalRule: () => Command,\n    }\n  }\n}\n\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  defaultOptions: {\n    HTMLAttributes: {},\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [\n      { tag: 'hr' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({ chain }) => {\n        return chain()\n          .insertContent({ type: this.name })\n          .command(({ tr, dispatch }) => {\n            if (dispatch) {\n              const { parent, pos } = tr.selection.$from\n              const posAfter = pos + 1\n              const nodeAfter = tr.doc.nodeAt(posAfter)\n\n              // end of document\n              if (!nodeAfter) {\n                const node = parent.type.contentMatch.defaultType?.create()\n\n                if (node) {\n                  tr.insert(posAfter, node)\n                  tr.setSelection(TextSelection.create(tr.doc, posAfter))\n                }\n              }\n\n              tr.scrollIntoView()\n            }\n\n            return true\n          })\n          .run()\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule(/^(?:---|—-|___\\s|\\*\\*\\*\\s)$/, this.type),\n    ]\n  },\n})\n"]},"metadata":{},"sourceType":"module"}