{"ast":null,"code":"import { isNodeSelection, posToDOMRect, Extension } from '@tiptap/core';\nimport { PluginKey, Plugin } from 'prosemirror-state';\nimport tippy from 'tippy.js';\n\nclass BubbleMenuView {\n  constructor({\n    editor,\n    element,\n    view,\n    tippyOptions\n  }) {\n    this.preventHide = false;\n\n    this.mousedownHandler = () => {\n      this.preventHide = true;\n    };\n\n    this.focusHandler = () => {\n      // we use `setTimeout` to make sure `selection` is already updated\n      setTimeout(() => this.update(this.editor.view));\n    };\n\n    this.blurHandler = ({\n      event\n    }) => {\n      var _a;\n\n      if (this.preventHide) {\n        this.preventHide = false;\n        return;\n      }\n\n      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n        return;\n      }\n\n      this.hide();\n    };\n\n    this.editor = editor;\n    this.element = element;\n    this.view = view;\n    this.element.addEventListener('mousedown', this.mousedownHandler, {\n      capture: true\n    });\n    this.editor.on('focus', this.focusHandler);\n    this.editor.on('blur', this.blurHandler);\n    this.createTooltip(tippyOptions);\n    this.element.style.visibility = 'visible';\n  }\n\n  createTooltip(options = {}) {\n    this.tippy = tippy(this.view.dom, {\n      duration: 0,\n      getReferenceClientRect: null,\n      content: this.element,\n      interactive: true,\n      trigger: 'manual',\n      placement: 'top',\n      hideOnClick: 'toggle',\n      ...options\n    });\n  }\n\n  update(view, oldState) {\n    const {\n      state,\n      composing\n    } = view;\n    const {\n      doc,\n      selection\n    } = state;\n    const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\n\n    if (composing || isSame) {\n      return;\n    }\n\n    const {\n      empty,\n      $anchor,\n      ranges\n    } = selection; // support for CellSelections\n\n    const from = Math.min(...ranges.map(range => range.$from.pos));\n    const to = Math.max(...ranges.map(range => range.$to.pos)); // Sometime check for `empty` is not enough.\n    // Doubleclick an empty paragraph returns a node size of 2.\n    // So we check also for an empty text size.\n\n    if (empty || !$anchor.parent.textContent) {\n      this.hide();\n      return;\n    }\n\n    this.tippy.setProps({\n      getReferenceClientRect: () => {\n        if (isNodeSelection(view.state.selection)) {\n          const node = view.nodeDOM(from);\n\n          if (node) {\n            return node.getBoundingClientRect();\n          }\n        }\n\n        return posToDOMRect(view, from, to);\n      }\n    });\n    this.show();\n  }\n\n  show() {\n    this.tippy.show();\n  }\n\n  hide() {\n    this.tippy.hide();\n  }\n\n  destroy() {\n    this.tippy.destroy();\n    this.element.removeEventListener('mousedown', this.mousedownHandler);\n    this.editor.off('focus', this.focusHandler);\n    this.editor.off('blur', this.blurHandler);\n  }\n\n}\n\nconst BubbleMenuPluginKey = new PluginKey('menuBubble');\n\nconst BubbleMenuPlugin = options => {\n  return new Plugin({\n    key: BubbleMenuPluginKey,\n    view: view => new BubbleMenuView({\n      view,\n      ...options\n    })\n  });\n};\n\nconst BubbleMenu = Extension.create({\n  name: 'bubbleMenu',\n  defaultOptions: {\n    element: null,\n    tippyOptions: {}\n  },\n\n  addProseMirrorPlugins() {\n    if (!this.options.element) {\n      return [];\n    }\n\n    return [BubbleMenuPlugin({\n      editor: this.editor,\n      element: this.options.element,\n      tippyOptions: this.options.tippyOptions\n    })];\n  }\n\n});\nexport default BubbleMenu;\nexport { BubbleMenu, BubbleMenuPlugin, BubbleMenuPluginKey, BubbleMenuView };","map":null,"metadata":{},"sourceType":"module"}