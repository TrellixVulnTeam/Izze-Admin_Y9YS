{"ast":null,"code":"import { Plugin, PluginKey, TextSelection, Selection, NodeSelection, EditorState } from 'prosemirror-state';\nimport { EditorView } from 'prosemirror-view';\nimport { Fragment, DOMParser, DOMSerializer, Schema, Slice, Node as Node$1 } from 'prosemirror-model';\nimport { keymap } from 'prosemirror-keymap';\nimport { inputRules, undoInputRule as undoInputRule$2, InputRule } from 'prosemirror-inputrules';\nimport { liftTarget, ReplaceStep, ReplaceAroundStep, canSplit } from 'prosemirror-transform';\nimport { createParagraphNear as createParagraphNear$2, deleteSelection as deleteSelection$2, exitCode as exitCode$2, joinBackward as joinBackward$2, joinForward as joinForward$2, lift as lift$2, liftEmptyBlock as liftEmptyBlock$2, newlineInCode as newlineInCode$2, selectAll as selectAll$2, selectNodeBackward as selectNodeBackward$2, selectNodeForward as selectNodeForward$2, selectParentNode as selectParentNode$2, setBlockType, wrapIn as wrapIn$2 } from 'prosemirror-commands';\nimport { liftListItem as liftListItem$2, sinkListItem as sinkListItem$2, wrapInList as wrapInList$2 } from 'prosemirror-schema-list';\n\nfunction getSchemaTypeNameByName(name, schema) {\n  if (schema.nodes[name]) {\n    return 'node';\n  }\n\n  if (schema.marks[name]) {\n    return 'mark';\n  }\n\n  return null;\n}\n\nfunction getNodeType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n\n    return schema.nodes[nameOrType];\n  }\n\n  return nameOrType;\n}\n\nfunction getNodeAttributes(state, typeOrName) {\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    from,\n    to\n  } = state.selection;\n  let nodes = [];\n  state.doc.nodesBetween(from, to, node => {\n    nodes = [...nodes, node];\n  });\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name);\n\n  if (node) {\n    return { ...node.attrs\n    };\n  }\n\n  return {};\n}\n\nfunction getMarkType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n\n    return schema.marks[nameOrType];\n  }\n\n  return nameOrType;\n}\n\nfunction getMarkAttributes(state, typeOrName) {\n  const type = getMarkType(typeOrName, state.schema);\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  let marks = [];\n\n  if (empty) {\n    marks = state.selection.$head.marks();\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks = [...marks, ...node.marks];\n    });\n  }\n\n  const mark = marks.find(markItem => markItem.type.name === type.name);\n\n  if (mark) {\n    return { ...mark.attrs\n    };\n  }\n\n  return {};\n}\n\nfunction getAttributes(state, typeOrName) {\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName);\n  }\n\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName);\n  }\n\n  return {};\n}\n/**\r\n * Check if object1 includes object2\r\n * @param object1 Object\r\n * @param object2 Object\r\n */\n\n\nfunction objectIncludes(object1, object2) {\n  const keys = Object.keys(object2);\n\n  if (!keys.length) {\n    return true;\n  }\n\n  return !!keys.filter(key => object2[key] === object1[key]).length;\n}\n\nfunction isNodeActive(state, typeOrName, attributes = {}) {\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n  let nodeRanges = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isText) {\n      const relativeFrom = Math.max(from, pos);\n      const relativeTo = Math.min(to, pos + node.nodeSize);\n      nodeRanges = [...nodeRanges, {\n        node,\n        from: relativeFrom,\n        to: relativeTo\n      }];\n    }\n  });\n\n  if (empty) {\n    return !!nodeRanges.filter(nodeRange => {\n      if (!type) {\n        return true;\n      }\n\n      return type.name === nodeRange.node.type.name;\n    }).find(nodeRange => objectIncludes(nodeRange.node.attrs, attributes));\n  }\n\n  const selectionRange = to - from;\n  const range = nodeRanges.filter(nodeRange => {\n    if (!type) {\n      return true;\n    }\n\n    return type.name === nodeRange.node.type.name;\n  }).filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes)).reduce((sum, nodeRange) => {\n    const size = nodeRange.to - nodeRange.from;\n    return sum + size;\n  }, 0);\n  return range >= selectionRange;\n}\n\nfunction isMarkActive(state, typeOrName, attributes = {}) {\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks()).filter(mark => {\n      if (!type) {\n        return true;\n      }\n\n      return type.name === mark.type.name;\n    }).find(mark => objectIncludes(mark.attrs, attributes));\n  }\n\n  let selectionRange = 0;\n  let markRanges = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      const relativeFrom = Math.max(from, pos);\n      const relativeTo = Math.min(to, pos + node.nodeSize);\n      const range = relativeTo - relativeFrom;\n      selectionRange += range;\n      markRanges = [...markRanges, ...node.marks.map(mark => ({\n        mark,\n        from: relativeFrom,\n        to: relativeTo\n      }))];\n    }\n  });\n\n  if (selectionRange === 0) {\n    return false;\n  } // calculate range of matched mark\n\n\n  const matchedRange = markRanges.filter(markRange => {\n    if (!type) {\n      return true;\n    }\n\n    return type.name === markRange.mark.type.name;\n  }).filter(markRange => objectIncludes(markRange.mark.attrs, attributes)).reduce((sum, markRange) => {\n    const size = markRange.to - markRange.from;\n    return sum + size;\n  }, 0); // calculate range of marks that excludes the searched mark\n  // for example `code` doesnâ€™t allow any other marks\n\n  const excludedRange = markRanges.filter(markRange => {\n    if (!type) {\n      return true;\n    }\n\n    return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n  }).reduce((sum, markRange) => {\n    const size = markRange.to - markRange.from;\n    return sum + size;\n  }, 0); // we only include the result of `excludedRange`\n  // if there is a match at all\n\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n  return range >= selectionRange;\n}\n\nfunction isActive(state, name, attributes = {}) {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n  }\n\n  const schemaType = getSchemaTypeNameByName(name, state.schema);\n\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes);\n  }\n\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes);\n  }\n\n  return false;\n}\n\nfunction removeElement(element) {\n  if (element && element.parentNode) {\n    element.parentNode.removeChild(element);\n  }\n}\n\nfunction elementFromString(value) {\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = `<body>${value}</body>`;\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;\n}\n\nfunction createNodeFromContent(content, schema, options) {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options\n  };\n\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content)) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)));\n      }\n\n      return schema.nodeFromJSON(content);\n    } catch (error) {\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);\n      return createNodeFromContent('', schema, options);\n    }\n  }\n\n  if (typeof content === 'string') {\n    const parser = DOMParser.fromSchema(schema);\n    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);\n  }\n\n  return createNodeFromContent('', schema, options);\n}\n\nfunction createDocument(content, schema, parseOptions = {}) {\n  return createNodeFromContent(content, schema, {\n    slice: false,\n    parseOptions\n  });\n}\n\nfunction getHTMLFromFragment(doc, schema) {\n  const fragment = DOMSerializer.fromSchema(schema).serializeFragment(doc.content);\n  const temporaryDocument = document.implementation.createHTMLDocument();\n  const container = temporaryDocument.createElement('div');\n  container.appendChild(fragment);\n  return container.innerHTML;\n}\n\nfunction isNodeEmpty(node) {\n  var _a;\n\n  const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();\n  const content = node.toJSON();\n  return JSON.stringify(defaultContent) === JSON.stringify(content);\n}\n\nfunction createStyleTag(style) {\n  const tipTapStyleTag = document.querySelector('style[data-tiptap-style]');\n\n  if (tipTapStyleTag !== null) {\n    return tipTapStyleTag;\n  }\n\n  const styleNode = document.createElement('style');\n  styleNode.setAttribute('data-tiptap-style', '');\n  styleNode.innerHTML = style;\n  document.getElementsByTagName('head')[0].appendChild(styleNode);\n  return styleNode;\n}\n\nclass CommandManager {\n  constructor(editor, commands) {\n    this.editor = editor;\n    this.commands = commands;\n  }\n\n  createCommands() {\n    const {\n      commands,\n      editor\n    } = this;\n    const {\n      state,\n      view\n    } = editor;\n    const {\n      tr\n    } = state;\n    const props = this.buildProps(tr);\n    return Object.fromEntries(Object.entries(commands).map(([name, command]) => {\n      const method = (...args) => {\n        const callback = command(...args)(props);\n\n        if (!tr.getMeta('preventDispatch')) {\n          view.dispatch(tr);\n        }\n\n        return callback;\n      };\n\n      return [name, method];\n    }));\n  }\n\n  createChain(startTr, shouldDispatch = true) {\n    const {\n      commands,\n      editor\n    } = this;\n    const {\n      state,\n      view\n    } = editor;\n    const callbacks = [];\n    const hasStartTransaction = !!startTr;\n    const tr = startTr || state.tr;\n\n    const run = () => {\n      if (!hasStartTransaction && shouldDispatch && !tr.getMeta('preventDispatch')) {\n        view.dispatch(tr);\n      }\n\n      return callbacks.every(callback => callback === true);\n    };\n\n    const chain = { ...Object.fromEntries(Object.entries(commands).map(([name, command]) => {\n        const chainedCommand = (...args) => {\n          const props = this.buildProps(tr, shouldDispatch);\n          const callback = command(...args)(props);\n          callbacks.push(callback);\n          return chain;\n        };\n\n        return [name, chainedCommand];\n      })),\n      run\n    };\n    return chain;\n  }\n\n  createCan(startTr) {\n    const {\n      commands,\n      editor\n    } = this;\n    const {\n      state\n    } = editor;\n    const dispatch = undefined;\n    const tr = startTr || state.tr;\n    const props = this.buildProps(tr, dispatch);\n    const formattedCommands = Object.fromEntries(Object.entries(commands).map(([name, command]) => {\n      return [name, (...args) => command(...args)({ ...props,\n        dispatch\n      })];\n    }));\n    return { ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch)\n    };\n  }\n\n  buildProps(tr, shouldDispatch = true) {\n    const {\n      editor,\n      commands\n    } = this;\n    const {\n      state,\n      view\n    } = editor;\n\n    if (state.storedMarks) {\n      tr.setStoredMarks(state.storedMarks);\n    }\n\n    const props = {\n      tr,\n      editor,\n      view,\n      state: this.chainableState(tr, state),\n      dispatch: shouldDispatch ? () => undefined : undefined,\n      chain: () => this.createChain(tr),\n      can: () => this.createCan(tr),\n\n      get commands() {\n        return Object.fromEntries(Object.entries(commands).map(([name, command]) => {\n          return [name, (...args) => command(...args)(props)];\n        }));\n      }\n\n    };\n    return props;\n  }\n\n  chainableState(tr, state) {\n    let {\n      selection\n    } = tr;\n    let {\n      doc\n    } = tr;\n    let {\n      storedMarks\n    } = tr;\n    return { ...state,\n      schema: state.schema,\n      plugins: state.plugins,\n      apply: state.apply.bind(state),\n      applyTransaction: state.applyTransaction.bind(state),\n      reconfigure: state.reconfigure.bind(state),\n      toJSON: state.toJSON.bind(state),\n\n      get storedMarks() {\n        return storedMarks;\n      },\n\n      get selection() {\n        return selection;\n      },\n\n      get doc() {\n        return doc;\n      },\n\n      get tr() {\n        selection = tr.selection;\n        doc = tr.doc;\n        storedMarks = tr.storedMarks;\n        return tr;\n      }\n\n    };\n  }\n\n}\n\nfunction getExtensionField(extension, field, context = {}) {\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context);\n  }\n\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({ ...context,\n      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n    });\n    return value;\n  }\n\n  return extension.config[field];\n}\n\nfunction splitExtensions(extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension');\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node');\n  const markExtensions = extensions.filter(extension => extension.type === 'mark');\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions\n  };\n}\n/**\r\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\r\n * @param extensions List of extensions\r\n */\n\n\nfunction getAttributesFromExtensions(extensions) {\n  const extensionAttributes = [];\n  const {\n    nodeExtensions,\n    markExtensions\n  } = splitExtensions(extensions);\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\n  const defaultAttribute = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true\n  };\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options\n    };\n    const addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);\n\n    if (!addGlobalAttributes) {\n      return;\n    } // TODO: remove `as GlobalAttributes`\n\n\n    const globalAttributes = addGlobalAttributes();\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {\n          extensionAttributes.push({\n            type,\n            name,\n            attribute: { ...defaultAttribute,\n              ...attribute\n            }\n          });\n        });\n      });\n    });\n  });\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options\n    };\n    const addAttributes = getExtensionField(extension, 'addAttributes', context);\n\n    if (!addAttributes) {\n      return;\n    } // TODO: remove `as Attributes`\n\n\n    const attributes = addAttributes();\n    Object.entries(attributes).forEach(([name, attribute]) => {\n      extensionAttributes.push({\n        type: extension.name,\n        name,\n        attribute: { ...defaultAttribute,\n          ...attribute\n        }\n      });\n    });\n  });\n  return extensionAttributes;\n}\n\nfunction mergeAttributes(...objects) {\n  return objects.filter(item => !!item).reduce((items, item) => {\n    const mergedAttributes = { ...items\n    };\n    Object.entries(item).forEach(([key, value]) => {\n      const exists = mergedAttributes[key];\n\n      if (!exists) {\n        mergedAttributes[key] = value;\n        return;\n      }\n\n      if (key === 'class') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join(' ');\n      } else if (key === 'style') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join('; ');\n      } else {\n        mergedAttributes[key] = value;\n      }\n    });\n    return mergedAttributes;\n  }, {});\n}\n\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n  return extensionAttributes.filter(item => item.attribute.rendered).map(item => {\n    if (!item.attribute.renderHTML) {\n      return {\n        [item.name]: nodeOrMark.attrs[item.name]\n      };\n    }\n\n    return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n  }).reduce((attributes, attribute) => {\n    return mergeAttributes(attributes, attribute);\n  }, {});\n}\n\nfunction isEmptyObject(object = {}) {\n  return Object.keys(object).length === 0 && object.constructor === Object;\n}\n\nfunction fromString(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  if (value.match(/^\\d*(\\.\\d+)?$/)) {\n    return Number(value);\n  }\n\n  if (value === 'true') {\n    return true;\n  }\n\n  if (value === 'false') {\n    return false;\n  }\n\n  return value;\n}\n/**\r\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\r\n * Cancels when `getAttrs` returned `false`.\r\n * @param parseRule ProseMirror ParseRule\r\n * @param extensionAttributes List of attributes to inject\r\n */\n\n\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n  if (parseRule.style) {\n    return parseRule;\n  }\n\n  return { ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n\n      if (oldAttributes === false) {\n        return false;\n      }\n\n      const newAttributes = extensionAttributes.filter(item => item.attribute.rendered).reduce((items, item) => {\n        const attributes = item.attribute.parseHTML ? item.attribute.parseHTML(node) || {} : {\n          [item.name]: fromString(node.getAttribute(item.name))\n        };\n        const filteredAttributes = Object.fromEntries(Object.entries(attributes).filter(([, value]) => value !== undefined && value !== null));\n        return { ...items,\n          ...filteredAttributes\n        };\n      }, {});\n      return { ...oldAttributes,\n        ...newAttributes\n      };\n    }\n  };\n}\n/**\r\n * Optionally calls `value` as a function.\r\n * Otherwise it is returned directly.\r\n * @param value Function or any value.\r\n * @param context Optional context to bind to function.\r\n * @param props Optional props to pass to function.\r\n */\n\n\nfunction callOrReturn(value, context = undefined, ...props) {\n  if (typeof value === 'function') {\n    if (context) {\n      return value.bind(context)(...props);\n    }\n\n    return value(...props);\n  }\n\n  return value;\n}\n\nfunction cleanUpSchemaItem(data) {\n  return Object.fromEntries(Object.entries(data).filter(([key, value]) => {\n    if (key === 'attrs' && isEmptyObject(value)) {\n      return false;\n    }\n\n    return value !== null && value !== undefined;\n  }));\n}\n\nfunction getSchemaByResolvedExtensions(extensions) {\n  var _a;\n\n  const allAttributes = getAttributesFromExtensions(extensions);\n  const {\n    nodeExtensions,\n    markExtensions\n  } = splitExtensions(extensions);\n  const topNode = (_a = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))) === null || _a === void 0 ? void 0 : _a.name;\n  const nodes = Object.fromEntries(nodeExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options\n    };\n    const extraNodeFields = extensions.reduce((fields, e) => {\n      const extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);\n      return { ...fields,\n        ...(extendNodeSchema ? extendNodeSchema(extension) : {})\n      };\n    }, {});\n    const schema = cleanUpSchemaItem({ ...extraNodeFields,\n      content: callOrReturn(getExtensionField(extension, 'content', context)),\n      marks: callOrReturn(getExtensionField(extension, 'marks', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      inline: callOrReturn(getExtensionField(extension, 'inline', context)),\n      atom: callOrReturn(getExtensionField(extension, 'atom', context)),\n      selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),\n      draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      defining: callOrReturn(getExtensionField(extension, 'defining', context)),\n      isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        var _a;\n\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    });\n    const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n\n    const renderHTML = getExtensionField(extension, 'renderHTML', context);\n\n    if (renderHTML) {\n      schema.toDOM = node => renderHTML({\n        node,\n        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n      });\n    }\n\n    return [extension.name, schema];\n  }));\n  const marks = Object.fromEntries(markExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options\n    };\n    const extraMarkFields = extensions.reduce((fields, e) => {\n      const extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);\n      return { ...fields,\n        ...(extendMarkSchema ? extendMarkSchema(extension) : {})\n      };\n    }, {});\n    const schema = cleanUpSchemaItem({ ...extraMarkFields,\n      inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),\n      excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        var _a;\n\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    });\n    const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n\n    const renderHTML = getExtensionField(extension, 'renderHTML', context);\n\n    if (renderHTML) {\n      schema.toDOM = mark => renderHTML({\n        mark,\n        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n      });\n    }\n\n    return [extension.name, schema];\n  }));\n  return new Schema({\n    topNode,\n    nodes,\n    marks\n  });\n}\n\nfunction getSchemaTypeByName(name, schema) {\n  if (schema.nodes[name]) {\n    return schema.nodes[name];\n  }\n\n  if (schema.marks[name]) {\n    return schema.marks[name];\n  }\n\n  return null;\n}\n\nclass ExtensionManager {\n  constructor(extensions, editor) {\n    this.splittableMarks = [];\n    this.editor = editor;\n    this.extensions = ExtensionManager.resolve(extensions);\n    this.schema = getSchemaByResolvedExtensions(this.extensions);\n    this.extensions.forEach(extension => {\n      var _a;\n\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n\n      if (extension.type === 'mark') {\n        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;\n\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name);\n        }\n      }\n\n      const onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);\n\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate);\n      }\n\n      const onCreate = getExtensionField(extension, 'onCreate', context);\n\n      if (onCreate) {\n        this.editor.on('create', onCreate);\n      }\n\n      const onUpdate = getExtensionField(extension, 'onUpdate', context);\n\n      if (onUpdate) {\n        this.editor.on('update', onUpdate);\n      }\n\n      const onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);\n\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate);\n      }\n\n      const onTransaction = getExtensionField(extension, 'onTransaction', context);\n\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction);\n      }\n\n      const onFocus = getExtensionField(extension, 'onFocus', context);\n\n      if (onFocus) {\n        this.editor.on('focus', onFocus);\n      }\n\n      const onBlur = getExtensionField(extension, 'onBlur', context);\n\n      if (onBlur) {\n        this.editor.on('blur', onBlur);\n      }\n\n      const onDestroy = getExtensionField(extension, 'onDestroy', context);\n\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy);\n      }\n    });\n  }\n\n  static resolve(extensions) {\n    return ExtensionManager.sort(ExtensionManager.flatten(extensions));\n  }\n\n  static flatten(extensions) {\n    return extensions.map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options\n      };\n      const addExtensions = getExtensionField(extension, 'addExtensions', context);\n\n      if (addExtensions) {\n        return [extension, ...this.flatten(addExtensions())];\n      }\n\n      return extension;\n    }) // `Infinity` will break TypeScript so we set a number that is probably high enough\n    .flat(10);\n  }\n\n  static sort(extensions) {\n    const defaultPriority = 100;\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField(a, 'priority') || defaultPriority;\n      const priorityB = getExtensionField(b, 'priority') || defaultPriority;\n\n      if (priorityA > priorityB) {\n        return -1;\n      }\n\n      if (priorityA < priorityB) {\n        return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  get commands() {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const addCommands = getExtensionField(extension, 'addCommands', context);\n\n      if (!addCommands) {\n        return commands;\n      }\n\n      return { ...commands,\n        ...addCommands()\n      };\n    }, {});\n  }\n\n  get plugins() {\n    return [...this.extensions].reverse().map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const plugins = [];\n      const addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);\n\n      if (addKeyboardShortcuts) {\n        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n          return [shortcut, () => method({\n            editor: this.editor\n          })];\n        }));\n        const keyMapPlugin = keymap(bindings);\n        plugins.push(keyMapPlugin);\n      }\n\n      const addInputRules = getExtensionField(extension, 'addInputRules', context);\n\n      if (this.editor.options.enableInputRules && addInputRules) {\n        const inputRules$1 = addInputRules();\n        const inputRulePlugins = inputRules$1.length ? [inputRules({\n          rules: inputRules$1\n        })] : [];\n        plugins.push(...inputRulePlugins);\n      }\n\n      const addPasteRules = getExtensionField(extension, 'addPasteRules', context);\n\n      if (this.editor.options.enablePasteRules && addPasteRules) {\n        const pasteRulePlugins = addPasteRules();\n        plugins.push(...pasteRulePlugins);\n      }\n\n      const addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);\n\n      if (addProseMirrorPlugins) {\n        const proseMirrorPlugins = addProseMirrorPlugins();\n        plugins.push(...proseMirrorPlugins);\n      }\n\n      return plugins;\n    }).flat();\n  }\n\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions);\n  }\n\n  get nodeViews() {\n    const {\n      editor\n    } = this;\n    const {\n      nodeExtensions\n    } = splitExtensions(this.extensions);\n    return Object.fromEntries(nodeExtensions.filter(extension => !!getExtensionField(extension, 'addNodeView')).map(extension => {\n      const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name);\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        editor,\n        type: getNodeType(extension.name, this.schema)\n      };\n      const addNodeView = getExtensionField(extension, 'addNodeView', context);\n\n      if (!addNodeView) {\n        return [];\n      }\n\n      const nodeview = (node, view, getPos, decorations) => {\n        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n        return addNodeView()({\n          editor,\n          node,\n          getPos,\n          decorations,\n          HTMLAttributes,\n          extension\n        });\n      };\n\n      return [extension.name, nodeview];\n    }));\n  }\n\n  get textSerializers() {\n    const {\n      editor\n    } = this;\n    const {\n      nodeExtensions\n    } = splitExtensions(this.extensions);\n    return Object.fromEntries(nodeExtensions.filter(extension => !!getExtensionField(extension, 'renderText')).map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        editor,\n        type: getNodeType(extension.name, this.schema)\n      };\n      const renderText = getExtensionField(extension, 'renderText', context);\n\n      if (!renderText) {\n        return [];\n      }\n\n      const textSerializer = props => renderText(props);\n\n      return [extension.name, textSerializer];\n    }));\n  }\n\n}\n\nclass EventEmitter {\n  constructor() {\n    this.callbacks = {};\n  }\n\n  on(event, fn) {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [];\n    }\n\n    this.callbacks[event].push(fn);\n    return this;\n  }\n\n  emit(event, ...args) {\n    const callbacks = this.callbacks[event];\n\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args));\n    }\n\n    return this;\n  }\n\n  off(event, fn) {\n    const callbacks = this.callbacks[event];\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn);\n      } else {\n        delete this.callbacks[event];\n      }\n    }\n\n    return this;\n  }\n\n  removeAllListeners() {\n    this.callbacks = {};\n  }\n\n} // see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\n\n\nfunction getType(payload) {\n  return Object.prototype.toString.call(payload).slice(8, -1);\n}\n\nfunction isPlainObject(payload) {\n  if (getType(payload) !== 'Object') return false;\n  return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;\n}\n\nfunction mergeDeep(target, source) {\n  const output = { ...target\n  };\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, {\n            [key]: source[key]\n          });\n        } else {\n          output[key] = mergeDeep(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, {\n          [key]: source[key]\n        });\n      }\n    });\n  }\n\n  return output;\n}\n\nclass Extension {\n  constructor(config = {}) {\n    this.type = 'extension';\n    this.name = 'extension';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = { ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    this.options = this.config.defaultOptions;\n  }\n\n  static create(config = {}) {\n    return new Extension(config);\n  }\n\n  configure(options = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    return extension;\n  }\n\n  extend(extendedConfig = {}) {\n    const extension = new Extension(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    extension.options = extendedConfig.defaultOptions ? extendedConfig.defaultOptions : extension.parent.options;\n    return extension;\n  }\n\n}\n\nconst textBetween = (editor, from, to, blockSeparator, leafText) => {\n  let text = '';\n  let separated = true;\n  editor.state.doc.nodesBetween(from, to, (node, pos) => {\n    var _a;\n\n    const textSerializer = editor.extensionManager.textSerializers[node.type.name];\n\n    if (textSerializer) {\n      text += textSerializer({\n        node\n      });\n      separated = !blockSeparator;\n    } else if (node.isText) {\n      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);\n      separated = !blockSeparator;\n    } else if (node.isLeaf && leafText) {\n      text += leafText;\n      separated = !blockSeparator;\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator;\n      separated = true;\n    }\n  }, 0);\n  return text;\n};\n\nconst ClipboardTextSerializer = Extension.create({\n  name: 'editable',\n\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('clipboardTextSerializer'),\n      props: {\n        clipboardTextSerializer: () => {\n          const {\n            editor\n          } = this;\n          const {\n            from,\n            to\n          } = editor.state.selection;\n          return textBetween(editor, from, to, '\\n');\n        }\n      }\n    })];\n  }\n\n});\n\nconst blur = () => ({\n  view\n}) => {\n  const element = view.dom;\n  element.blur();\n  return true;\n};\n\nvar blur$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  blur: blur\n});\n\nconst clearContent = (emitUpdate = false) => ({\n  commands\n}) => {\n  return commands.setContent('', emitUpdate);\n};\n\nvar clearContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  clearContent: clearContent\n});\n\nconst clearNodes = () => ({\n  state,\n  tr,\n  dispatch\n}) => {\n  const {\n    selection\n  } = tr;\n  const {\n    ranges\n  } = selection;\n  ranges.forEach(range => {\n    state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return;\n      }\n\n      const $fromPos = tr.doc.resolve(tr.mapping.map(pos));\n      const $toPos = tr.doc.resolve(tr.mapping.map(pos + node.nodeSize));\n      const nodeRange = $fromPos.blockRange($toPos);\n\n      if (!nodeRange) {\n        return;\n      }\n\n      const targetLiftDepth = liftTarget(nodeRange);\n\n      if (node.type.isTextblock && dispatch) {\n        const {\n          defaultType\n        } = $fromPos.parent.contentMatchAt($fromPos.index());\n        tr.setNodeMarkup(nodeRange.start, defaultType);\n      }\n\n      if ((targetLiftDepth || targetLiftDepth === 0) && dispatch) {\n        tr.lift(nodeRange, targetLiftDepth);\n      }\n    });\n  });\n  return true;\n};\n\nvar clearNodes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  clearNodes: clearNodes\n});\n\nconst command = fn => props => {\n  return fn(props);\n};\n\nvar command$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  command: command\n});\n\nconst createParagraphNear = () => ({\n  state,\n  dispatch\n}) => {\n  return createParagraphNear$2(state, dispatch);\n};\n\nvar createParagraphNear$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createParagraphNear: createParagraphNear\n});\n\nconst deleteRange = range => ({\n  tr,\n  dispatch\n}) => {\n  const {\n    from,\n    to\n  } = range;\n\n  if (dispatch) {\n    tr.delete(from, to);\n  }\n\n  return true;\n};\n\nvar deleteRange$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  deleteRange: deleteRange\n});\n\nconst deleteSelection = () => ({\n  state,\n  dispatch\n}) => {\n  return deleteSelection$2(state, dispatch);\n};\n\nvar deleteSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  deleteSelection: deleteSelection\n});\n\nconst enter = () => ({\n  commands\n}) => {\n  return commands.keyboardShortcut('Enter');\n};\n\nvar enter$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  enter: enter\n});\n\nconst exitCode = () => ({\n  state,\n  dispatch\n}) => {\n  return exitCode$2(state, dispatch);\n};\n\nvar exitCode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  exitCode: exitCode\n});\n\nfunction findMarkInSet(marks, type, attributes = {}) {\n  return marks.find(item => {\n    return item.type === type && objectIncludes(item.attrs, attributes);\n  });\n}\n\nfunction isMarkInSet(marks, type, attributes = {}) {\n  return !!findMarkInSet(marks, type, attributes);\n}\n\nfunction getMarkRange($pos, type, attributes = {}) {\n  if (!$pos || !type) {\n    return;\n  }\n\n  const start = $pos.parent.childAfter($pos.parentOffset);\n\n  if (!start.node) {\n    return;\n  }\n\n  const mark = findMarkInSet(start.node.marks, type, attributes);\n\n  if (!mark) {\n    return;\n  }\n\n  let startIndex = $pos.index();\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n  findMarkInSet(start.node.marks, type, attributes);\n\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n\n  while (endIndex < $pos.parent.childCount && isMarkInSet($pos.parent.child(endIndex).marks, type, attributes)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\n\nconst extendMarkRange = (typeOrName, attributes = {}) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  const type = getMarkType(typeOrName, state.schema);\n  const {\n    doc,\n    selection\n  } = tr;\n  const {\n    $from,\n    from,\n    to\n  } = selection;\n\n  if (dispatch) {\n    const range = getMarkRange($from, type, attributes);\n\n    if (range && range.from <= from && range.to >= to) {\n      const newSelection = TextSelection.create(doc, range.from, range.to);\n      tr.setSelection(newSelection);\n    }\n  }\n\n  return true;\n};\n\nvar extendMarkRange$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  extendMarkRange: extendMarkRange\n});\n\nconst first = commands => props => {\n  const items = typeof commands === 'function' ? commands(props) : commands;\n\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar first$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  first: first\n});\n\nfunction minMax(value = 0, min = 0, max = 0) {\n  return Math.min(Math.max(value, min), max);\n}\n\nfunction isClass(item) {\n  var _a;\n\n  if (((_a = item.constructor) === null || _a === void 0 ? void 0 : _a.toString().substring(0, 5)) !== 'class') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item) && !isClass(item);\n}\n\nfunction isTextSelection(value) {\n  return isObject(value) && value instanceof TextSelection;\n}\n\nfunction resolveSelection(state, position = null) {\n  if (!position) {\n    return null;\n  }\n\n  if (position === 'start' || position === true) {\n    return {\n      from: 0,\n      to: 0\n    };\n  }\n\n  if (position === 'end') {\n    const {\n      size\n    } = state.doc.content;\n    return {\n      from: size,\n      to: size\n    };\n  }\n\n  return {\n    from: position,\n    to: position\n  };\n}\n\nconst focus = (position = null) => ({\n  editor,\n  view,\n  tr,\n  dispatch\n}) => {\n  if (view.hasFocus() && position === null || position === false) {\n    return true;\n  } // we donâ€™t try to resolve a NodeSelection or CellSelection\n\n\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    view.focus();\n    return true;\n  }\n\n  const {\n    from,\n    to\n  } = resolveSelection(editor.state, position) || editor.state.selection;\n  const {\n    doc,\n    storedMarks\n  } = tr;\n  const resolvedFrom = minMax(from, 0, doc.content.size);\n  const resolvedEnd = minMax(to, 0, doc.content.size);\n  const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd);\n  const isSameSelection = editor.state.selection.eq(selection);\n\n  if (dispatch) {\n    tr.setSelection(selection); // `tr.setSelection` resets the stored marks\n    // so weâ€™ll restore them if the selection is the same as before\n\n    if (isSameSelection && storedMarks) {\n      tr.setStoredMarks(storedMarks);\n    }\n\n    view.focus();\n  }\n\n  return true;\n};\n\nvar focus$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  focus: focus\n});\n\nconst insertContent = value => ({\n  tr,\n  commands\n}) => {\n  return commands.insertContentAt({\n    from: tr.selection.from,\n    to: tr.selection.to\n  }, value);\n};\n\nvar insertContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  insertContent: insertContent\n}); // source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  const last = tr.steps.length - 1;\n\n  if (last < startLen) {\n    return;\n  }\n\n  const step = tr.steps[last];\n\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return;\n  }\n\n  const map = tr.mapping.maps[last];\n  let end = 0;\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo;\n    }\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nconst insertContentAt = (position, value) => ({\n  tr,\n  dispatch,\n  editor\n}) => {\n  if (dispatch) {\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: {\n        preserveWhitespace: 'full'\n      }\n    }); // donâ€™t dispatch an empty fragment because this can lead to strange errors\n\n    if (content.toString() === '<>') {\n      return true;\n    }\n\n    const {\n      from,\n      to\n    } = typeof position === 'number' ? {\n      from: position,\n      to: position\n    } : position;\n    tr.replaceWith(from, to, content); // set cursor at end of inserted content\n\n    selectionToInsertionEnd(tr, tr.steps.length - 1, 1);\n  }\n\n  return true;\n};\n\nvar insertContentAt$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  insertContentAt: insertContentAt\n});\n\nconst joinBackward = () => ({\n  state,\n  dispatch\n}) => {\n  return joinBackward$2(state, dispatch);\n};\n\nvar joinBackward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  joinBackward: joinBackward\n});\n\nconst joinForward = () => ({\n  state,\n  dispatch\n}) => {\n  return joinForward$2(state, dispatch);\n};\n\nvar joinForward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  joinForward: joinForward\n});\nconst mac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;\n\nfunction normalizeKeyName(name) {\n  const parts = name.split(/-(?!$)/);\n  let result = parts[parts.length - 1];\n\n  if (result === 'Space') {\n    result = ' ';\n  }\n\n  let alt;\n  let ctrl;\n  let shift;\n  let meta;\n\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i];\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (mac) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`);\n    }\n  }\n\n  if (alt) {\n    result = `Alt-${result}`;\n  }\n\n  if (ctrl) {\n    result = `Ctrl-${result}`;\n  }\n\n  if (meta) {\n    result = `Meta-${result}`;\n  }\n\n  if (shift) {\n    result = `Shift-${result}`;\n  }\n\n  return result;\n}\n\nconst keyboardShortcut = name => ({\n  editor,\n  view,\n  tr,\n  dispatch\n}) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/);\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item));\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space' ? ' ' : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true\n  });\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event));\n  });\n  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(step => {\n    const newStep = step.map(tr.mapping);\n\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep);\n    }\n  });\n  return true;\n};\n\nvar keyboardShortcut$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  keyboardShortcut: keyboardShortcut\n});\n\nconst lift = (typeOrName, attributes = {}) => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive = isNodeActive(state, type, attributes);\n\n  if (!isActive) {\n    return false;\n  }\n\n  return lift$2(state, dispatch);\n};\n\nvar lift$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  lift: lift\n});\n\nconst liftEmptyBlock = () => ({\n  state,\n  dispatch\n}) => {\n  return liftEmptyBlock$2(state, dispatch);\n};\n\nvar liftEmptyBlock$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  liftEmptyBlock: liftEmptyBlock\n});\n\nconst liftListItem = typeOrName => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return liftListItem$2(type)(state, dispatch);\n};\n\nvar liftListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  liftListItem: liftListItem\n});\n\nconst newlineInCode = () => ({\n  state,\n  dispatch\n}) => {\n  return newlineInCode$2(state, dispatch);\n};\n\nvar newlineInCode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  newlineInCode: newlineInCode\n});\n\nconst replace = (typeOrName, attributes = {}) => ({\n  state,\n  commands\n}) => {\n  console.warn('[tiptap warn]: replace() is deprecated. please use insertContent() instead.');\n  const {\n    from,\n    to\n  } = state.selection;\n  const range = {\n    from,\n    to\n  };\n  return commands.replaceRange(range, typeOrName, attributes);\n};\n\nvar replace$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  replace: replace\n});\n\nconst replaceRange = (range, typeOrName, attributes = {}) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  console.warn('[tiptap warn]: replaceRange() is deprecated. please use insertContent() instead.');\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    from,\n    to\n  } = range; // const $from = tr.doc.resolve(from)\n  // const index = $from.index()\n  // if (!$from.parent.canReplaceWith(index, index, type)) {\n  //   return false\n  // }\n\n  if (dispatch) {\n    tr.replaceRangeWith(from, to, type.create(attributes));\n  }\n\n  return true;\n};\n\nvar replaceRange$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  replaceRange: replaceRange\n});\n/**\r\n * Remove a property or an array of properties from an object\r\n * @param obj Object\r\n * @param key Key to remove\r\n */\n\nfunction deleteProps(obj, propOrProps) {\n  const props = typeof propOrProps === 'string' ? [propOrProps] : propOrProps;\n  return Object.keys(obj).reduce((newObj, prop) => {\n    if (!props.includes(prop)) {\n      newObj[prop] = obj[prop];\n    }\n\n    return newObj;\n  }, {});\n}\n\nconst resetAttributes = (typeOrName, attributes) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n\n  if (!schemaType) {\n    return false;\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n            }\n          });\n        }\n      });\n    });\n  }\n\n  return true;\n};\n\nvar resetAttributes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  resetAttributes: resetAttributes\n});\n\nconst scrollIntoView = () => ({\n  tr,\n  dispatch\n}) => {\n  if (dispatch) {\n    tr.scrollIntoView();\n  }\n\n  return true;\n};\n\nvar scrollIntoView$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  scrollIntoView: scrollIntoView\n});\n\nconst selectAll = () => ({\n  state,\n  dispatch\n}) => {\n  return selectAll$2(state, dispatch);\n};\n\nvar selectAll$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectAll: selectAll\n});\n\nconst selectNodeBackward = () => ({\n  state,\n  dispatch\n}) => {\n  return selectNodeBackward$2(state, dispatch);\n};\n\nvar selectNodeBackward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectNodeBackward: selectNodeBackward\n});\n\nconst selectNodeForward = () => ({\n  state,\n  dispatch\n}) => {\n  return selectNodeForward$2(state, dispatch);\n};\n\nvar selectNodeForward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectNodeForward: selectNodeForward\n});\n\nconst selectParentNode = () => ({\n  state,\n  dispatch\n}) => {\n  return selectParentNode$2(state, dispatch);\n};\n\nvar selectParentNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectParentNode: selectParentNode\n});\n\nconst setContent = (content, emitUpdate = false, parseOptions = {}) => ({\n  tr,\n  editor,\n  dispatch\n}) => {\n  const {\n    doc\n  } = tr;\n  const document = createDocument(content, editor.schema, parseOptions);\n  const selection = TextSelection.create(doc, 0, doc.content.size);\n\n  if (dispatch) {\n    tr.setSelection(selection).replaceSelectionWith(document, false).setMeta('preventUpdate', !emitUpdate);\n  }\n\n  return true;\n};\n\nvar setContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setContent: setContent\n});\n\nconst setMark = (typeOrName, attributes = {}) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  const {\n    selection\n  } = tr;\n  const {\n    empty,\n    ranges\n  } = selection;\n  const type = getMarkType(typeOrName, state.schema);\n\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type);\n      tr.addStoredMark(type.create({ ...oldAttributes,\n        ...attributes\n      }));\n    } else {\n      ranges.forEach(range => {\n        const from = range.$from.pos;\n        const to = range.$to.pos;\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from);\n          const trimmedTo = Math.min(pos + node.nodeSize, to);\n          const someHasMark = node.marks.find(mark => mark.type === type); // if there is already a mark of this type\n          // we know that we have to merge its attributes\n          // otherwise we add a fresh new mark\n\n          if (someHasMark) {\n            node.marks.forEach(mark => {\n              if (type === mark.type) {\n                tr.addMark(trimmedFrom, trimmedTo, type.create({ ...mark.attrs,\n                  ...attributes\n                }));\n              }\n            });\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n          }\n        });\n      });\n    }\n  }\n\n  return true;\n};\n\nvar setMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setMark: setMark\n});\n\nconst setMeta = (key, value) => ({\n  tr\n}) => {\n  tr.setMeta(key, value);\n  return true;\n};\n\nvar setMeta$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setMeta: setMeta\n});\n\nconst setNode = (typeOrName, attributes = {}) => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return setBlockType(type, attributes)(state, dispatch);\n};\n\nvar setNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setNode: setNode\n});\n\nconst setNodeSelection = position => ({\n  tr,\n  dispatch\n}) => {\n  if (dispatch) {\n    const {\n      doc\n    } = tr;\n    const from = minMax(position, 0, doc.content.size);\n    const selection = NodeSelection.create(doc, from);\n    tr.setSelection(selection);\n  }\n\n  return true;\n};\n\nvar setNodeSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setNodeSelection: setNodeSelection\n});\n\nconst setTextSelection = position => ({\n  tr,\n  dispatch\n}) => {\n  if (dispatch) {\n    const {\n      doc\n    } = tr;\n    const {\n      from,\n      to\n    } = typeof position === 'number' ? {\n      from: position,\n      to: position\n    } : position;\n    const boundedFrom = minMax(from, 0, doc.content.size);\n    const boundedTo = minMax(to, 0, doc.content.size);\n    const selection = TextSelection.create(doc, boundedFrom, boundedTo);\n    tr.setSelection(selection);\n  }\n\n  return true;\n};\n\nvar setTextSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setTextSelection: setTextSelection\n});\n\nconst sinkListItem = typeOrName => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return sinkListItem$2(type)(state, dispatch);\n};\n\nvar sinkListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  sinkListItem: sinkListItem\n});\n\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {\n    const extensionAttribute = extensionAttributes.find(item => {\n      return item.type === typeName && item.name === name;\n    });\n\n    if (!extensionAttribute) {\n      return false;\n    }\n\n    return extensionAttribute.attribute.keepOnSplit;\n  }));\n}\n\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const {\n      type\n    } = match.edge(i);\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n\n  return null;\n}\n\nfunction ensureMarks(state, splittableMarks) {\n  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\n    state.tr.ensureMarks(filteredMarks);\n  }\n}\n\nconst splitBlock = ({\n  keepMarks = true\n} = {}) => ({\n  tr,\n  state,\n  dispatch,\n  editor\n}) => {\n  const {\n    selection,\n    doc\n  } = tr;\n  const {\n    $from,\n    $to\n  } = selection;\n  const extensionAttributes = editor.extensionManager.attributes;\n  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n\n  if (selection instanceof NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n      return false;\n    }\n\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks);\n      }\n\n      tr.split($from.pos).scrollIntoView();\n    }\n\n    return true;\n  }\n\n  if (!$from.parent.isBlock) {\n    return false;\n  }\n\n  if (dispatch) {\n    const atEnd = $to.parentOffset === $to.parent.content.size;\n\n    if (selection instanceof TextSelection) {\n      tr.deleteSelection();\n    }\n\n    const deflt = $from.depth === 0 ? undefined : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n    let types = atEnd && deflt ? [{\n      type: deflt,\n      attrs: newAttributes\n    }] : undefined;\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{\n      type: deflt\n    }] : undefined)) {\n      can = true;\n      types = deflt ? [{\n        type: deflt,\n        attrs: newAttributes\n      }] : undefined;\n    }\n\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types);\n\n      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n        const first = tr.mapping.map($from.before());\n        const $first = tr.doc.resolve(first);\n\n        if ($from.parent.canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n        }\n      }\n    }\n\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks);\n    }\n\n    tr.scrollIntoView();\n  }\n\n  return true;\n};\n\nvar splitBlock$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  splitBlock: splitBlock\n});\n\nconst splitListItem = typeOrName => ({\n  tr,\n  state,\n  dispatch,\n  editor\n}) => {\n  var _a;\n\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    $from,\n    $to\n  } = state.selection; // @ts-ignore\n  // eslint-disable-next-line\n\n  const node = state.selection.node;\n\n  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n    return false;\n  }\n\n  const grandParent = $from.node(-1);\n\n  if (grandParent.type !== type) {\n    return false;\n  }\n\n  const extensionAttributes = editor.extensionManager.attributes;\n\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n      return false;\n    }\n\n    if (dispatch) {\n      let wrap = Fragment.empty;\n      const keepItem = $from.index(-1) > 0; // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n\n      for (let d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap));\n      } // Add a second list item with an empty default start node\n\n\n      const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n      const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined));\n      tr.replace($from.before(keepItem ? undefined : -1), $from.after(-3), new Slice(wrap, keepItem ? 3 : 2, 2)).setSelection(TextSelection.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2)))).scrollIntoView();\n    }\n\n    return true;\n  }\n\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);\n  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n  tr.delete($from.pos, $to.pos);\n  const types = nextType ? [{\n    type,\n    attrs: newTypeAttributes\n  }, {\n    type: nextType,\n    attrs: newNextTypeAttributes\n  }] : [{\n    type,\n    attrs: newTypeAttributes\n  }];\n\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false;\n  }\n\n  if (dispatch) {\n    tr.split($from.pos, 2, types).scrollIntoView();\n  }\n\n  return true;\n};\n\nvar splitListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  splitListItem: splitListItem\n});\n\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i);\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n}\n\nfunction findParentNode(predicate) {\n  return selection => findParentNodeClosestToPos(selection.$from, predicate);\n}\n\nfunction isList(name, extensions) {\n  const {\n    nodeExtensions\n  } = splitExtensions(extensions);\n  const extension = nodeExtensions.find(item => item.name === name);\n\n  if (!extension) {\n    return false;\n  }\n\n  const context = {\n    name: extension.name,\n    options: extension.options\n  };\n  const group = callOrReturn(getExtensionField(extension, 'group', context));\n\n  if (typeof group !== 'string') {\n    return false;\n  }\n\n  return group.split(' ').includes('list');\n}\n\nconst toggleList = (listTypeOrName, itemTypeOrName) => ({\n  editor,\n  tr,\n  state,\n  dispatch,\n  chain,\n  commands,\n  can\n}) => {\n  const {\n    extensions\n  } = editor.extensionManager;\n  const listType = getNodeType(listTypeOrName, state.schema);\n  const itemType = getNodeType(itemTypeOrName, state.schema);\n  const {\n    selection\n  } = state;\n  const {\n    $from,\n    $to\n  } = selection;\n  const range = $from.blockRange($to);\n\n  if (!range) {\n    return false;\n  }\n\n  const parentList = findParentNode(node => isList(node.type.name, extensions))(selection);\n\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    // remove list\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType);\n    } // change list type\n\n\n    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n      tr.setNodeMarkup(parentList.pos, listType);\n      return true;\n    }\n  }\n\n  const canWrapInList = can().wrapInList(listType); // try to convert node to paragraph if needed\n\n  if (!canWrapInList) {\n    return chain().clearNodes().wrapInList(listType).run();\n  }\n\n  return commands.wrapInList(listType);\n};\n\nvar toggleList$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleList: toggleList\n});\n\nconst toggleMark = (typeOrName, attributes = {}) => ({\n  state,\n  commands\n}) => {\n  const type = getMarkType(typeOrName, state.schema);\n  const isActive = isMarkActive(state, type, attributes);\n\n  if (isActive) {\n    return commands.unsetMark(type);\n  }\n\n  return commands.setMark(type, attributes);\n};\n\nvar toggleMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleMark: toggleMark\n});\n\nconst toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({\n  state,\n  commands\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const toggleType = getNodeType(toggleTypeOrName, state.schema);\n  const isActive = isNodeActive(state, type, attributes);\n\n  if (isActive) {\n    return commands.setNode(toggleType);\n  }\n\n  return commands.setNode(type, attributes);\n};\n\nvar toggleNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleNode: toggleNode\n});\n\nconst toggleWrap = (typeOrName, attributes = {}) => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive = isNodeActive(state, type, attributes);\n\n  if (isActive) {\n    return lift$2(state, dispatch);\n  }\n\n  return wrapIn$2(type, attributes)(state, dispatch);\n};\n\nvar toggleWrap$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleWrap: toggleWrap\n});\n\nconst undoInputRule = () => ({\n  state,\n  dispatch\n}) => {\n  return undoInputRule$2(state, dispatch);\n};\n\nvar undoInputRule$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  undoInputRule: undoInputRule\n});\n\nconst unsetAllMarks = () => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  const {\n    selection\n  } = tr;\n  const {\n    empty,\n    ranges\n  } = selection;\n\n  if (empty) {\n    return true;\n  }\n\n  if (dispatch) {\n    Object.entries(state.schema.marks).forEach(([, mark]) => {\n      ranges.forEach(range => {\n        tr.removeMark(range.$from.pos, range.$to.pos, mark);\n      });\n    });\n  }\n\n  return true;\n};\n\nvar unsetAllMarks$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unsetAllMarks: unsetAllMarks\n});\n\nconst unsetMark = typeOrName => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  const {\n    selection\n  } = tr;\n  const type = getMarkType(typeOrName, state.schema);\n  const {\n    $from,\n    empty,\n    ranges\n  } = selection;\n\n  if (dispatch) {\n    if (empty) {\n      let {\n        from,\n        to\n      } = selection;\n      const range = getMarkRange($from, type);\n\n      if (range) {\n        from = range.from;\n        to = range.to;\n      }\n\n      tr.removeMark(from, to, type);\n    } else {\n      ranges.forEach(range => {\n        tr.removeMark(range.$from.pos, range.$to.pos, type);\n      });\n    }\n\n    tr.removeStoredMark(type);\n  }\n\n  return true;\n};\n\nvar unsetMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unsetMark: unsetMark\n});\n\nconst updateAttributes = (typeOrName, attributes = {}) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n\n  if (!schemaType) {\n    return false;\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      const from = range.$from.pos;\n      const to = range.$to.pos;\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, { ...node.attrs,\n            ...attributes\n          });\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              const trimmedFrom = Math.max(pos, from);\n              const trimmedTo = Math.min(pos + node.nodeSize, to);\n              tr.addMark(trimmedFrom, trimmedTo, markType.create({ ...mark.attrs,\n                ...attributes\n              }));\n            }\n          });\n        }\n      });\n    });\n  }\n\n  return true;\n};\n\nvar updateAttributes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  updateAttributes: updateAttributes\n});\n\nconst wrapIn = (typeOrName, attributes = {}) => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive = isNodeActive(state, type, attributes);\n\n  if (isActive) {\n    return false;\n  }\n\n  return wrapIn$2(type, attributes)(state, dispatch);\n};\n\nvar wrapIn$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  wrapIn: wrapIn\n});\n\nconst wrapInList = (typeOrName, attributes = {}) => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return wrapInList$2(type, attributes)(state, dispatch);\n};\n\nvar wrapInList$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  wrapInList: wrapInList\n});\nconst Commands = Extension.create({\n  name: 'commands',\n\n  addCommands() {\n    return { ...blur$1,\n      ...clearContent$1,\n      ...clearNodes$1,\n      ...command$1,\n      ...createParagraphNear$1,\n      ...deleteRange$1,\n      ...deleteSelection$1,\n      ...enter$1,\n      ...exitCode$1,\n      ...extendMarkRange$1,\n      ...first$1,\n      ...focus$1,\n      ...insertContent$1,\n      ...insertContentAt$1,\n      ...joinBackward$1,\n      ...joinForward$1,\n      ...keyboardShortcut$1,\n      ...lift$1,\n      ...liftEmptyBlock$1,\n      ...liftListItem$1,\n      ...newlineInCode$1,\n      ...replace$1,\n      ...replaceRange$1,\n      ...resetAttributes$1,\n      ...scrollIntoView$1,\n      ...selectAll$1,\n      ...selectNodeBackward$1,\n      ...selectNodeForward$1,\n      ...selectParentNode$1,\n      ...setContent$1,\n      ...setMark$1,\n      ...setMeta$1,\n      ...setNode$1,\n      ...setNodeSelection$1,\n      ...setTextSelection$1,\n      ...sinkListItem$1,\n      ...splitBlock$1,\n      ...splitListItem$1,\n      ...toggleList$1,\n      ...toggleMark$1,\n      ...toggleNode$1,\n      ...toggleWrap$1,\n      ...undoInputRule$1,\n      ...unsetAllMarks$1,\n      ...unsetMark$1,\n      ...updateAttributes$1,\n      ...wrapIn$1,\n      ...wrapInList$1\n    };\n  }\n\n});\nconst Editable = Extension.create({\n  name: 'editable',\n\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('editable'),\n      props: {\n        editable: () => this.editor.options.editable\n      }\n    })];\n  }\n\n});\nconst FocusEvents = Extension.create({\n  name: 'focusEvents',\n\n  addProseMirrorPlugins() {\n    const {\n      editor\n    } = this;\n    return [new Plugin({\n      key: new PluginKey('focusEvents'),\n      props: {\n        attributes: {\n          tabindex: '0'\n        },\n        handleDOMEvents: {\n          focus: (view, event) => {\n            editor.isFocused = true;\n            const transaction = editor.state.tr.setMeta('focus', {\n              event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          },\n          blur: (view, event) => {\n            editor.isFocused = false;\n            const transaction = editor.state.tr.setMeta('blur', {\n              event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          }\n        }\n      }\n    })];\n  }\n\n});\nconst Keymap = Extension.create({\n  name: 'keymap',\n\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({\n      commands\n    }) => [() => commands.undoInputRule(), () => commands.deleteSelection(), () => commands.joinBackward(), () => commands.selectNodeBackward()]);\n\n    const handleDelete = () => this.editor.commands.first(({\n      commands\n    }) => [() => commands.deleteSelection(), () => commands.joinForward(), () => commands.selectNodeForward()]);\n\n    return {\n      Enter: () => this.editor.commands.first(({\n        commands\n      }) => [() => commands.newlineInCode(), () => commands.createParagraphNear(), () => commands.liftEmptyBlock(), () => commands.splitBlock()]),\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: () => handleBackspace(),\n      'Mod-Backspace': () => handleBackspace(),\n      Delete: () => handleDelete(),\n      'Mod-Delete': () => handleDelete() // we donâ€™t need a custom `selectAll` for now\n      // 'Mod-a': () => this.editor.commands.selectAll(),\n\n    };\n  }\n\n});\nvar extensions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer: ClipboardTextSerializer,\n  Commands: Commands,\n  Editable: Editable,\n  FocusEvents: FocusEvents,\n  Keymap: Keymap\n});\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\n\nclass Editor extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.isFocused = false;\n    this.options = {\n      element: document.createElement('div'),\n      content: '',\n      injectCSS: true,\n      extensions: [],\n      autofocus: false,\n      editable: true,\n      editorProps: {},\n      parseOptions: {},\n      enableInputRules: true,\n      enablePasteRules: true,\n      onBeforeCreate: () => null,\n      onCreate: () => null,\n      onUpdate: () => null,\n      onSelectionUpdate: () => null,\n      onTransaction: () => null,\n      onFocus: () => null,\n      onBlur: () => null,\n      onDestroy: () => null\n    };\n    this.isCapturingTransaction = false;\n    this.capturedTransaction = null;\n    this.setOptions(options);\n    this.createExtensionManager();\n    this.createCommandManager();\n    this.createSchema();\n    this.on('beforeCreate', this.options.onBeforeCreate);\n    this.emit('beforeCreate', {\n      editor: this\n    });\n    this.createView();\n    this.injectCSS();\n    this.on('create', this.options.onCreate);\n    this.on('update', this.options.onUpdate);\n    this.on('selectionUpdate', this.options.onSelectionUpdate);\n    this.on('transaction', this.options.onTransaction);\n    this.on('focus', this.options.onFocus);\n    this.on('blur', this.options.onBlur);\n    this.on('destroy', this.options.onDestroy);\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return;\n      }\n\n      this.commands.focus(this.options.autofocus);\n      this.emit('create', {\n        editor: this\n      });\n    }, 0);\n  }\n  /**\r\n   * An object of all registered commands.\r\n   */\n\n\n  get commands() {\n    return this.commandManager.createCommands();\n  }\n  /**\r\n   * Create a command chain to call multiple commands at once.\r\n   */\n\n\n  chain() {\n    return this.commandManager.createChain();\n  }\n  /**\r\n   * Check if a command or a command chain can be executed. Without executing it.\r\n   */\n\n\n  can() {\n    return this.commandManager.createCan();\n  }\n  /**\r\n   * Inject CSS styles.\r\n   */\n\n\n  injectCSS() {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style);\n    }\n  }\n  /**\r\n   * Update editor options.\r\n   *\r\n   * @param options A list of options\r\n   */\n\n\n  setOptions(options = {}) {\n    this.options = { ...this.options,\n      ...options\n    };\n  }\n  /**\r\n   * Update editable state of the editor.\r\n   */\n\n\n  setEditable(editable) {\n    this.setOptions({\n      editable\n    });\n\n    if (this.view && this.state && !this.isDestroyed) {\n      this.view.updateState(this.state);\n    }\n  }\n  /**\r\n   * Returns whether the editor is editable.\r\n   */\n\n\n  get isEditable() {\n    return this.view && this.view.editable;\n  }\n  /**\r\n   * Returns the editor state.\r\n   */\n\n\n  get state() {\n    return this.view.state;\n  }\n  /**\r\n   * Register a ProseMirror plugin.\r\n   *\r\n   * @param plugin A ProseMirror plugin\r\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\r\n   */\n\n\n  registerPlugin(plugin, handlePlugins) {\n    const plugins = typeof handlePlugins === 'function' ? handlePlugins(plugin, this.state.plugins) : [...this.state.plugins, plugin];\n    const state = this.state.reconfigure({\n      plugins\n    });\n    this.view.updateState(state);\n  }\n  /**\r\n   * Unregister a ProseMirror plugin.\r\n   *\r\n   * @param name The plugins name\r\n   */\n\n\n  unregisterPlugin(nameOrPluginKey) {\n    if (this.isDestroyed) {\n      return;\n    }\n\n    const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` // @ts-ignore\n    : nameOrPluginKey.key;\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name))\n    });\n    this.view.updateState(state);\n  }\n  /**\r\n   * Creates an extension manager.\r\n   */\n\n\n  createExtensionManager() {\n    const coreExtensions = Object.entries(extensions).map(([, extension]) => extension);\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n    });\n    this.extensionManager = new ExtensionManager(allExtensions, this);\n  }\n  /**\r\n   * Creates an command manager.\r\n   */\n\n\n  createCommandManager() {\n    this.commandManager = new CommandManager(this, this.extensionManager.commands);\n  }\n  /**\r\n   * Creates a ProseMirror schema.\r\n   */\n\n\n  createSchema() {\n    this.schema = this.extensionManager.schema;\n  }\n  /**\r\n   * Creates a ProseMirror view.\r\n   */\n\n\n  createView() {\n    this.view = new EditorView(this.options.element, { ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc: createDocument(this.options.content, this.schema, this.options.parseOptions)\n      })\n    }); // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins\n    });\n    this.view.updateState(newState);\n    this.createNodeViews(); // Letâ€™s store the editor instance in the DOM element.\n    // So weâ€™ll have access to it for tests.\n\n    const dom = this.view.dom;\n    dom.editor = this;\n  }\n  /**\r\n   * Creates all node views.\r\n   */\n\n\n  createNodeViews() {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews\n    });\n  }\n\n  captureTransaction(fn) {\n    this.isCapturingTransaction = true;\n    fn();\n    this.isCapturingTransaction = false;\n    const tr = this.capturedTransaction;\n    this.capturedTransaction = null;\n    return tr;\n  }\n  /**\r\n   * The callback over which to send transactions (state updates) produced by the view.\r\n   *\r\n   * @param transaction An editor state transaction\r\n   */\n\n\n  dispatchTransaction(transaction) {\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction;\n        return;\n      }\n\n      transaction.steps.forEach(step => {\n        var _a;\n\n        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);\n      });\n      return;\n    }\n\n    const state = this.state.apply(transaction);\n    const selectionHasChanged = !this.state.selection.eq(state.selection);\n    this.view.updateState(state);\n    this.emit('transaction', {\n      editor: this,\n      transaction\n    });\n\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this\n      });\n    }\n\n    const focus = transaction.getMeta('focus');\n    const blur = transaction.getMeta('blur');\n\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event\n      });\n    }\n\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event\n      });\n    }\n\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return;\n    }\n\n    this.emit('update', {\n      editor: this,\n      transaction\n    });\n  }\n  /**\r\n   * Get attributes of the currently selected node or mark.\r\n   */\n\n\n  getAttributes(nameOrType) {\n    return getAttributes(this.state, nameOrType);\n  }\n  /**\r\n   * Get attributes of the currently selected node.\r\n   *\r\n   * @param name Name of the node\r\n   */\n\n\n  getNodeAttributes(name) {\n    console.warn('[tiptap warn]: editor.getNodeAttributes() is deprecated. please use editor.getAttributes() instead.');\n    return getNodeAttributes(this.state, name);\n  }\n  /**\r\n   * Get attributes of the currently selected mark.\r\n   *\r\n   * @param name Name of the mark\r\n   */\n\n\n  getMarkAttributes(name) {\n    console.warn('[tiptap warn]: editor.getMarkAttributes() is deprecated. please use editor.getAttributes() instead.');\n    return getMarkAttributes(this.state, name);\n  }\n\n  isActive(nameOrAttributes, attributesOrUndefined) {\n    const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null;\n    const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes;\n    return isActive(this.state, name, attributes);\n  }\n  /**\r\n   * Get the document as JSON.\r\n   */\n\n\n  getJSON() {\n    return this.state.doc.toJSON();\n  }\n  /**\r\n   * Get the document as HTML.\r\n   */\n\n\n  getHTML() {\n    return getHTMLFromFragment(this.state.doc, this.schema);\n  }\n  /**\r\n   * Check if there is no content.\r\n   */\n\n\n  get isEmpty() {\n    return isNodeEmpty(this.state.doc);\n  }\n  /**\r\n   * Get the number of characters for the current document.\r\n   */\n\n\n  getCharacterCount() {\n    return this.state.doc.content.size - 2;\n  }\n  /**\r\n   * Destroy the editor.\r\n   */\n\n\n  destroy() {\n    this.emit('destroy');\n\n    if (this.view) {\n      this.view.destroy();\n    }\n\n    this.removeAllListeners();\n    removeElement(this.css);\n  }\n  /**\r\n   * Check if the editor is already destroyed.\r\n   */\n\n\n  get isDestroyed() {\n    var _a; // @ts-ignore\n\n\n    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n  }\n\n}\n\nclass Node {\n  constructor(config = {}) {\n    this.type = 'node';\n    this.name = 'node';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = { ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    this.options = this.config.defaultOptions;\n  }\n\n  static create(config = {}) {\n    return new Node(config);\n  }\n\n  configure(options = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    return extension;\n  }\n\n  extend(extendedConfig = {}) {\n    const extension = new Node(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    extension.options = extendedConfig.defaultOptions ? extendedConfig.defaultOptions : extension.parent.options;\n    return extension;\n  }\n\n}\n\nclass Mark {\n  constructor(config = {}) {\n    this.type = 'mark';\n    this.name = 'mark';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = { ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n    this.options = this.config.defaultOptions;\n  }\n\n  static create(config = {}) {\n    return new Mark(config);\n  }\n\n  configure(options = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    return extension;\n  }\n\n  extend(extendedConfig = {}) {\n    const extension = new Mark(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    extension.options = extendedConfig.defaultOptions ? extendedConfig.defaultOptions : extension.parent.options;\n    return extension;\n  }\n\n}\n\nfunction isiOS() {\n  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform) // iPad on iOS 13 detection\n  || navigator.userAgent.includes('Mac') && 'ontouchend' in document;\n}\n\nclass NodeView {\n  constructor(component, props, options) {\n    this.isDragging = false;\n    this.options = {\n      stopEvent: null,\n      update: null\n    };\n    this.component = component;\n    this.options = { ...this.options,\n      ...options\n    };\n    this.editor = props.editor;\n    this.extension = props.extension;\n    this.node = props.node;\n    this.decorations = props.decorations;\n    this.getPos = props.getPos;\n    this.mount();\n  }\n\n  mount() {\n    // eslint-disable-next-line\n    return;\n  }\n\n  get dom() {\n    return null;\n  }\n\n  get contentDOM() {\n    return null;\n  }\n\n  onDragStart(event) {\n    var _a, _b, _c;\n\n    const {\n      view\n    } = this.editor;\n    const target = event.target; // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n\n    const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]') : target.closest('[data-drag-handle]');\n\n    if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n      return;\n    }\n\n    let x = 0;\n    let y = 0; // calculate offset for drag element if we use a different drag handle element\n\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect();\n      const handleBox = dragHandle.getBoundingClientRect();\n      x = handleBox.x - domBox.x + event.offsetX;\n      y = handleBox.y - domBox.y + event.offsetY;\n    }\n\n    (_c = event.dataTransfer) === null || _c === void 0 ? void 0 : _c.setDragImage(this.dom, x, y); // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n\n    const selection = NodeSelection.create(view.state.doc, this.getPos());\n    const transaction = view.state.tr.setSelection(selection);\n    view.dispatch(transaction);\n  }\n\n  stopEvent(event) {\n    var _a;\n\n    if (!this.dom) {\n      return false;\n    }\n\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent(event);\n    }\n\n    const target = event.target;\n    const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target)); // any event from child nodes should be handled by ProseMirror\n\n    if (!isInElement) {\n      return false;\n    }\n\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable; // any input event within node views should be ignored by ProseMirror\n\n    if (isInput) {\n      return true;\n    }\n\n    const {\n      isEditable\n    } = this.editor;\n    const {\n      isDragging\n    } = this;\n    const isDraggable = !!this.node.type.spec.draggable;\n    const isSelectable = NodeSelection.isSelectable(this.node);\n    const isCopyEvent = event.type === 'copy';\n    const isPasteEvent = event.type === 'paste';\n    const isCutEvent = event.type === 'cut';\n    const isClickEvent = event.type === 'mousedown';\n    const isDragEvent = event.type.startsWith('drag') || event.type === 'drop'; // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault();\n    }\n\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault();\n      return false;\n    } // we have to store that dragging started\n\n\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]');\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n\n      if (isValidDragHandle) {\n        this.isDragging = true;\n        document.addEventListener('dragend', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n        document.addEventListener('mouseup', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n      }\n    } // these events are handled by prosemirror\n\n\n    if (isDragging || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n      return false;\n    }\n\n    return true;\n  }\n\n  ignoreMutation(mutation) {\n    if (!this.dom || !this.contentDOM) {\n      return true;\n    } // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n\n\n    if (this.node.isLeaf) {\n      return true;\n    } // ProseMirror should handle any selections\n\n\n    if (mutation.type === 'selection') {\n      return false;\n    } // try to prevent a bug on iOS that will break node views on enter\n    // this is because ProseMirror canâ€™t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n\n\n    if (this.dom.contains(mutation.target) && mutation.type === 'childList' && isiOS()) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)]; // weâ€™ll check if every changed node is contentEditable\n      // to make sure itâ€™s probably mutated by ProseMirror\n\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false;\n      }\n    } // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n\n\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true;\n    } // ProseMirror should handle any changes within contentDOM\n\n\n    if (this.contentDOM.contains(mutation.target)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  updateAttributes(attributes) {\n    if (!this.editor.view.editable) {\n      return;\n    }\n\n    const {\n      state\n    } = this.editor.view;\n    const pos = this.getPos();\n    const transaction = state.tr.setNodeMarkup(pos, undefined, { ...this.node.attrs,\n      ...attributes\n    });\n    this.editor.view.dispatch(transaction);\n  }\n\n  deleteNode() {\n    const from = this.getPos();\n    const to = from + this.node.nodeSize;\n    this.editor.commands.deleteRange({\n      from,\n      to\n    });\n  }\n\n}\n\nfunction nodeInputRule(regexp, type, getAttributes) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    const attributes = getAttributes instanceof Function ? getAttributes(match) : getAttributes;\n    const {\n      tr\n    } = state;\n\n    if (match[0]) {\n      tr.replaceWith(start - 1, end, type.create(attributes));\n    }\n\n    return tr;\n  });\n}\n\nfunction getMarksBetween(from, to, state) {\n  let marks = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    marks = [...marks, ...node.marks.map(mark => ({\n      from: pos,\n      to: pos + node.nodeSize,\n      mark\n    }))];\n  });\n  return marks;\n}\n\nfunction markInputRule(regexp, markType, getAttributes) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    const attributes = getAttributes instanceof Function ? getAttributes(match) : getAttributes;\n    const {\n      tr\n    } = state;\n    const captureGroup = match[match.length - 1];\n    const fullMatch = match[0];\n    let markEnd = end;\n\n    if (captureGroup) {\n      const startSpaces = fullMatch.search(/\\S/);\n      const textStart = start + fullMatch.indexOf(captureGroup);\n      const textEnd = textStart + captureGroup.length;\n      const excludedMarks = getMarksBetween(start, end, state).filter(item => {\n        // TODO: PR to add excluded to MarkType\n        // @ts-ignore\n        const {\n          excluded\n        } = item.mark.type;\n        return excluded.find(type => type.name === markType.name);\n      }).filter(item => item.to > textStart);\n\n      if (excludedMarks.length) {\n        return null;\n      }\n\n      if (textEnd < end) {\n        tr.delete(textEnd, end);\n      }\n\n      if (textStart > start) {\n        tr.delete(start + startSpaces, textStart);\n      }\n\n      markEnd = start + startSpaces + captureGroup.length;\n      tr.addMark(start + startSpaces, markEnd, markType.create(attributes));\n      tr.removeStoredMark(markType);\n    }\n\n    return tr;\n  });\n}\n\nfunction markPasteRule(regexp, type, getAttributes) {\n  const handler = (fragment, parent) => {\n    const nodes = [];\n    fragment.forEach(child => {\n      if (child.isText && child.text) {\n        const {\n          text\n        } = child;\n        let pos = 0;\n        let match; // eslint-disable-next-line\n\n        while ((match = regexp.exec(text)) !== null) {\n          const outerMatch = Math.max(match.length - 2, 0);\n          const innerMatch = Math.max(match.length - 1, 0);\n\n          if (parent === null || parent === void 0 ? void 0 : parent.type.allowsMarkType(type)) {\n            const start = match.index;\n            const matchStart = start + match[0].indexOf(match[outerMatch]);\n            const matchEnd = matchStart + match[outerMatch].length;\n            const textStart = matchStart + match[outerMatch].lastIndexOf(match[innerMatch]);\n            const textEnd = textStart + match[innerMatch].length;\n            const attrs = getAttributes instanceof Function ? getAttributes(match) : getAttributes; // adding text before markdown to nodes\n\n            if (matchStart > 0) {\n              nodes.push(child.cut(pos, matchStart));\n            } // adding the markdown part to nodes\n\n\n            nodes.push(child.cut(textStart, textEnd).mark(type.create(attrs).addToSet(child.marks)));\n            pos = matchEnd;\n          }\n        } // adding rest of text to nodes\n\n\n        if (pos < text.length) {\n          nodes.push(child.cut(pos));\n        }\n      } else {\n        nodes.push(child.copy(handler(child.content, child)));\n      }\n    });\n    return Fragment.fromArray(nodes);\n  };\n\n  return new Plugin({\n    key: new PluginKey('markPasteRule'),\n    props: {\n      transformPasted: slice => {\n        return new Slice(handler(slice.content), slice.openStart, slice.openEnd);\n      }\n    }\n  });\n}\n\nfunction findChildren(node, predicate) {\n  const nodesWithPos = [];\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n/**\r\n * Same as `findChildren` but searches only within a `range`.\r\n */\n\n\nfunction findChildrenInRange(node, range, predicate) {\n  const nodesWithPos = []; // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\nfunction getSchema(extensions) {\n  const resolvedExtensions = ExtensionManager.resolve(extensions);\n  return getSchemaByResolvedExtensions(resolvedExtensions);\n}\n\nfunction generateHTML(doc, extensions) {\n  const schema = getSchema(extensions);\n  const contentNode = Node$1.fromJSON(schema, doc);\n  return getHTMLFromFragment(contentNode, schema);\n}\n\nfunction generateJSON(html, extensions) {\n  const schema = getSchema(extensions);\n  const dom = elementFromString(html);\n  return DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\n/**\r\n * Returns a node tree with node positions.\r\n */\n\n\nfunction getDebugJSON(node, startOffset = 0) {\n  const nodes = [];\n  node.forEach((n, offset) => {\n    const from = startOffset + offset;\n    const to = from + n.nodeSize;\n    const marks = n.marks.map(mark => ({\n      type: mark.type.name,\n      attrs: { ...mark.attrs\n      }\n    }));\n    const attrs = { ...n.attrs\n    };\n    const content = getDebugJSON(n, from + 1);\n    const output = {\n      type: n.type.name,\n      from,\n      to\n    };\n\n    if (Object.keys(attrs).length) {\n      output.attrs = attrs;\n    }\n\n    if (marks.length) {\n      output.marks = marks;\n    }\n\n    if (content.length) {\n      output.content = content;\n    }\n\n    if (n.text) {\n      output.text = n.text;\n    }\n\n    nodes.push(output);\n  });\n  return nodes;\n}\n\nfunction isNodeSelection(value) {\n  return isObject(value) && value instanceof NodeSelection;\n}\n\nfunction posToDOMRect(view, from, to) {\n  const start = view.coordsAtPos(from);\n  const end = view.coordsAtPos(to, -1);\n  const top = Math.min(start.top, end.top);\n  const bottom = Math.max(start.bottom, end.bottom);\n  const left = Math.min(start.left, end.left);\n  const right = Math.max(start.right, end.right);\n  const width = right - left;\n  const height = bottom - top;\n  const x = left;\n  const y = top;\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y\n  };\n  return { ...data,\n    toJSON: () => data\n  };\n}\n\nexport { Editor, Extension, Mark, Node, NodeView, callOrReturn, extensions, findChildren, findChildrenInRange, findParentNode, findParentNodeClosestToPos, generateHTML, generateJSON, getAttributes, getDebugJSON, getExtensionField, getHTMLFromFragment, getMarkAttributes, getMarkRange, getMarkType, getMarksBetween, getNodeAttributes, getNodeType, getSchema, isActive, isList, isMarkActive, isNodeActive, isNodeEmpty, isNodeSelection, isTextSelection, markInputRule, markPasteRule, mergeAttributes, nodeInputRule, posToDOMRect };","map":null,"metadata":{},"sourceType":"module"}