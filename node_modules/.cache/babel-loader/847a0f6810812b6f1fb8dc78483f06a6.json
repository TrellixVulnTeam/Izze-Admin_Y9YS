{"ast":null,"code":"import _assertThisInitialized from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _objectSpread from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"D:/Pyramidion/WebApp/Izze-Admin/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { Plugin, PluginKey, TextSelection, Selection, NodeSelection, EditorState } from 'prosemirror-state';\nimport { EditorView } from 'prosemirror-view';\nimport { Fragment, DOMParser, DOMSerializer, Schema, Slice, Node as Node$1 } from 'prosemirror-model';\nimport { keymap } from 'prosemirror-keymap';\nimport { inputRules, undoInputRule as undoInputRule$2, InputRule } from 'prosemirror-inputrules';\nimport { liftTarget, ReplaceStep, ReplaceAroundStep, canSplit } from 'prosemirror-transform';\nimport { createParagraphNear as createParagraphNear$2, deleteSelection as deleteSelection$2, exitCode as exitCode$2, joinBackward as joinBackward$2, joinForward as joinForward$2, lift as lift$2, liftEmptyBlock as liftEmptyBlock$2, newlineInCode as newlineInCode$2, selectAll as selectAll$2, selectNodeBackward as selectNodeBackward$2, selectNodeForward as selectNodeForward$2, selectParentNode as selectParentNode$2, setBlockType, wrapIn as wrapIn$2 } from 'prosemirror-commands';\nimport { liftListItem as liftListItem$2, sinkListItem as sinkListItem$2, wrapInList as wrapInList$2 } from 'prosemirror-schema-list';\n\nfunction getSchemaTypeNameByName(name, schema) {\n  if (schema.nodes[name]) {\n    return 'node';\n  }\n\n  if (schema.marks[name]) {\n    return 'mark';\n  }\n\n  return null;\n}\n\nfunction getNodeType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(\"There is no node type named '\".concat(nameOrType, \"'. Maybe you forgot to add the extension?\"));\n    }\n\n    return schema.nodes[nameOrType];\n  }\n\n  return nameOrType;\n}\n\nfunction _getNodeAttributes(state, typeOrName) {\n  var type = getNodeType(typeOrName, state.schema);\n  var _state$selection = state.selection,\n      from = _state$selection.from,\n      to = _state$selection.to;\n  var nodes = [];\n  state.doc.nodesBetween(from, to, function (node) {\n    nodes = [].concat(_toConsumableArray(nodes), [node]);\n  });\n  var node = nodes.reverse().find(function (nodeItem) {\n    return nodeItem.type.name === type.name;\n  });\n\n  if (node) {\n    return _objectSpread({}, node.attrs);\n  }\n\n  return {};\n}\n\nfunction getMarkType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(\"There is no mark type named '\".concat(nameOrType, \"'. Maybe you forgot to add the extension?\"));\n    }\n\n    return schema.marks[nameOrType];\n  }\n\n  return nameOrType;\n}\n\nfunction _getMarkAttributes(state, typeOrName) {\n  var type = getMarkType(typeOrName, state.schema);\n  var _state$selection2 = state.selection,\n      from = _state$selection2.from,\n      to = _state$selection2.to,\n      empty = _state$selection2.empty;\n  var marks = [];\n\n  if (empty) {\n    marks = state.selection.$head.marks();\n  } else {\n    state.doc.nodesBetween(from, to, function (node) {\n      marks = [].concat(_toConsumableArray(marks), _toConsumableArray(node.marks));\n    });\n  }\n\n  var mark = marks.find(function (markItem) {\n    return markItem.type.name === type.name;\n  });\n\n  if (mark) {\n    return _objectSpread({}, mark.attrs);\n  }\n\n  return {};\n}\n\nfunction _getAttributes(state, typeOrName) {\n  var schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n\n  if (schemaType === 'node') {\n    return _getNodeAttributes(state, typeOrName);\n  }\n\n  if (schemaType === 'mark') {\n    return _getMarkAttributes(state, typeOrName);\n  }\n\n  return {};\n}\n/**\r\n * Check if object1 includes object2\r\n * @param object1 Object\r\n * @param object2 Object\r\n */\n\n\nfunction objectIncludes(object1, object2) {\n  var keys = Object.keys(object2);\n\n  if (!keys.length) {\n    return true;\n  }\n\n  return !!keys.filter(function (key) {\n    return object2[key] === object1[key];\n  }).length;\n}\n\nfunction isNodeActive(state, typeOrName) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _state$selection3 = state.selection,\n      from = _state$selection3.from,\n      to = _state$selection3.to,\n      empty = _state$selection3.empty;\n  var type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n  var nodeRanges = [];\n  state.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isText) {\n      var relativeFrom = Math.max(from, pos);\n      var relativeTo = Math.min(to, pos + node.nodeSize);\n      nodeRanges = [].concat(_toConsumableArray(nodeRanges), [{\n        node: node,\n        from: relativeFrom,\n        to: relativeTo\n      }]);\n    }\n  });\n\n  if (empty) {\n    return !!nodeRanges.filter(function (nodeRange) {\n      if (!type) {\n        return true;\n      }\n\n      return type.name === nodeRange.node.type.name;\n    }).find(function (nodeRange) {\n      return objectIncludes(nodeRange.node.attrs, attributes);\n    });\n  }\n\n  var selectionRange = to - from;\n  var range = nodeRanges.filter(function (nodeRange) {\n    if (!type) {\n      return true;\n    }\n\n    return type.name === nodeRange.node.type.name;\n  }).filter(function (nodeRange) {\n    return objectIncludes(nodeRange.node.attrs, attributes);\n  }).reduce(function (sum, nodeRange) {\n    var size = nodeRange.to - nodeRange.from;\n    return sum + size;\n  }, 0);\n  return range >= selectionRange;\n}\n\nfunction isMarkActive(state, typeOrName) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _state$selection4 = state.selection,\n      from = _state$selection4.from,\n      to = _state$selection4.to,\n      empty = _state$selection4.empty;\n  var type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks()).filter(function (mark) {\n      if (!type) {\n        return true;\n      }\n\n      return type.name === mark.type.name;\n    }).find(function (mark) {\n      return objectIncludes(mark.attrs, attributes);\n    });\n  }\n\n  var selectionRange = 0;\n  var markRanges = [];\n  state.doc.nodesBetween(from, to, function (node, pos) {\n    if (node.isText) {\n      var relativeFrom = Math.max(from, pos);\n      var relativeTo = Math.min(to, pos + node.nodeSize);\n\n      var _range = relativeTo - relativeFrom;\n\n      selectionRange += _range;\n      markRanges = [].concat(_toConsumableArray(markRanges), _toConsumableArray(node.marks.map(function (mark) {\n        return {\n          mark: mark,\n          from: relativeFrom,\n          to: relativeTo\n        };\n      })));\n    }\n  });\n\n  if (selectionRange === 0) {\n    return false;\n  } // calculate range of matched mark\n\n\n  var matchedRange = markRanges.filter(function (markRange) {\n    if (!type) {\n      return true;\n    }\n\n    return type.name === markRange.mark.type.name;\n  }).filter(function (markRange) {\n    return objectIncludes(markRange.mark.attrs, attributes);\n  }).reduce(function (sum, markRange) {\n    var size = markRange.to - markRange.from;\n    return sum + size;\n  }, 0); // calculate range of marks that excludes the searched mark\n  // for example `code` doesnâ€™t allow any other marks\n\n  var excludedRange = markRanges.filter(function (markRange) {\n    if (!type) {\n      return true;\n    }\n\n    return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n  }).reduce(function (sum, markRange) {\n    var size = markRange.to - markRange.from;\n    return sum + size;\n  }, 0); // we only include the result of `excludedRange`\n  // if there is a match at all\n\n  var range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n  return range >= selectionRange;\n}\n\nfunction _isActive(state, name) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n  }\n\n  var schemaType = getSchemaTypeNameByName(name, state.schema);\n\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes);\n  }\n\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes);\n  }\n\n  return false;\n}\n\nfunction removeElement(element) {\n  if (element && element.parentNode) {\n    element.parentNode.removeChild(element);\n  }\n}\n\nfunction elementFromString(value) {\n  // add a wrapper to preserve leading and trailing whitespace\n  var wrappedValue = \"<body>\".concat(value, \"</body>\");\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;\n}\n\nfunction createNodeFromContent(content, schema, options) {\n  options = _objectSpread({\n    slice: true,\n    parseOptions: {}\n  }, options);\n\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content)) {\n        return Fragment.fromArray(content.map(function (item) {\n          return schema.nodeFromJSON(item);\n        }));\n      }\n\n      return schema.nodeFromJSON(content);\n    } catch (error) {\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);\n      return createNodeFromContent('', schema, options);\n    }\n  }\n\n  if (typeof content === 'string') {\n    var parser = DOMParser.fromSchema(schema);\n    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);\n  }\n\n  return createNodeFromContent('', schema, options);\n}\n\nfunction createDocument(content, schema) {\n  var parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return createNodeFromContent(content, schema, {\n    slice: false,\n    parseOptions: parseOptions\n  });\n}\n\nfunction getHTMLFromFragment(doc, schema) {\n  var fragment = DOMSerializer.fromSchema(schema).serializeFragment(doc.content);\n  var temporaryDocument = document.implementation.createHTMLDocument();\n  var container = temporaryDocument.createElement('div');\n  container.appendChild(fragment);\n  return container.innerHTML;\n}\n\nfunction isNodeEmpty(node) {\n  var _a;\n\n  var defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();\n  var content = node.toJSON();\n  return JSON.stringify(defaultContent) === JSON.stringify(content);\n}\n\nfunction createStyleTag(style) {\n  var tipTapStyleTag = document.querySelector('style[data-tiptap-style]');\n\n  if (tipTapStyleTag !== null) {\n    return tipTapStyleTag;\n  }\n\n  var styleNode = document.createElement('style');\n  styleNode.setAttribute('data-tiptap-style', '');\n  styleNode.innerHTML = style;\n  document.getElementsByTagName('head')[0].appendChild(styleNode);\n  return styleNode;\n}\n\nvar CommandManager = /*#__PURE__*/function () {\n  function CommandManager(editor, commands) {\n    _classCallCheck(this, CommandManager);\n\n    this.editor = editor;\n    this.commands = commands;\n  }\n\n  _createClass(CommandManager, [{\n    key: \"createCommands\",\n    value: function createCommands() {\n      var commands = this.commands,\n          editor = this.editor;\n      var state = editor.state,\n          view = editor.view;\n      var tr = state.tr;\n      var props = this.buildProps(tr);\n      return Object.fromEntries(Object.entries(commands).map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            name = _ref2[0],\n            command = _ref2[1];\n\n        var method = function method() {\n          var callback = command.apply(void 0, arguments)(props);\n\n          if (!tr.getMeta('preventDispatch')) {\n            view.dispatch(tr);\n          }\n\n          return callback;\n        };\n\n        return [name, method];\n      }));\n    }\n  }, {\n    key: \"createChain\",\n    value: function createChain(startTr) {\n      var _this = this;\n\n      var shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var commands = this.commands,\n          editor = this.editor;\n      var state = editor.state,\n          view = editor.view;\n      var callbacks = [];\n      var hasStartTransaction = !!startTr;\n      var tr = startTr || state.tr;\n\n      var run = function run() {\n        if (!hasStartTransaction && shouldDispatch && !tr.getMeta('preventDispatch')) {\n          view.dispatch(tr);\n        }\n\n        return callbacks.every(function (callback) {\n          return callback === true;\n        });\n      };\n\n      var chain = _objectSpread(_objectSpread({}, Object.fromEntries(Object.entries(commands).map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            name = _ref4[0],\n            command = _ref4[1];\n\n        var chainedCommand = function chainedCommand() {\n          var props = _this.buildProps(tr, shouldDispatch);\n\n          var callback = command.apply(void 0, arguments)(props);\n          callbacks.push(callback);\n          return chain;\n        };\n\n        return [name, chainedCommand];\n      }))), {}, {\n        run: run\n      });\n\n      return chain;\n    }\n  }, {\n    key: \"createCan\",\n    value: function createCan(startTr) {\n      var _this2 = this;\n\n      var commands = this.commands,\n          editor = this.editor;\n      var state = editor.state;\n      var dispatch = undefined;\n      var tr = startTr || state.tr;\n      var props = this.buildProps(tr, dispatch);\n      var formattedCommands = Object.fromEntries(Object.entries(commands).map(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            name = _ref6[0],\n            command = _ref6[1];\n\n        return [name, function () {\n          return command.apply(void 0, arguments)(_objectSpread(_objectSpread({}, props), {}, {\n            dispatch: dispatch\n          }));\n        }];\n      }));\n      return _objectSpread(_objectSpread({}, formattedCommands), {}, {\n        chain: function chain() {\n          return _this2.createChain(tr, dispatch);\n        }\n      });\n    }\n  }, {\n    key: \"buildProps\",\n    value: function buildProps(tr) {\n      var _this3 = this;\n\n      var shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var editor = this.editor,\n          commands = this.commands;\n      var state = editor.state,\n          view = editor.view;\n\n      if (state.storedMarks) {\n        tr.setStoredMarks(state.storedMarks);\n      }\n\n      var props = {\n        tr: tr,\n        editor: editor,\n        view: view,\n        state: this.chainableState(tr, state),\n        dispatch: shouldDispatch ? function () {\n          return undefined;\n        } : undefined,\n        chain: function chain() {\n          return _this3.createChain(tr);\n        },\n        can: function can() {\n          return _this3.createCan(tr);\n        },\n\n        get commands() {\n          return Object.fromEntries(Object.entries(commands).map(function (_ref7) {\n            var _ref8 = _slicedToArray(_ref7, 2),\n                name = _ref8[0],\n                command = _ref8[1];\n\n            return [name, function () {\n              return command.apply(void 0, arguments)(props);\n            }];\n          }));\n        }\n\n      };\n      return props;\n    }\n  }, {\n    key: \"chainableState\",\n    value: function chainableState(tr, state) {\n      var selection = tr.selection;\n      var doc = tr.doc;\n      var storedMarks = tr.storedMarks;\n      return _objectSpread(_objectSpread({}, state), {}, {\n        schema: state.schema,\n        plugins: state.plugins,\n        apply: state.apply.bind(state),\n        applyTransaction: state.applyTransaction.bind(state),\n        reconfigure: state.reconfigure.bind(state),\n        toJSON: state.toJSON.bind(state),\n\n        get storedMarks() {\n          return storedMarks;\n        },\n\n        get selection() {\n          return selection;\n        },\n\n        get doc() {\n          return doc;\n        },\n\n        get tr() {\n          selection = tr.selection;\n          doc = tr.doc;\n          storedMarks = tr.storedMarks;\n          return tr;\n        }\n\n      });\n    }\n  }]);\n\n  return CommandManager;\n}();\n\nfunction getExtensionField(extension, field) {\n  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context);\n  }\n\n  if (typeof extension.config[field] === 'function') {\n    var value = extension.config[field].bind(_objectSpread(_objectSpread({}, context), {}, {\n      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n    }));\n    return value;\n  }\n\n  return extension.config[field];\n}\n\nfunction splitExtensions(extensions) {\n  var baseExtensions = extensions.filter(function (extension) {\n    return extension.type === 'extension';\n  });\n  var nodeExtensions = extensions.filter(function (extension) {\n    return extension.type === 'node';\n  });\n  var markExtensions = extensions.filter(function (extension) {\n    return extension.type === 'mark';\n  });\n  return {\n    baseExtensions: baseExtensions,\n    nodeExtensions: nodeExtensions,\n    markExtensions: markExtensions\n  };\n}\n/**\r\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\r\n * @param extensions List of extensions\r\n */\n\n\nfunction getAttributesFromExtensions(extensions) {\n  var extensionAttributes = [];\n\n  var _splitExtensions = splitExtensions(extensions),\n      nodeExtensions = _splitExtensions.nodeExtensions,\n      markExtensions = _splitExtensions.markExtensions;\n\n  var nodeAndMarkExtensions = [].concat(_toConsumableArray(nodeExtensions), _toConsumableArray(markExtensions));\n  var defaultAttribute = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true\n  };\n  extensions.forEach(function (extension) {\n    var context = {\n      name: extension.name,\n      options: extension.options\n    };\n    var addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);\n\n    if (!addGlobalAttributes) {\n      return;\n    } // TODO: remove `as GlobalAttributes`\n\n\n    var globalAttributes = addGlobalAttributes();\n    globalAttributes.forEach(function (globalAttribute) {\n      globalAttribute.types.forEach(function (type) {\n        Object.entries(globalAttribute.attributes).forEach(function (_ref9) {\n          var _ref10 = _slicedToArray(_ref9, 2),\n              name = _ref10[0],\n              attribute = _ref10[1];\n\n          extensionAttributes.push({\n            type: type,\n            name: name,\n            attribute: _objectSpread(_objectSpread({}, defaultAttribute), attribute)\n          });\n        });\n      });\n    });\n  });\n  nodeAndMarkExtensions.forEach(function (extension) {\n    var context = {\n      name: extension.name,\n      options: extension.options\n    };\n    var addAttributes = getExtensionField(extension, 'addAttributes', context);\n\n    if (!addAttributes) {\n      return;\n    } // TODO: remove `as Attributes`\n\n\n    var attributes = addAttributes();\n    Object.entries(attributes).forEach(function (_ref11) {\n      var _ref12 = _slicedToArray(_ref11, 2),\n          name = _ref12[0],\n          attribute = _ref12[1];\n\n      extensionAttributes.push({\n        type: extension.name,\n        name: name,\n        attribute: _objectSpread(_objectSpread({}, defaultAttribute), attribute)\n      });\n    });\n  });\n  return extensionAttributes;\n}\n\nfunction mergeAttributes() {\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  return objects.filter(function (item) {\n    return !!item;\n  }).reduce(function (items, item) {\n    var mergedAttributes = _objectSpread({}, items);\n\n    Object.entries(item).forEach(function (_ref13) {\n      var _ref14 = _slicedToArray(_ref13, 2),\n          key = _ref14[0],\n          value = _ref14[1];\n\n      var exists = mergedAttributes[key];\n\n      if (!exists) {\n        mergedAttributes[key] = value;\n        return;\n      }\n\n      if (key === 'class') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join(' ');\n      } else if (key === 'style') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join('; ');\n      } else {\n        mergedAttributes[key] = value;\n      }\n    });\n    return mergedAttributes;\n  }, {});\n}\n\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n  return extensionAttributes.filter(function (item) {\n    return item.attribute.rendered;\n  }).map(function (item) {\n    if (!item.attribute.renderHTML) {\n      return _defineProperty({}, item.name, nodeOrMark.attrs[item.name]);\n    }\n\n    return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n  }).reduce(function (attributes, attribute) {\n    return mergeAttributes(attributes, attribute);\n  }, {});\n}\n\nfunction isEmptyObject() {\n  var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return Object.keys(object).length === 0 && object.constructor === Object;\n}\n\nfunction fromString(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  if (value.match(/^\\d*(\\.\\d+)?$/)) {\n    return Number(value);\n  }\n\n  if (value === 'true') {\n    return true;\n  }\n\n  if (value === 'false') {\n    return false;\n  }\n\n  return value;\n}\n/**\r\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\r\n * Cancels when `getAttrs` returned `false`.\r\n * @param parseRule ProseMirror ParseRule\r\n * @param extensionAttributes List of attributes to inject\r\n */\n\n\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n  if (parseRule.style) {\n    return parseRule;\n  }\n\n  return _objectSpread(_objectSpread({}, parseRule), {}, {\n    getAttrs: function getAttrs(node) {\n      var oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n\n      if (oldAttributes === false) {\n        return false;\n      }\n\n      var newAttributes = extensionAttributes.filter(function (item) {\n        return item.attribute.rendered;\n      }).reduce(function (items, item) {\n        var attributes = item.attribute.parseHTML ? item.attribute.parseHTML(node) || {} : _defineProperty({}, item.name, fromString(node.getAttribute(item.name)));\n        var filteredAttributes = Object.fromEntries(Object.entries(attributes).filter(function (_ref17) {\n          var _ref18 = _slicedToArray(_ref17, 2),\n              value = _ref18[1];\n\n          return value !== undefined && value !== null;\n        }));\n        return _objectSpread(_objectSpread({}, items), filteredAttributes);\n      }, {});\n      return _objectSpread(_objectSpread({}, oldAttributes), newAttributes);\n    }\n  });\n}\n/**\r\n * Optionally calls `value` as a function.\r\n * Otherwise it is returned directly.\r\n * @param value Function or any value.\r\n * @param context Optional context to bind to function.\r\n * @param props Optional props to pass to function.\r\n */\n\n\nfunction callOrReturn(value) {\n  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n  if (typeof value === 'function') {\n    for (var _len2 = arguments.length, props = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      props[_key2 - 2] = arguments[_key2];\n    }\n\n    if (context) {\n      return value.bind(context).apply(void 0, props);\n    }\n\n    return value.apply(void 0, props);\n  }\n\n  return value;\n}\n\nfunction cleanUpSchemaItem(data) {\n  return Object.fromEntries(Object.entries(data).filter(function (_ref19) {\n    var _ref20 = _slicedToArray(_ref19, 2),\n        key = _ref20[0],\n        value = _ref20[1];\n\n    if (key === 'attrs' && isEmptyObject(value)) {\n      return false;\n    }\n\n    return value !== null && value !== undefined;\n  }));\n}\n\nfunction getSchemaByResolvedExtensions(extensions) {\n  var _a;\n\n  var allAttributes = getAttributesFromExtensions(extensions);\n\n  var _splitExtensions2 = splitExtensions(extensions),\n      nodeExtensions = _splitExtensions2.nodeExtensions,\n      markExtensions = _splitExtensions2.markExtensions;\n\n  var topNode = (_a = nodeExtensions.find(function (extension) {\n    return getExtensionField(extension, 'topNode');\n  })) === null || _a === void 0 ? void 0 : _a.name;\n  var nodes = Object.fromEntries(nodeExtensions.map(function (extension) {\n    var extensionAttributes = allAttributes.filter(function (attribute) {\n      return attribute.type === extension.name;\n    });\n    var context = {\n      name: extension.name,\n      options: extension.options\n    };\n    var extraNodeFields = extensions.reduce(function (fields, e) {\n      var extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);\n      return _objectSpread(_objectSpread({}, fields), extendNodeSchema ? extendNodeSchema(extension) : {});\n    }, {});\n    var schema = cleanUpSchemaItem(_objectSpread(_objectSpread({}, extraNodeFields), {}, {\n      content: callOrReturn(getExtensionField(extension, 'content', context)),\n      marks: callOrReturn(getExtensionField(extension, 'marks', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      inline: callOrReturn(getExtensionField(extension, 'inline', context)),\n      atom: callOrReturn(getExtensionField(extension, 'atom', context)),\n      selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),\n      draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      defining: callOrReturn(getExtensionField(extension, 'defining', context)),\n      isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(function (extensionAttribute) {\n        var _a;\n\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    }));\n    var parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(function (parseRule) {\n        return injectExtensionAttributesToParseRule(parseRule, extensionAttributes);\n      });\n    }\n\n    var renderHTML = getExtensionField(extension, 'renderHTML', context);\n\n    if (renderHTML) {\n      schema.toDOM = function (node) {\n        return renderHTML({\n          node: node,\n          HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n        });\n      };\n    }\n\n    return [extension.name, schema];\n  }));\n  var marks = Object.fromEntries(markExtensions.map(function (extension) {\n    var extensionAttributes = allAttributes.filter(function (attribute) {\n      return attribute.type === extension.name;\n    });\n    var context = {\n      name: extension.name,\n      options: extension.options\n    };\n    var extraMarkFields = extensions.reduce(function (fields, e) {\n      var extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);\n      return _objectSpread(_objectSpread({}, fields), extendMarkSchema ? extendMarkSchema(extension) : {});\n    }, {});\n    var schema = cleanUpSchemaItem(_objectSpread(_objectSpread({}, extraMarkFields), {}, {\n      inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),\n      excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(function (extensionAttribute) {\n        var _a;\n\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    }));\n    var parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(function (parseRule) {\n        return injectExtensionAttributesToParseRule(parseRule, extensionAttributes);\n      });\n    }\n\n    var renderHTML = getExtensionField(extension, 'renderHTML', context);\n\n    if (renderHTML) {\n      schema.toDOM = function (mark) {\n        return renderHTML({\n          mark: mark,\n          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n        });\n      };\n    }\n\n    return [extension.name, schema];\n  }));\n  return new Schema({\n    topNode: topNode,\n    nodes: nodes,\n    marks: marks\n  });\n}\n\nfunction getSchemaTypeByName(name, schema) {\n  if (schema.nodes[name]) {\n    return schema.nodes[name];\n  }\n\n  if (schema.marks[name]) {\n    return schema.marks[name];\n  }\n\n  return null;\n}\n\nvar ExtensionManager = /*#__PURE__*/function () {\n  function ExtensionManager(extensions, editor) {\n    var _this4 = this;\n\n    _classCallCheck(this, ExtensionManager);\n\n    this.splittableMarks = [];\n    this.editor = editor;\n    this.extensions = ExtensionManager.resolve(extensions);\n    this.schema = getSchemaByResolvedExtensions(this.extensions);\n    this.extensions.forEach(function (extension) {\n      var _a;\n\n      var context = {\n        name: extension.name,\n        options: extension.options,\n        editor: _this4.editor,\n        type: getSchemaTypeByName(extension.name, _this4.schema)\n      };\n\n      if (extension.type === 'mark') {\n        var keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;\n\n        if (keepOnSplit) {\n          _this4.splittableMarks.push(extension.name);\n        }\n      }\n\n      var onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);\n\n      if (onBeforeCreate) {\n        _this4.editor.on('beforeCreate', onBeforeCreate);\n      }\n\n      var onCreate = getExtensionField(extension, 'onCreate', context);\n\n      if (onCreate) {\n        _this4.editor.on('create', onCreate);\n      }\n\n      var onUpdate = getExtensionField(extension, 'onUpdate', context);\n\n      if (onUpdate) {\n        _this4.editor.on('update', onUpdate);\n      }\n\n      var onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);\n\n      if (onSelectionUpdate) {\n        _this4.editor.on('selectionUpdate', onSelectionUpdate);\n      }\n\n      var onTransaction = getExtensionField(extension, 'onTransaction', context);\n\n      if (onTransaction) {\n        _this4.editor.on('transaction', onTransaction);\n      }\n\n      var onFocus = getExtensionField(extension, 'onFocus', context);\n\n      if (onFocus) {\n        _this4.editor.on('focus', onFocus);\n      }\n\n      var onBlur = getExtensionField(extension, 'onBlur', context);\n\n      if (onBlur) {\n        _this4.editor.on('blur', onBlur);\n      }\n\n      var onDestroy = getExtensionField(extension, 'onDestroy', context);\n\n      if (onDestroy) {\n        _this4.editor.on('destroy', onDestroy);\n      }\n    });\n  }\n\n  _createClass(ExtensionManager, [{\n    key: \"commands\",\n    get: function get() {\n      var _this5 = this;\n\n      return this.extensions.reduce(function (commands, extension) {\n        var context = {\n          name: extension.name,\n          options: extension.options,\n          editor: _this5.editor,\n          type: getSchemaTypeByName(extension.name, _this5.schema)\n        };\n        var addCommands = getExtensionField(extension, 'addCommands', context);\n\n        if (!addCommands) {\n          return commands;\n        }\n\n        return _objectSpread(_objectSpread({}, commands), addCommands());\n      }, {});\n    }\n  }, {\n    key: \"plugins\",\n    get: function get() {\n      var _this6 = this;\n\n      return _toConsumableArray(this.extensions).reverse().map(function (extension) {\n        var context = {\n          name: extension.name,\n          options: extension.options,\n          editor: _this6.editor,\n          type: getSchemaTypeByName(extension.name, _this6.schema)\n        };\n        var plugins = [];\n        var addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);\n\n        if (addKeyboardShortcuts) {\n          var bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(function (_ref21) {\n            var _ref22 = _slicedToArray(_ref21, 2),\n                shortcut = _ref22[0],\n                method = _ref22[1];\n\n            return [shortcut, function () {\n              return method({\n                editor: _this6.editor\n              });\n            }];\n          }));\n          var keyMapPlugin = keymap(bindings);\n          plugins.push(keyMapPlugin);\n        }\n\n        var addInputRules = getExtensionField(extension, 'addInputRules', context);\n\n        if (_this6.editor.options.enableInputRules && addInputRules) {\n          var inputRules$1 = addInputRules();\n          var inputRulePlugins = inputRules$1.length ? [inputRules({\n            rules: inputRules$1\n          })] : [];\n          plugins.push.apply(plugins, inputRulePlugins);\n        }\n\n        var addPasteRules = getExtensionField(extension, 'addPasteRules', context);\n\n        if (_this6.editor.options.enablePasteRules && addPasteRules) {\n          var pasteRulePlugins = addPasteRules();\n          plugins.push.apply(plugins, _toConsumableArray(pasteRulePlugins));\n        }\n\n        var addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);\n\n        if (addProseMirrorPlugins) {\n          var proseMirrorPlugins = addProseMirrorPlugins();\n          plugins.push.apply(plugins, _toConsumableArray(proseMirrorPlugins));\n        }\n\n        return plugins;\n      }).flat();\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      return getAttributesFromExtensions(this.extensions);\n    }\n  }, {\n    key: \"nodeViews\",\n    get: function get() {\n      var _this7 = this;\n\n      var editor = this.editor;\n\n      var _splitExtensions3 = splitExtensions(this.extensions),\n          nodeExtensions = _splitExtensions3.nodeExtensions;\n\n      return Object.fromEntries(nodeExtensions.filter(function (extension) {\n        return !!getExtensionField(extension, 'addNodeView');\n      }).map(function (extension) {\n        var extensionAttributes = _this7.attributes.filter(function (attribute) {\n          return attribute.type === extension.name;\n        });\n\n        var context = {\n          name: extension.name,\n          options: extension.options,\n          editor: editor,\n          type: getNodeType(extension.name, _this7.schema)\n        };\n        var addNodeView = getExtensionField(extension, 'addNodeView', context);\n\n        if (!addNodeView) {\n          return [];\n        }\n\n        var nodeview = function nodeview(node, view, getPos, decorations) {\n          var HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n          return addNodeView()({\n            editor: editor,\n            node: node,\n            getPos: getPos,\n            decorations: decorations,\n            HTMLAttributes: HTMLAttributes,\n            extension: extension\n          });\n        };\n\n        return [extension.name, nodeview];\n      }));\n    }\n  }, {\n    key: \"textSerializers\",\n    get: function get() {\n      var _this8 = this;\n\n      var editor = this.editor;\n\n      var _splitExtensions4 = splitExtensions(this.extensions),\n          nodeExtensions = _splitExtensions4.nodeExtensions;\n\n      return Object.fromEntries(nodeExtensions.filter(function (extension) {\n        return !!getExtensionField(extension, 'renderText');\n      }).map(function (extension) {\n        var context = {\n          name: extension.name,\n          options: extension.options,\n          editor: editor,\n          type: getNodeType(extension.name, _this8.schema)\n        };\n        var renderText = getExtensionField(extension, 'renderText', context);\n\n        if (!renderText) {\n          return [];\n        }\n\n        var textSerializer = function textSerializer(props) {\n          return renderText(props);\n        };\n\n        return [extension.name, textSerializer];\n      }));\n    }\n  }], [{\n    key: \"resolve\",\n    value: function resolve(extensions) {\n      return ExtensionManager.sort(ExtensionManager.flatten(extensions));\n    }\n  }, {\n    key: \"flatten\",\n    value: function flatten(extensions) {\n      var _this9 = this;\n\n      return extensions.map(function (extension) {\n        var context = {\n          name: extension.name,\n          options: extension.options\n        };\n        var addExtensions = getExtensionField(extension, 'addExtensions', context);\n\n        if (addExtensions) {\n          return [extension].concat(_toConsumableArray(_this9.flatten(addExtensions())));\n        }\n\n        return extension;\n      }) // `Infinity` will break TypeScript so we set a number that is probably high enough\n      .flat(10);\n    }\n  }, {\n    key: \"sort\",\n    value: function sort(extensions) {\n      var defaultPriority = 100;\n      return extensions.sort(function (a, b) {\n        var priorityA = getExtensionField(a, 'priority') || defaultPriority;\n        var priorityB = getExtensionField(b, 'priority') || defaultPriority;\n\n        if (priorityA > priorityB) {\n          return -1;\n        }\n\n        if (priorityA < priorityB) {\n          return 1;\n        }\n\n        return 0;\n      });\n    }\n  }]);\n\n  return ExtensionManager;\n}();\n\nvar EventEmitter = /*#__PURE__*/function () {\n  function EventEmitter() {\n    _classCallCheck(this, EventEmitter);\n\n    this.callbacks = {};\n  }\n\n  _createClass(EventEmitter, [{\n    key: \"on\",\n    value: function on(event, fn) {\n      if (!this.callbacks[event]) {\n        this.callbacks[event] = [];\n      }\n\n      this.callbacks[event].push(fn);\n      return this;\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      var _this10 = this;\n\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      var callbacks = this.callbacks[event];\n\n      if (callbacks) {\n        callbacks.forEach(function (callback) {\n          return callback.apply(_this10, args);\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, fn) {\n      var callbacks = this.callbacks[event];\n\n      if (callbacks) {\n        if (fn) {\n          this.callbacks[event] = callbacks.filter(function (callback) {\n            return callback !== fn;\n          });\n        } else {\n          delete this.callbacks[event];\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners() {\n      this.callbacks = {};\n    }\n  }]);\n\n  return EventEmitter;\n}(); // see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\n\n\nfunction getType(payload) {\n  return Object.prototype.toString.call(payload).slice(8, -1);\n}\n\nfunction isPlainObject(payload) {\n  if (getType(payload) !== 'Object') return false;\n  return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;\n}\n\nfunction mergeDeep(target, source) {\n  var output = _objectSpread({}, target);\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(function (key) {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, _defineProperty({}, key, source[key]));\n        } else {\n          output[key] = mergeDeep(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, _defineProperty({}, key, source[key]));\n      }\n    });\n  }\n\n  return output;\n}\n\nvar Extension = /*#__PURE__*/function () {\n  function Extension() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Extension);\n\n    this.type = 'extension';\n    this.name = 'extension';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = _objectSpread(_objectSpread({}, this.config), config);\n    this.name = this.config.name;\n    this.options = this.config.defaultOptions;\n  }\n\n  _createClass(Extension, [{\n    key: \"configure\",\n    value: function configure() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // return a new instance so we can use the same extension\n      // with different calls of `configure`\n      var extension = this.extend();\n      extension.options = mergeDeep(this.options, options);\n      return extension;\n    }\n  }, {\n    key: \"extend\",\n    value: function extend() {\n      var extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var extension = new Extension(extendedConfig);\n      extension.parent = this;\n      this.child = extension;\n      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n      extension.options = extendedConfig.defaultOptions ? extendedConfig.defaultOptions : extension.parent.options;\n      return extension;\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new Extension(config);\n    }\n  }]);\n\n  return Extension;\n}();\n\nvar textBetween = function textBetween(editor, from, to, blockSeparator, leafText) {\n  var text = '';\n  var separated = true;\n  editor.state.doc.nodesBetween(from, to, function (node, pos) {\n    var _a;\n\n    var textSerializer = editor.extensionManager.textSerializers[node.type.name];\n\n    if (textSerializer) {\n      text += textSerializer({\n        node: node\n      });\n      separated = !blockSeparator;\n    } else if (node.isText) {\n      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);\n      separated = !blockSeparator;\n    } else if (node.isLeaf && leafText) {\n      text += leafText;\n      separated = !blockSeparator;\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator;\n      separated = true;\n    }\n  }, 0);\n  return text;\n};\n\nvar ClipboardTextSerializer = Extension.create({\n  name: 'editable',\n  addProseMirrorPlugins: function addProseMirrorPlugins() {\n    var _this11 = this;\n\n    return [new Plugin({\n      key: new PluginKey('clipboardTextSerializer'),\n      props: {\n        clipboardTextSerializer: function clipboardTextSerializer() {\n          var editor = _this11.editor;\n          var _editor$state$selecti = editor.state.selection,\n              from = _editor$state$selecti.from,\n              to = _editor$state$selecti.to;\n          return textBetween(editor, from, to, '\\n');\n        }\n      }\n    })];\n  }\n});\n\nvar blur = function blur() {\n  return function (_ref23) {\n    var view = _ref23.view;\n    var element = view.dom;\n    element.blur();\n    return true;\n  };\n};\n\nvar blur$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  blur: blur\n});\n\nvar clearContent = function clearContent() {\n  var emitUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return function (_ref24) {\n    var commands = _ref24.commands;\n    return commands.setContent('', emitUpdate);\n  };\n};\n\nvar clearContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  clearContent: clearContent\n});\n\nvar clearNodes = function clearNodes() {\n  return function (_ref25) {\n    var state = _ref25.state,\n        tr = _ref25.tr,\n        dispatch = _ref25.dispatch;\n    var selection = tr.selection;\n    var ranges = selection.ranges;\n    ranges.forEach(function (range) {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, function (node, pos) {\n        if (node.type.isText) {\n          return;\n        }\n\n        var $fromPos = tr.doc.resolve(tr.mapping.map(pos));\n        var $toPos = tr.doc.resolve(tr.mapping.map(pos + node.nodeSize));\n        var nodeRange = $fromPos.blockRange($toPos);\n\n        if (!nodeRange) {\n          return;\n        }\n\n        var targetLiftDepth = liftTarget(nodeRange);\n\n        if (node.type.isTextblock && dispatch) {\n          var _$fromPos$parent$cont = $fromPos.parent.contentMatchAt($fromPos.index()),\n              defaultType = _$fromPos$parent$cont.defaultType;\n\n          tr.setNodeMarkup(nodeRange.start, defaultType);\n        }\n\n        if ((targetLiftDepth || targetLiftDepth === 0) && dispatch) {\n          tr.lift(nodeRange, targetLiftDepth);\n        }\n      });\n    });\n    return true;\n  };\n};\n\nvar clearNodes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  clearNodes: clearNodes\n});\n\nvar command = function command(fn) {\n  return function (props) {\n    return fn(props);\n  };\n};\n\nvar command$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  command: command\n});\n\nvar createParagraphNear = function createParagraphNear() {\n  return function (_ref26) {\n    var state = _ref26.state,\n        dispatch = _ref26.dispatch;\n    return createParagraphNear$2(state, dispatch);\n  };\n};\n\nvar createParagraphNear$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createParagraphNear: createParagraphNear\n});\n\nvar deleteRange = function deleteRange(range) {\n  return function (_ref27) {\n    var tr = _ref27.tr,\n        dispatch = _ref27.dispatch;\n    var from = range.from,\n        to = range.to;\n\n    if (dispatch) {\n      tr.delete(from, to);\n    }\n\n    return true;\n  };\n};\n\nvar deleteRange$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  deleteRange: deleteRange\n});\n\nvar deleteSelection = function deleteSelection() {\n  return function (_ref28) {\n    var state = _ref28.state,\n        dispatch = _ref28.dispatch;\n    return deleteSelection$2(state, dispatch);\n  };\n};\n\nvar deleteSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  deleteSelection: deleteSelection\n});\n\nvar enter = function enter() {\n  return function (_ref29) {\n    var commands = _ref29.commands;\n    return commands.keyboardShortcut('Enter');\n  };\n};\n\nvar enter$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  enter: enter\n});\n\nvar exitCode = function exitCode() {\n  return function (_ref30) {\n    var state = _ref30.state,\n        dispatch = _ref30.dispatch;\n    return exitCode$2(state, dispatch);\n  };\n};\n\nvar exitCode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  exitCode: exitCode\n});\n\nfunction findMarkInSet(marks, type) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return marks.find(function (item) {\n    return item.type === type && objectIncludes(item.attrs, attributes);\n  });\n}\n\nfunction isMarkInSet(marks, type) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return !!findMarkInSet(marks, type, attributes);\n}\n\nfunction getMarkRange($pos, type) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!$pos || !type) {\n    return;\n  }\n\n  var start = $pos.parent.childAfter($pos.parentOffset);\n\n  if (!start.node) {\n    return;\n  }\n\n  var mark = findMarkInSet(start.node.marks, type, attributes);\n\n  if (!mark) {\n    return;\n  }\n\n  var startIndex = $pos.index();\n  var startPos = $pos.start() + start.offset;\n  var endIndex = startIndex + 1;\n  var endPos = startPos + start.node.nodeSize;\n  findMarkInSet(start.node.marks, type, attributes);\n\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n\n  while (endIndex < $pos.parent.childCount && isMarkInSet($pos.parent.child(endIndex).marks, type, attributes)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\n\nvar extendMarkRange = function extendMarkRange(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref31) {\n    var tr = _ref31.tr,\n        state = _ref31.state,\n        dispatch = _ref31.dispatch;\n    var type = getMarkType(typeOrName, state.schema);\n    var doc = tr.doc,\n        selection = tr.selection;\n    var $from = selection.$from,\n        from = selection.from,\n        to = selection.to;\n\n    if (dispatch) {\n      var range = getMarkRange($from, type, attributes);\n\n      if (range && range.from <= from && range.to >= to) {\n        var newSelection = TextSelection.create(doc, range.from, range.to);\n        tr.setSelection(newSelection);\n      }\n    }\n\n    return true;\n  };\n};\n\nvar extendMarkRange$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  extendMarkRange: extendMarkRange\n});\n\nvar first = function first(commands) {\n  return function (props) {\n    var items = typeof commands === 'function' ? commands(props) : commands;\n\n    for (var i = 0; i < items.length; i += 1) {\n      if (items[i](props)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n};\n\nvar first$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  first: first\n});\n\nfunction minMax() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return Math.min(Math.max(value, min), max);\n}\n\nfunction isClass(item) {\n  var _a;\n\n  if (((_a = item.constructor) === null || _a === void 0 ? void 0 : _a.toString().substring(0, 5)) !== 'class') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item) && !isClass(item);\n}\n\nfunction isTextSelection(value) {\n  return isObject(value) && value instanceof TextSelection;\n}\n\nfunction resolveSelection(state) {\n  var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (!position) {\n    return null;\n  }\n\n  if (position === 'start' || position === true) {\n    return {\n      from: 0,\n      to: 0\n    };\n  }\n\n  if (position === 'end') {\n    var size = state.doc.content.size;\n    return {\n      from: size,\n      to: size\n    };\n  }\n\n  return {\n    from: position,\n    to: position\n  };\n}\n\nvar focus = function focus() {\n  var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return function (_ref32) {\n    var editor = _ref32.editor,\n        view = _ref32.view,\n        tr = _ref32.tr,\n        dispatch = _ref32.dispatch;\n\n    if (view.hasFocus() && position === null || position === false) {\n      return true;\n    } // we donâ€™t try to resolve a NodeSelection or CellSelection\n\n\n    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n      view.focus();\n      return true;\n    }\n\n    var _ref33 = resolveSelection(editor.state, position) || editor.state.selection,\n        from = _ref33.from,\n        to = _ref33.to;\n\n    var doc = tr.doc,\n        storedMarks = tr.storedMarks;\n    var resolvedFrom = minMax(from, 0, doc.content.size);\n    var resolvedEnd = minMax(to, 0, doc.content.size);\n    var selection = TextSelection.create(doc, resolvedFrom, resolvedEnd);\n    var isSameSelection = editor.state.selection.eq(selection);\n\n    if (dispatch) {\n      tr.setSelection(selection); // `tr.setSelection` resets the stored marks\n      // so weâ€™ll restore them if the selection is the same as before\n\n      if (isSameSelection && storedMarks) {\n        tr.setStoredMarks(storedMarks);\n      }\n\n      view.focus();\n    }\n\n    return true;\n  };\n};\n\nvar focus$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  focus: focus\n});\n\nvar insertContent = function insertContent(value) {\n  return function (_ref34) {\n    var tr = _ref34.tr,\n        commands = _ref34.commands;\n    return commands.insertContentAt({\n      from: tr.selection.from,\n      to: tr.selection.to\n    }, value);\n  };\n};\n\nvar insertContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  insertContent: insertContent\n}); // source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  var last = tr.steps.length - 1;\n\n  if (last < startLen) {\n    return;\n  }\n\n  var step = tr.steps[last];\n\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return;\n  }\n\n  var map = tr.mapping.maps[last];\n  var end = 0;\n  map.forEach(function (_from, _to, _newFrom, newTo) {\n    if (end === 0) {\n      end = newTo;\n    }\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nvar insertContentAt = function insertContentAt(position, value) {\n  return function (_ref35) {\n    var tr = _ref35.tr,\n        dispatch = _ref35.dispatch,\n        editor = _ref35.editor;\n\n    if (dispatch) {\n      var content = createNodeFromContent(value, editor.schema, {\n        parseOptions: {\n          preserveWhitespace: 'full'\n        }\n      }); // donâ€™t dispatch an empty fragment because this can lead to strange errors\n\n      if (content.toString() === '<>') {\n        return true;\n      }\n\n      var _ref36 = typeof position === 'number' ? {\n        from: position,\n        to: position\n      } : position,\n          from = _ref36.from,\n          to = _ref36.to;\n\n      tr.replaceWith(from, to, content); // set cursor at end of inserted content\n\n      selectionToInsertionEnd(tr, tr.steps.length - 1, 1);\n    }\n\n    return true;\n  };\n};\n\nvar insertContentAt$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  insertContentAt: insertContentAt\n});\n\nvar joinBackward = function joinBackward() {\n  return function (_ref37) {\n    var state = _ref37.state,\n        dispatch = _ref37.dispatch;\n    return joinBackward$2(state, dispatch);\n  };\n};\n\nvar joinBackward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  joinBackward: joinBackward\n});\n\nvar joinForward = function joinForward() {\n  return function (_ref38) {\n    var state = _ref38.state,\n        dispatch = _ref38.dispatch;\n    return joinForward$2(state, dispatch);\n  };\n};\n\nvar joinForward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  joinForward: joinForward\n});\nvar mac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/);\n  var result = parts[parts.length - 1];\n\n  if (result === 'Space') {\n    result = ' ';\n  }\n\n  var alt;\n  var ctrl;\n  var shift;\n  var meta;\n\n  for (var i = 0; i < parts.length - 1; i += 1) {\n    var mod = parts[i];\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (mac) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(\"Unrecognized modifier name: \".concat(mod));\n    }\n  }\n\n  if (alt) {\n    result = \"Alt-\".concat(result);\n  }\n\n  if (ctrl) {\n    result = \"Ctrl-\".concat(result);\n  }\n\n  if (meta) {\n    result = \"Meta-\".concat(result);\n  }\n\n  if (shift) {\n    result = \"Shift-\".concat(result);\n  }\n\n  return result;\n}\n\nvar keyboardShortcut = function keyboardShortcut(name) {\n  return function (_ref39) {\n    var editor = _ref39.editor,\n        view = _ref39.view,\n        tr = _ref39.tr,\n        dispatch = _ref39.dispatch;\n    var keys = normalizeKeyName(name).split(/-(?!$)/);\n    var key = keys.find(function (item) {\n      return !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item);\n    });\n    var event = new KeyboardEvent('keydown', {\n      key: key === 'Space' ? ' ' : key,\n      altKey: keys.includes('Alt'),\n      ctrlKey: keys.includes('Ctrl'),\n      metaKey: keys.includes('Meta'),\n      shiftKey: keys.includes('Shift'),\n      bubbles: true,\n      cancelable: true\n    });\n    var capturedTransaction = editor.captureTransaction(function () {\n      view.someProp('handleKeyDown', function (f) {\n        return f(view, event);\n      });\n    });\n    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(function (step) {\n      var newStep = step.map(tr.mapping);\n\n      if (newStep && dispatch) {\n        tr.maybeStep(newStep);\n      }\n    });\n    return true;\n  };\n};\n\nvar keyboardShortcut$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  keyboardShortcut: keyboardShortcut\n});\n\nvar lift = function lift(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref40) {\n    var state = _ref40.state,\n        dispatch = _ref40.dispatch;\n    var type = getNodeType(typeOrName, state.schema);\n    var isActive = isNodeActive(state, type, attributes);\n\n    if (!isActive) {\n      return false;\n    }\n\n    return lift$2(state, dispatch);\n  };\n};\n\nvar lift$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  lift: lift\n});\n\nvar liftEmptyBlock = function liftEmptyBlock() {\n  return function (_ref41) {\n    var state = _ref41.state,\n        dispatch = _ref41.dispatch;\n    return liftEmptyBlock$2(state, dispatch);\n  };\n};\n\nvar liftEmptyBlock$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  liftEmptyBlock: liftEmptyBlock\n});\n\nvar liftListItem = function liftListItem(typeOrName) {\n  return function (_ref42) {\n    var state = _ref42.state,\n        dispatch = _ref42.dispatch;\n    var type = getNodeType(typeOrName, state.schema);\n    return liftListItem$2(type)(state, dispatch);\n  };\n};\n\nvar liftListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  liftListItem: liftListItem\n});\n\nvar newlineInCode = function newlineInCode() {\n  return function (_ref43) {\n    var state = _ref43.state,\n        dispatch = _ref43.dispatch;\n    return newlineInCode$2(state, dispatch);\n  };\n};\n\nvar newlineInCode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  newlineInCode: newlineInCode\n});\n\nvar replace = function replace(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref44) {\n    var state = _ref44.state,\n        commands = _ref44.commands;\n    console.warn('[tiptap warn]: replace() is deprecated. please use insertContent() instead.');\n    var _state$selection5 = state.selection,\n        from = _state$selection5.from,\n        to = _state$selection5.to;\n    var range = {\n      from: from,\n      to: to\n    };\n    return commands.replaceRange(range, typeOrName, attributes);\n  };\n};\n\nvar replace$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  replace: replace\n});\n\nvar replaceRange = function replaceRange(range, typeOrName) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return function (_ref45) {\n    var tr = _ref45.tr,\n        state = _ref45.state,\n        dispatch = _ref45.dispatch;\n    console.warn('[tiptap warn]: replaceRange() is deprecated. please use insertContent() instead.');\n    var type = getNodeType(typeOrName, state.schema);\n    var from = range.from,\n        to = range.to; // const $from = tr.doc.resolve(from)\n    // const index = $from.index()\n    // if (!$from.parent.canReplaceWith(index, index, type)) {\n    //   return false\n    // }\n\n    if (dispatch) {\n      tr.replaceRangeWith(from, to, type.create(attributes));\n    }\n\n    return true;\n  };\n};\n\nvar replaceRange$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  replaceRange: replaceRange\n});\n/**\r\n * Remove a property or an array of properties from an object\r\n * @param obj Object\r\n * @param key Key to remove\r\n */\n\nfunction deleteProps(obj, propOrProps) {\n  var props = typeof propOrProps === 'string' ? [propOrProps] : propOrProps;\n  return Object.keys(obj).reduce(function (newObj, prop) {\n    if (!props.includes(prop)) {\n      newObj[prop] = obj[prop];\n    }\n\n    return newObj;\n  }, {});\n}\n\nvar resetAttributes = function resetAttributes(typeOrName, attributes) {\n  return function (_ref46) {\n    var tr = _ref46.tr,\n        state = _ref46.state,\n        dispatch = _ref46.dispatch;\n    var nodeType = null;\n    var markType = null;\n    var schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n\n    if (!schemaType) {\n      return false;\n    }\n\n    if (schemaType === 'node') {\n      nodeType = getNodeType(typeOrName, state.schema);\n    }\n\n    if (schemaType === 'mark') {\n      markType = getMarkType(typeOrName, state.schema);\n    }\n\n    if (dispatch) {\n      tr.selection.ranges.forEach(function (range) {\n        state.doc.nodesBetween(range.$from.pos, range.$to.pos, function (node, pos) {\n          if (nodeType && nodeType === node.type) {\n            tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\n          }\n\n          if (markType && node.marks.length) {\n            node.marks.forEach(function (mark) {\n              if (markType === mark.type) {\n                tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n              }\n            });\n          }\n        });\n      });\n    }\n\n    return true;\n  };\n};\n\nvar resetAttributes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  resetAttributes: resetAttributes\n});\n\nvar scrollIntoView = function scrollIntoView() {\n  return function (_ref47) {\n    var tr = _ref47.tr,\n        dispatch = _ref47.dispatch;\n\n    if (dispatch) {\n      tr.scrollIntoView();\n    }\n\n    return true;\n  };\n};\n\nvar scrollIntoView$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  scrollIntoView: scrollIntoView\n});\n\nvar selectAll = function selectAll() {\n  return function (_ref48) {\n    var state = _ref48.state,\n        dispatch = _ref48.dispatch;\n    return selectAll$2(state, dispatch);\n  };\n};\n\nvar selectAll$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectAll: selectAll\n});\n\nvar selectNodeBackward = function selectNodeBackward() {\n  return function (_ref49) {\n    var state = _ref49.state,\n        dispatch = _ref49.dispatch;\n    return selectNodeBackward$2(state, dispatch);\n  };\n};\n\nvar selectNodeBackward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectNodeBackward: selectNodeBackward\n});\n\nvar selectNodeForward = function selectNodeForward() {\n  return function (_ref50) {\n    var state = _ref50.state,\n        dispatch = _ref50.dispatch;\n    return selectNodeForward$2(state, dispatch);\n  };\n};\n\nvar selectNodeForward$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectNodeForward: selectNodeForward\n});\n\nvar selectParentNode = function selectParentNode() {\n  return function (_ref51) {\n    var state = _ref51.state,\n        dispatch = _ref51.dispatch;\n    return selectParentNode$2(state, dispatch);\n  };\n};\n\nvar selectParentNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  selectParentNode: selectParentNode\n});\n\nvar setContent = function setContent(content) {\n  var emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return function (_ref52) {\n    var tr = _ref52.tr,\n        editor = _ref52.editor,\n        dispatch = _ref52.dispatch;\n    var doc = tr.doc;\n    var document = createDocument(content, editor.schema, parseOptions);\n    var selection = TextSelection.create(doc, 0, doc.content.size);\n\n    if (dispatch) {\n      tr.setSelection(selection).replaceSelectionWith(document, false).setMeta('preventUpdate', !emitUpdate);\n    }\n\n    return true;\n  };\n};\n\nvar setContent$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setContent: setContent\n});\n\nvar setMark = function setMark(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref53) {\n    var tr = _ref53.tr,\n        state = _ref53.state,\n        dispatch = _ref53.dispatch;\n    var selection = tr.selection;\n    var empty = selection.empty,\n        ranges = selection.ranges;\n    var type = getMarkType(typeOrName, state.schema);\n\n    if (dispatch) {\n      if (empty) {\n        var oldAttributes = _getMarkAttributes(state, type);\n\n        tr.addStoredMark(type.create(_objectSpread(_objectSpread({}, oldAttributes), attributes)));\n      } else {\n        ranges.forEach(function (range) {\n          var from = range.$from.pos;\n          var to = range.$to.pos;\n          state.doc.nodesBetween(from, to, function (node, pos) {\n            var trimmedFrom = Math.max(pos, from);\n            var trimmedTo = Math.min(pos + node.nodeSize, to);\n            var someHasMark = node.marks.find(function (mark) {\n              return mark.type === type;\n            }); // if there is already a mark of this type\n            // we know that we have to merge its attributes\n            // otherwise we add a fresh new mark\n\n            if (someHasMark) {\n              node.marks.forEach(function (mark) {\n                if (type === mark.type) {\n                  tr.addMark(trimmedFrom, trimmedTo, type.create(_objectSpread(_objectSpread({}, mark.attrs), attributes)));\n                }\n              });\n            } else {\n              tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n            }\n          });\n        });\n      }\n    }\n\n    return true;\n  };\n};\n\nvar setMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setMark: setMark\n});\n\nvar setMeta = function setMeta(key, value) {\n  return function (_ref54) {\n    var tr = _ref54.tr;\n    tr.setMeta(key, value);\n    return true;\n  };\n};\n\nvar setMeta$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setMeta: setMeta\n});\n\nvar setNode = function setNode(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref55) {\n    var state = _ref55.state,\n        dispatch = _ref55.dispatch;\n    var type = getNodeType(typeOrName, state.schema);\n    return setBlockType(type, attributes)(state, dispatch);\n  };\n};\n\nvar setNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setNode: setNode\n});\n\nvar setNodeSelection = function setNodeSelection(position) {\n  return function (_ref56) {\n    var tr = _ref56.tr,\n        dispatch = _ref56.dispatch;\n\n    if (dispatch) {\n      var doc = tr.doc;\n      var from = minMax(position, 0, doc.content.size);\n      var selection = NodeSelection.create(doc, from);\n      tr.setSelection(selection);\n    }\n\n    return true;\n  };\n};\n\nvar setNodeSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setNodeSelection: setNodeSelection\n});\n\nvar setTextSelection = function setTextSelection(position) {\n  return function (_ref57) {\n    var tr = _ref57.tr,\n        dispatch = _ref57.dispatch;\n\n    if (dispatch) {\n      var doc = tr.doc;\n\n      var _ref58 = typeof position === 'number' ? {\n        from: position,\n        to: position\n      } : position,\n          from = _ref58.from,\n          to = _ref58.to;\n\n      var boundedFrom = minMax(from, 0, doc.content.size);\n      var boundedTo = minMax(to, 0, doc.content.size);\n      var selection = TextSelection.create(doc, boundedFrom, boundedTo);\n      tr.setSelection(selection);\n    }\n\n    return true;\n  };\n};\n\nvar setTextSelection$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setTextSelection: setTextSelection\n});\n\nvar sinkListItem = function sinkListItem(typeOrName) {\n  return function (_ref59) {\n    var state = _ref59.state,\n        dispatch = _ref59.dispatch;\n    var type = getNodeType(typeOrName, state.schema);\n    return sinkListItem$2(type)(state, dispatch);\n  };\n};\n\nvar sinkListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  sinkListItem: sinkListItem\n});\n\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n  return Object.fromEntries(Object.entries(attributes).filter(function (_ref60) {\n    var _ref61 = _slicedToArray(_ref60, 1),\n        name = _ref61[0];\n\n    var extensionAttribute = extensionAttributes.find(function (item) {\n      return item.type === typeName && item.name === name;\n    });\n\n    if (!extensionAttribute) {\n      return false;\n    }\n\n    return extensionAttribute.attribute.keepOnSplit;\n  }));\n}\n\nfunction defaultBlockAt(match) {\n  for (var i = 0; i < match.edgeCount; i += 1) {\n    var _match$edge = match.edge(i),\n        type = _match$edge.type;\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n\n  return null;\n}\n\nfunction ensureMarks(state, splittableMarks) {\n  var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n\n  if (marks) {\n    var filteredMarks = marks.filter(function (mark) {\n      return splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name);\n    });\n    state.tr.ensureMarks(filteredMarks);\n  }\n}\n\nvar splitBlock = function splitBlock() {\n  var _ref62 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref62$keepMarks = _ref62.keepMarks,\n      keepMarks = _ref62$keepMarks === void 0 ? true : _ref62$keepMarks;\n\n  return function (_ref63) {\n    var tr = _ref63.tr,\n        state = _ref63.state,\n        dispatch = _ref63.dispatch,\n        editor = _ref63.editor;\n    var selection = tr.selection,\n        doc = tr.doc;\n    var $from = selection.$from,\n        $to = selection.$to;\n    var extensionAttributes = editor.extensionManager.attributes;\n    var newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\n      if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n        return false;\n      }\n\n      if (dispatch) {\n        if (keepMarks) {\n          ensureMarks(state, editor.extensionManager.splittableMarks);\n        }\n\n        tr.split($from.pos).scrollIntoView();\n      }\n\n      return true;\n    }\n\n    if (!$from.parent.isBlock) {\n      return false;\n    }\n\n    if (dispatch) {\n      var atEnd = $to.parentOffset === $to.parent.content.size;\n\n      if (selection instanceof TextSelection) {\n        tr.deleteSelection();\n      }\n\n      var deflt = $from.depth === 0 ? undefined : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n      var types = atEnd && deflt ? [{\n        type: deflt,\n        attrs: newAttributes\n      }] : undefined;\n      var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n\n      if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{\n        type: deflt\n      }] : undefined)) {\n        can = true;\n        types = deflt ? [{\n          type: deflt,\n          attrs: newAttributes\n        }] : undefined;\n      }\n\n      if (can) {\n        tr.split(tr.mapping.map($from.pos), 1, types);\n\n        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n          var _first = tr.mapping.map($from.before());\n\n          var $first = tr.doc.resolve(_first);\n\n          if ($from.parent.canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n          }\n        }\n      }\n\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks);\n      }\n\n      tr.scrollIntoView();\n    }\n\n    return true;\n  };\n};\n\nvar splitBlock$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  splitBlock: splitBlock\n});\n\nvar splitListItem = function splitListItem(typeOrName) {\n  return function (_ref64) {\n    var tr = _ref64.tr,\n        state = _ref64.state,\n        dispatch = _ref64.dispatch,\n        editor = _ref64.editor;\n\n    var _a;\n\n    var type = getNodeType(typeOrName, state.schema);\n    var _state$selection6 = state.selection,\n        $from = _state$selection6.$from,\n        $to = _state$selection6.$to; // @ts-ignore\n    // eslint-disable-next-line\n\n    var node = state.selection.node;\n\n    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n      return false;\n    }\n\n    var grandParent = $from.node(-1);\n\n    if (grandParent.type !== type) {\n      return false;\n    }\n\n    var extensionAttributes = editor.extensionManager.attributes;\n\n    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n        return false;\n      }\n\n      if (dispatch) {\n        var wrap = Fragment.empty;\n        var keepItem = $from.index(-1) > 0; // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n\n        for (var d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d -= 1) {\n          wrap = Fragment.from($from.node(d).copy(wrap));\n        } // Add a second list item with an empty default start node\n\n\n        var _newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n\n        var _nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(_newNextTypeAttributes)) || undefined;\n\n        wrap = wrap.append(Fragment.from(type.createAndFill(null, _nextType) || undefined));\n        tr.replace($from.before(keepItem ? undefined : -1), $from.after(-3), new Slice(wrap, keepItem ? 3 : 2, 2)).setSelection(TextSelection.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2)))).scrollIntoView();\n      }\n\n      return true;\n    }\n\n    var nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n    var newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);\n    var newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n    tr.delete($from.pos, $to.pos);\n    var types = nextType ? [{\n      type: type,\n      attrs: newTypeAttributes\n    }, {\n      type: nextType,\n      attrs: newNextTypeAttributes\n    }] : [{\n      type: type,\n      attrs: newTypeAttributes\n    }];\n\n    if (!canSplit(tr.doc, $from.pos, 2)) {\n      return false;\n    }\n\n    if (dispatch) {\n      tr.split($from.pos, 2, types).scrollIntoView();\n    }\n\n    return true;\n  };\n};\n\nvar splitListItem$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  splitListItem: splitListItem\n});\n\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (var i = $pos.depth; i > 0; i -= 1) {\n    var node = $pos.node(i);\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node: node\n      };\n    }\n  }\n}\n\nfunction findParentNode(predicate) {\n  return function (selection) {\n    return findParentNodeClosestToPos(selection.$from, predicate);\n  };\n}\n\nfunction isList(name, extensions) {\n  var _splitExtensions5 = splitExtensions(extensions),\n      nodeExtensions = _splitExtensions5.nodeExtensions;\n\n  var extension = nodeExtensions.find(function (item) {\n    return item.name === name;\n  });\n\n  if (!extension) {\n    return false;\n  }\n\n  var context = {\n    name: extension.name,\n    options: extension.options\n  };\n  var group = callOrReturn(getExtensionField(extension, 'group', context));\n\n  if (typeof group !== 'string') {\n    return false;\n  }\n\n  return group.split(' ').includes('list');\n}\n\nvar toggleList = function toggleList(listTypeOrName, itemTypeOrName) {\n  return function (_ref65) {\n    var editor = _ref65.editor,\n        tr = _ref65.tr,\n        state = _ref65.state,\n        dispatch = _ref65.dispatch,\n        chain = _ref65.chain,\n        commands = _ref65.commands,\n        can = _ref65.can;\n    var extensions = editor.extensionManager.extensions;\n    var listType = getNodeType(listTypeOrName, state.schema);\n    var itemType = getNodeType(itemTypeOrName, state.schema);\n    var selection = state.selection;\n    var $from = selection.$from,\n        $to = selection.$to;\n    var range = $from.blockRange($to);\n\n    if (!range) {\n      return false;\n    }\n\n    var parentList = findParentNode(function (node) {\n      return isList(node.type.name, extensions);\n    })(selection);\n\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n      // remove list\n      if (parentList.node.type === listType) {\n        return commands.liftListItem(itemType);\n      } // change list type\n\n\n      if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n        tr.setNodeMarkup(parentList.pos, listType);\n        return true;\n      }\n    }\n\n    var canWrapInList = can().wrapInList(listType); // try to convert node to paragraph if needed\n\n    if (!canWrapInList) {\n      return chain().clearNodes().wrapInList(listType).run();\n    }\n\n    return commands.wrapInList(listType);\n  };\n};\n\nvar toggleList$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleList: toggleList\n});\n\nvar toggleMark = function toggleMark(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref66) {\n    var state = _ref66.state,\n        commands = _ref66.commands;\n    var type = getMarkType(typeOrName, state.schema);\n    var isActive = isMarkActive(state, type, attributes);\n\n    if (isActive) {\n      return commands.unsetMark(type);\n    }\n\n    return commands.setMark(type, attributes);\n  };\n};\n\nvar toggleMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleMark: toggleMark\n});\n\nvar toggleNode = function toggleNode(typeOrName, toggleTypeOrName) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return function (_ref67) {\n    var state = _ref67.state,\n        commands = _ref67.commands;\n    var type = getNodeType(typeOrName, state.schema);\n    var toggleType = getNodeType(toggleTypeOrName, state.schema);\n    var isActive = isNodeActive(state, type, attributes);\n\n    if (isActive) {\n      return commands.setNode(toggleType);\n    }\n\n    return commands.setNode(type, attributes);\n  };\n};\n\nvar toggleNode$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleNode: toggleNode\n});\n\nvar toggleWrap = function toggleWrap(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref68) {\n    var state = _ref68.state,\n        dispatch = _ref68.dispatch;\n    var type = getNodeType(typeOrName, state.schema);\n    var isActive = isNodeActive(state, type, attributes);\n\n    if (isActive) {\n      return lift$2(state, dispatch);\n    }\n\n    return wrapIn$2(type, attributes)(state, dispatch);\n  };\n};\n\nvar toggleWrap$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  toggleWrap: toggleWrap\n});\n\nvar undoInputRule = function undoInputRule() {\n  return function (_ref69) {\n    var state = _ref69.state,\n        dispatch = _ref69.dispatch;\n    return undoInputRule$2(state, dispatch);\n  };\n};\n\nvar undoInputRule$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  undoInputRule: undoInputRule\n});\n\nvar unsetAllMarks = function unsetAllMarks() {\n  return function (_ref70) {\n    var tr = _ref70.tr,\n        state = _ref70.state,\n        dispatch = _ref70.dispatch;\n    var selection = tr.selection;\n    var empty = selection.empty,\n        ranges = selection.ranges;\n\n    if (empty) {\n      return true;\n    }\n\n    if (dispatch) {\n      Object.entries(state.schema.marks).forEach(function (_ref71) {\n        var _ref72 = _slicedToArray(_ref71, 2),\n            mark = _ref72[1];\n\n        ranges.forEach(function (range) {\n          tr.removeMark(range.$from.pos, range.$to.pos, mark);\n        });\n      });\n    }\n\n    return true;\n  };\n};\n\nvar unsetAllMarks$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unsetAllMarks: unsetAllMarks\n});\n\nvar unsetMark = function unsetMark(typeOrName) {\n  return function (_ref73) {\n    var tr = _ref73.tr,\n        state = _ref73.state,\n        dispatch = _ref73.dispatch;\n    var selection = tr.selection;\n    var type = getMarkType(typeOrName, state.schema);\n    var $from = selection.$from,\n        empty = selection.empty,\n        ranges = selection.ranges;\n\n    if (dispatch) {\n      if (empty) {\n        var from = selection.from,\n            to = selection.to;\n        var range = getMarkRange($from, type);\n\n        if (range) {\n          from = range.from;\n          to = range.to;\n        }\n\n        tr.removeMark(from, to, type);\n      } else {\n        ranges.forEach(function (range) {\n          tr.removeMark(range.$from.pos, range.$to.pos, type);\n        });\n      }\n\n      tr.removeStoredMark(type);\n    }\n\n    return true;\n  };\n};\n\nvar unsetMark$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unsetMark: unsetMark\n});\n\nvar updateAttributes = function updateAttributes(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref74) {\n    var tr = _ref74.tr,\n        state = _ref74.state,\n        dispatch = _ref74.dispatch;\n    var nodeType = null;\n    var markType = null;\n    var schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n\n    if (!schemaType) {\n      return false;\n    }\n\n    if (schemaType === 'node') {\n      nodeType = getNodeType(typeOrName, state.schema);\n    }\n\n    if (schemaType === 'mark') {\n      markType = getMarkType(typeOrName, state.schema);\n    }\n\n    if (dispatch) {\n      tr.selection.ranges.forEach(function (range) {\n        var from = range.$from.pos;\n        var to = range.$to.pos;\n        state.doc.nodesBetween(from, to, function (node, pos) {\n          if (nodeType && nodeType === node.type) {\n            tr.setNodeMarkup(pos, undefined, _objectSpread(_objectSpread({}, node.attrs), attributes));\n          }\n\n          if (markType && node.marks.length) {\n            node.marks.forEach(function (mark) {\n              if (markType === mark.type) {\n                var trimmedFrom = Math.max(pos, from);\n                var trimmedTo = Math.min(pos + node.nodeSize, to);\n                tr.addMark(trimmedFrom, trimmedTo, markType.create(_objectSpread(_objectSpread({}, mark.attrs), attributes)));\n              }\n            });\n          }\n        });\n      });\n    }\n\n    return true;\n  };\n};\n\nvar updateAttributes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  updateAttributes: updateAttributes\n});\n\nvar wrapIn = function wrapIn(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref75) {\n    var state = _ref75.state,\n        dispatch = _ref75.dispatch;\n    var type = getNodeType(typeOrName, state.schema);\n    var isActive = isNodeActive(state, type, attributes);\n\n    if (isActive) {\n      return false;\n    }\n\n    return wrapIn$2(type, attributes)(state, dispatch);\n  };\n};\n\nvar wrapIn$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  wrapIn: wrapIn\n});\n\nvar wrapInList = function wrapInList(typeOrName) {\n  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (_ref76) {\n    var state = _ref76.state,\n        dispatch = _ref76.dispatch;\n    var type = getNodeType(typeOrName, state.schema);\n    return wrapInList$2(type, attributes)(state, dispatch);\n  };\n};\n\nvar wrapInList$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  wrapInList: wrapInList\n});\nvar Commands = Extension.create({\n  name: 'commands',\n  addCommands: function addCommands() {\n    return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, blur$1), clearContent$1), clearNodes$1), command$1), createParagraphNear$1), deleteRange$1), deleteSelection$1), enter$1), exitCode$1), extendMarkRange$1), first$1), focus$1), insertContent$1), insertContentAt$1), joinBackward$1), joinForward$1), keyboardShortcut$1), lift$1), liftEmptyBlock$1), liftListItem$1), newlineInCode$1), replace$1), replaceRange$1), resetAttributes$1), scrollIntoView$1), selectAll$1), selectNodeBackward$1), selectNodeForward$1), selectParentNode$1), setContent$1), setMark$1), setMeta$1), setNode$1), setNodeSelection$1), setTextSelection$1), sinkListItem$1), splitBlock$1), splitListItem$1), toggleList$1), toggleMark$1), toggleNode$1), toggleWrap$1), undoInputRule$1), unsetAllMarks$1), unsetMark$1), updateAttributes$1), wrapIn$1), wrapInList$1);\n  }\n});\nvar Editable = Extension.create({\n  name: 'editable',\n  addProseMirrorPlugins: function addProseMirrorPlugins() {\n    var _this12 = this;\n\n    return [new Plugin({\n      key: new PluginKey('editable'),\n      props: {\n        editable: function editable() {\n          return _this12.editor.options.editable;\n        }\n      }\n    })];\n  }\n});\nvar FocusEvents = Extension.create({\n  name: 'focusEvents',\n  addProseMirrorPlugins: function addProseMirrorPlugins() {\n    var editor = this.editor;\n    return [new Plugin({\n      key: new PluginKey('focusEvents'),\n      props: {\n        attributes: {\n          tabindex: '0'\n        },\n        handleDOMEvents: {\n          focus: function focus(view, event) {\n            editor.isFocused = true;\n            var transaction = editor.state.tr.setMeta('focus', {\n              event: event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          },\n          blur: function blur(view, event) {\n            editor.isFocused = false;\n            var transaction = editor.state.tr.setMeta('blur', {\n              event: event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          }\n        }\n      }\n    })];\n  }\n});\nvar Keymap = Extension.create({\n  name: 'keymap',\n  addKeyboardShortcuts: function addKeyboardShortcuts() {\n    var _this13 = this;\n\n    var handleBackspace = function handleBackspace() {\n      return _this13.editor.commands.first(function (_ref77) {\n        var commands = _ref77.commands;\n        return [function () {\n          return commands.undoInputRule();\n        }, function () {\n          return commands.deleteSelection();\n        }, function () {\n          return commands.joinBackward();\n        }, function () {\n          return commands.selectNodeBackward();\n        }];\n      });\n    };\n\n    var handleDelete = function handleDelete() {\n      return _this13.editor.commands.first(function (_ref78) {\n        var commands = _ref78.commands;\n        return [function () {\n          return commands.deleteSelection();\n        }, function () {\n          return commands.joinForward();\n        }, function () {\n          return commands.selectNodeForward();\n        }];\n      });\n    };\n\n    return {\n      Enter: function Enter() {\n        return _this13.editor.commands.first(function (_ref79) {\n          var commands = _ref79.commands;\n          return [function () {\n            return commands.newlineInCode();\n          }, function () {\n            return commands.createParagraphNear();\n          }, function () {\n            return commands.liftEmptyBlock();\n          }, function () {\n            return commands.splitBlock();\n          }];\n        });\n      },\n      'Mod-Enter': function ModEnter() {\n        return _this13.editor.commands.exitCode();\n      },\n      Backspace: function Backspace() {\n        return handleBackspace();\n      },\n      'Mod-Backspace': function ModBackspace() {\n        return handleBackspace();\n      },\n      Delete: function Delete() {\n        return handleDelete();\n      },\n      'Mod-Delete': function ModDelete() {\n        return handleDelete();\n      } // we donâ€™t need a custom `selectAll` for now\n      // 'Mod-a': () => this.editor.commands.selectAll(),\n\n    };\n  }\n});\nvar extensions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer: ClipboardTextSerializer,\n  Commands: Commands,\n  Editable: Editable,\n  FocusEvents: FocusEvents,\n  Keymap: Keymap\n});\nvar style = \".ProseMirror {\\n  position: relative;\\n}\\n\\n.ProseMirror {\\n  word-wrap: break-word;\\n  white-space: pre-wrap;\\n  -webkit-font-variant-ligatures: none;\\n  font-variant-ligatures: none;\\n}\\n\\n.ProseMirror [contenteditable=\\\"false\\\"] {\\n  white-space: normal;\\n}\\n\\n.ProseMirror [contenteditable=\\\"false\\\"] [contenteditable=\\\"true\\\"] {\\n  white-space: pre-wrap;\\n}\\n\\n.ProseMirror pre {\\n  white-space: pre-wrap;\\n}\\n\\n.ProseMirror-gapcursor {\\n  display: none;\\n  pointer-events: none;\\n  position: absolute;\\n}\\n\\n.ProseMirror-gapcursor:after {\\n  content: \\\"\\\";\\n  display: block;\\n  position: absolute;\\n  top: -2px;\\n  width: 20px;\\n  border-top: 1px solid black;\\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\\n}\\n\\n@keyframes ProseMirror-cursor-blink {\\n  to {\\n    visibility: hidden;\\n  }\\n}\\n\\n.ProseMirror-hideselection *::selection {\\n  background: transparent;\\n}\\n\\n.ProseMirror-hideselection *::-moz-selection {\\n  background: transparent;\\n}\\n\\n.ProseMirror-hideselection * {\\n  caret-color: transparent;\\n}\\n\\n.ProseMirror-focused .ProseMirror-gapcursor {\\n  display: block;\\n}\\n\\n.tippy-box[data-animation=fade][data-state=hidden] {\\n  opacity: 0\\n}\";\n\nvar Editor = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Editor, _EventEmitter);\n\n  var _super = _createSuper(Editor);\n\n  function Editor() {\n    var _this14;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Editor);\n\n    _this14 = _super.call(this);\n    _this14.isFocused = false;\n    _this14.options = {\n      element: document.createElement('div'),\n      content: '',\n      injectCSS: true,\n      extensions: [],\n      autofocus: false,\n      editable: true,\n      editorProps: {},\n      parseOptions: {},\n      enableInputRules: true,\n      enablePasteRules: true,\n      onBeforeCreate: function onBeforeCreate() {\n        return null;\n      },\n      onCreate: function onCreate() {\n        return null;\n      },\n      onUpdate: function onUpdate() {\n        return null;\n      },\n      onSelectionUpdate: function onSelectionUpdate() {\n        return null;\n      },\n      onTransaction: function onTransaction() {\n        return null;\n      },\n      onFocus: function onFocus() {\n        return null;\n      },\n      onBlur: function onBlur() {\n        return null;\n      },\n      onDestroy: function onDestroy() {\n        return null;\n      }\n    };\n    _this14.isCapturingTransaction = false;\n    _this14.capturedTransaction = null;\n\n    _this14.setOptions(options);\n\n    _this14.createExtensionManager();\n\n    _this14.createCommandManager();\n\n    _this14.createSchema();\n\n    _this14.on('beforeCreate', _this14.options.onBeforeCreate);\n\n    _this14.emit('beforeCreate', {\n      editor: _assertThisInitialized(_this14)\n    });\n\n    _this14.createView();\n\n    _this14.injectCSS();\n\n    _this14.on('create', _this14.options.onCreate);\n\n    _this14.on('update', _this14.options.onUpdate);\n\n    _this14.on('selectionUpdate', _this14.options.onSelectionUpdate);\n\n    _this14.on('transaction', _this14.options.onTransaction);\n\n    _this14.on('focus', _this14.options.onFocus);\n\n    _this14.on('blur', _this14.options.onBlur);\n\n    _this14.on('destroy', _this14.options.onDestroy);\n\n    window.setTimeout(function () {\n      if (_this14.isDestroyed) {\n        return;\n      }\n\n      _this14.commands.focus(_this14.options.autofocus);\n\n      _this14.emit('create', {\n        editor: _assertThisInitialized(_this14)\n      });\n    }, 0);\n    return _this14;\n  }\n  /**\r\n   * An object of all registered commands.\r\n   */\n\n\n  _createClass(Editor, [{\n    key: \"commands\",\n    get: function get() {\n      return this.commandManager.createCommands();\n    }\n    /**\r\n     * Create a command chain to call multiple commands at once.\r\n     */\n\n  }, {\n    key: \"chain\",\n    value: function chain() {\n      return this.commandManager.createChain();\n    }\n    /**\r\n     * Check if a command or a command chain can be executed. Without executing it.\r\n     */\n\n  }, {\n    key: \"can\",\n    value: function can() {\n      return this.commandManager.createCan();\n    }\n    /**\r\n     * Inject CSS styles.\r\n     */\n\n  }, {\n    key: \"injectCSS\",\n    value: function injectCSS() {\n      if (this.options.injectCSS && document) {\n        this.css = createStyleTag(style);\n      }\n    }\n    /**\r\n     * Update editor options.\r\n     *\r\n     * @param options A list of options\r\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.options = _objectSpread(_objectSpread({}, this.options), options);\n    }\n    /**\r\n     * Update editable state of the editor.\r\n     */\n\n  }, {\n    key: \"setEditable\",\n    value: function setEditable(editable) {\n      this.setOptions({\n        editable: editable\n      });\n\n      if (this.view && this.state && !this.isDestroyed) {\n        this.view.updateState(this.state);\n      }\n    }\n    /**\r\n     * Returns whether the editor is editable.\r\n     */\n\n  }, {\n    key: \"isEditable\",\n    get: function get() {\n      return this.view && this.view.editable;\n    }\n    /**\r\n     * Returns the editor state.\r\n     */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.view.state;\n    }\n    /**\r\n     * Register a ProseMirror plugin.\r\n     *\r\n     * @param plugin A ProseMirror plugin\r\n     * @param handlePlugins Control how to merge the plugin into the existing plugins.\r\n     */\n\n  }, {\n    key: \"registerPlugin\",\n    value: function registerPlugin(plugin, handlePlugins) {\n      var plugins = typeof handlePlugins === 'function' ? handlePlugins(plugin, this.state.plugins) : [].concat(_toConsumableArray(this.state.plugins), [plugin]);\n      var state = this.state.reconfigure({\n        plugins: plugins\n      });\n      this.view.updateState(state);\n    }\n    /**\r\n     * Unregister a ProseMirror plugin.\r\n     *\r\n     * @param name The plugins name\r\n     */\n\n  }, {\n    key: \"unregisterPlugin\",\n    value: function unregisterPlugin(nameOrPluginKey) {\n      if (this.isDestroyed) {\n        return;\n      }\n\n      var name = typeof nameOrPluginKey === 'string' ? \"\".concat(nameOrPluginKey, \"$\") // @ts-ignore\n      : nameOrPluginKey.key;\n      var state = this.state.reconfigure({\n        // @ts-ignore\n        plugins: this.state.plugins.filter(function (plugin) {\n          return !plugin.key.startsWith(name);\n        })\n      });\n      this.view.updateState(state);\n    }\n    /**\r\n     * Creates an extension manager.\r\n     */\n\n  }, {\n    key: \"createExtensionManager\",\n    value: function createExtensionManager() {\n      var coreExtensions = Object.entries(extensions).map(function (_ref80) {\n        var _ref81 = _slicedToArray(_ref80, 2),\n            extension = _ref81[1];\n\n        return extension;\n      });\n      var allExtensions = [].concat(_toConsumableArray(coreExtensions), _toConsumableArray(this.options.extensions)).filter(function (extension) {\n        return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n      });\n      this.extensionManager = new ExtensionManager(allExtensions, this);\n    }\n    /**\r\n     * Creates an command manager.\r\n     */\n\n  }, {\n    key: \"createCommandManager\",\n    value: function createCommandManager() {\n      this.commandManager = new CommandManager(this, this.extensionManager.commands);\n    }\n    /**\r\n     * Creates a ProseMirror schema.\r\n     */\n\n  }, {\n    key: \"createSchema\",\n    value: function createSchema() {\n      this.schema = this.extensionManager.schema;\n    }\n    /**\r\n     * Creates a ProseMirror view.\r\n     */\n\n  }, {\n    key: \"createView\",\n    value: function createView() {\n      this.view = new EditorView(this.options.element, _objectSpread(_objectSpread({}, this.options.editorProps), {}, {\n        dispatchTransaction: this.dispatchTransaction.bind(this),\n        state: EditorState.create({\n          doc: createDocument(this.options.content, this.schema, this.options.parseOptions)\n        })\n      })); // `editor.view` is not yet available at this time.\n      // Therefore we will add all plugins and node views directly afterwards.\n\n      var newState = this.state.reconfigure({\n        plugins: this.extensionManager.plugins\n      });\n      this.view.updateState(newState);\n      this.createNodeViews(); // Letâ€™s store the editor instance in the DOM element.\n      // So weâ€™ll have access to it for tests.\n\n      var dom = this.view.dom;\n      dom.editor = this;\n    }\n    /**\r\n     * Creates all node views.\r\n     */\n\n  }, {\n    key: \"createNodeViews\",\n    value: function createNodeViews() {\n      this.view.setProps({\n        nodeViews: this.extensionManager.nodeViews\n      });\n    }\n  }, {\n    key: \"captureTransaction\",\n    value: function captureTransaction(fn) {\n      this.isCapturingTransaction = true;\n      fn();\n      this.isCapturingTransaction = false;\n      var tr = this.capturedTransaction;\n      this.capturedTransaction = null;\n      return tr;\n    }\n    /**\r\n     * The callback over which to send transactions (state updates) produced by the view.\r\n     *\r\n     * @param transaction An editor state transaction\r\n     */\n\n  }, {\n    key: \"dispatchTransaction\",\n    value: function dispatchTransaction(transaction) {\n      var _this15 = this;\n\n      if (this.isCapturingTransaction) {\n        if (!this.capturedTransaction) {\n          this.capturedTransaction = transaction;\n          return;\n        }\n\n        transaction.steps.forEach(function (step) {\n          var _a;\n\n          return (_a = _this15.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);\n        });\n        return;\n      }\n\n      var state = this.state.apply(transaction);\n      var selectionHasChanged = !this.state.selection.eq(state.selection);\n      this.view.updateState(state);\n      this.emit('transaction', {\n        editor: this,\n        transaction: transaction\n      });\n\n      if (selectionHasChanged) {\n        this.emit('selectionUpdate', {\n          editor: this\n        });\n      }\n\n      var focus = transaction.getMeta('focus');\n      var blur = transaction.getMeta('blur');\n\n      if (focus) {\n        this.emit('focus', {\n          editor: this,\n          event: focus.event\n        });\n      }\n\n      if (blur) {\n        this.emit('blur', {\n          editor: this,\n          event: blur.event\n        });\n      }\n\n      if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n        return;\n      }\n\n      this.emit('update', {\n        editor: this,\n        transaction: transaction\n      });\n    }\n    /**\r\n     * Get attributes of the currently selected node or mark.\r\n     */\n\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes(nameOrType) {\n      return _getAttributes(this.state, nameOrType);\n    }\n    /**\r\n     * Get attributes of the currently selected node.\r\n     *\r\n     * @param name Name of the node\r\n     */\n\n  }, {\n    key: \"getNodeAttributes\",\n    value: function getNodeAttributes(name) {\n      console.warn('[tiptap warn]: editor.getNodeAttributes() is deprecated. please use editor.getAttributes() instead.');\n      return _getNodeAttributes(this.state, name);\n    }\n    /**\r\n     * Get attributes of the currently selected mark.\r\n     *\r\n     * @param name Name of the mark\r\n     */\n\n  }, {\n    key: \"getMarkAttributes\",\n    value: function getMarkAttributes(name) {\n      console.warn('[tiptap warn]: editor.getMarkAttributes() is deprecated. please use editor.getAttributes() instead.');\n      return _getMarkAttributes(this.state, name);\n    }\n  }, {\n    key: \"isActive\",\n    value: function isActive(nameOrAttributes, attributesOrUndefined) {\n      var name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null;\n      var attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes;\n      return _isActive(this.state, name, attributes);\n    }\n    /**\r\n     * Get the document as JSON.\r\n     */\n\n  }, {\n    key: \"getJSON\",\n    value: function getJSON() {\n      return this.state.doc.toJSON();\n    }\n    /**\r\n     * Get the document as HTML.\r\n     */\n\n  }, {\n    key: \"getHTML\",\n    value: function getHTML() {\n      return getHTMLFromFragment(this.state.doc, this.schema);\n    }\n    /**\r\n     * Check if there is no content.\r\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return isNodeEmpty(this.state.doc);\n    }\n    /**\r\n     * Get the number of characters for the current document.\r\n     */\n\n  }, {\n    key: \"getCharacterCount\",\n    value: function getCharacterCount() {\n      return this.state.doc.content.size - 2;\n    }\n    /**\r\n     * Destroy the editor.\r\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.emit('destroy');\n\n      if (this.view) {\n        this.view.destroy();\n      }\n\n      this.removeAllListeners();\n      removeElement(this.css);\n    }\n    /**\r\n     * Check if the editor is already destroyed.\r\n     */\n\n  }, {\n    key: \"isDestroyed\",\n    get: function get() {\n      var _a; // @ts-ignore\n\n\n      return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n    }\n  }]);\n\n  return Editor;\n}(EventEmitter);\n\nvar Node = /*#__PURE__*/function () {\n  function Node() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Node);\n\n    this.type = 'node';\n    this.name = 'node';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = _objectSpread(_objectSpread({}, this.config), config);\n    this.name = this.config.name;\n    this.options = this.config.defaultOptions;\n  }\n\n  _createClass(Node, [{\n    key: \"configure\",\n    value: function configure() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // return a new instance so we can use the same extension\n      // with different calls of `configure`\n      var extension = this.extend();\n      extension.options = mergeDeep(this.options, options);\n      return extension;\n    }\n  }, {\n    key: \"extend\",\n    value: function extend() {\n      var extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var extension = new Node(extendedConfig);\n      extension.parent = this;\n      this.child = extension;\n      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n      extension.options = extendedConfig.defaultOptions ? extendedConfig.defaultOptions : extension.parent.options;\n      return extension;\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new Node(config);\n    }\n  }]);\n\n  return Node;\n}();\n\nvar Mark = /*#__PURE__*/function () {\n  function Mark() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Mark);\n\n    this.type = 'mark';\n    this.name = 'mark';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = _objectSpread(_objectSpread({}, this.config), config);\n    this.name = this.config.name;\n    this.options = this.config.defaultOptions;\n  }\n\n  _createClass(Mark, [{\n    key: \"configure\",\n    value: function configure() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // return a new instance so we can use the same extension\n      // with different calls of `configure`\n      var extension = this.extend();\n      extension.options = mergeDeep(this.options, options);\n      return extension;\n    }\n  }, {\n    key: \"extend\",\n    value: function extend() {\n      var extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var extension = new Mark(extendedConfig);\n      extension.parent = this;\n      this.child = extension;\n      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n      extension.options = extendedConfig.defaultOptions ? extendedConfig.defaultOptions : extension.parent.options;\n      return extension;\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new Mark(config);\n    }\n  }]);\n\n  return Mark;\n}();\n\nfunction isiOS() {\n  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform) // iPad on iOS 13 detection\n  || navigator.userAgent.includes('Mac') && 'ontouchend' in document;\n}\n\nvar NodeView = /*#__PURE__*/function () {\n  function NodeView(component, props, options) {\n    _classCallCheck(this, NodeView);\n\n    this.isDragging = false;\n    this.options = {\n      stopEvent: null,\n      update: null\n    };\n    this.component = component;\n    this.options = _objectSpread(_objectSpread({}, this.options), options);\n    this.editor = props.editor;\n    this.extension = props.extension;\n    this.node = props.node;\n    this.decorations = props.decorations;\n    this.getPos = props.getPos;\n    this.mount();\n  }\n\n  _createClass(NodeView, [{\n    key: \"mount\",\n    value: function mount() {\n      // eslint-disable-next-line\n      return;\n    }\n  }, {\n    key: \"dom\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"contentDOM\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"onDragStart\",\n    value: function onDragStart(event) {\n      var _a, _b, _c;\n\n      var view = this.editor.view;\n      var target = event.target; // get the drag handle element\n      // `closest` is not available for text nodes so we may have to use its parent\n\n      var dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]') : target.closest('[data-drag-handle]');\n\n      if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n        return;\n      }\n\n      var x = 0;\n      var y = 0; // calculate offset for drag element if we use a different drag handle element\n\n      if (this.dom !== dragHandle) {\n        var domBox = this.dom.getBoundingClientRect();\n        var handleBox = dragHandle.getBoundingClientRect();\n        x = handleBox.x - domBox.x + event.offsetX;\n        y = handleBox.y - domBox.y + event.offsetY;\n      }\n\n      (_c = event.dataTransfer) === null || _c === void 0 ? void 0 : _c.setDragImage(this.dom, x, y); // we need to tell ProseMirror that we want to move the whole node\n      // so we create a NodeSelection\n\n      var selection = NodeSelection.create(view.state.doc, this.getPos());\n      var transaction = view.state.tr.setSelection(selection);\n      view.dispatch(transaction);\n    }\n  }, {\n    key: \"stopEvent\",\n    value: function stopEvent(event) {\n      var _this16 = this;\n\n      var _a;\n\n      if (!this.dom) {\n        return false;\n      }\n\n      if (typeof this.options.stopEvent === 'function') {\n        return this.options.stopEvent(event);\n      }\n\n      var target = event.target;\n      var isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target)); // any event from child nodes should be handled by ProseMirror\n\n      if (!isInElement) {\n        return false;\n      }\n\n      var isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable; // any input event within node views should be ignored by ProseMirror\n\n      if (isInput) {\n        return true;\n      }\n\n      var isEditable = this.editor.isEditable;\n      var isDragging = this.isDragging;\n      var isDraggable = !!this.node.type.spec.draggable;\n      var isSelectable = NodeSelection.isSelectable(this.node);\n      var isCopyEvent = event.type === 'copy';\n      var isPasteEvent = event.type === 'paste';\n      var isCutEvent = event.type === 'cut';\n      var isClickEvent = event.type === 'mousedown';\n      var isDragEvent = event.type.startsWith('drag') || event.type === 'drop'; // ProseMirror tries to drag selectable nodes\n      // even if `draggable` is set to `false`\n      // this fix prevents that\n\n      if (!isDraggable && isSelectable && isDragEvent) {\n        event.preventDefault();\n      }\n\n      if (isDraggable && isDragEvent && !isDragging) {\n        event.preventDefault();\n        return false;\n      } // we have to store that dragging started\n\n\n      if (isDraggable && isEditable && !isDragging && isClickEvent) {\n        var dragHandle = target.closest('[data-drag-handle]');\n        var isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n\n        if (isValidDragHandle) {\n          this.isDragging = true;\n          document.addEventListener('dragend', function () {\n            _this16.isDragging = false;\n          }, {\n            once: true\n          });\n          document.addEventListener('mouseup', function () {\n            _this16.isDragging = false;\n          }, {\n            once: true\n          });\n        }\n      } // these events are handled by prosemirror\n\n\n      if (isDragging || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"ignoreMutation\",\n    value: function ignoreMutation(mutation) {\n      if (!this.dom || !this.contentDOM) {\n        return true;\n      } // a leaf/atom node is like a black box for ProseMirror\n      // and should be fully handled by the node view\n\n\n      if (this.node.isLeaf) {\n        return true;\n      } // ProseMirror should handle any selections\n\n\n      if (mutation.type === 'selection') {\n        return false;\n      } // try to prevent a bug on iOS that will break node views on enter\n      // this is because ProseMirror canâ€™t preventDispatch on enter\n      // this will lead to a re-render of the node view on enter\n      // see: https://github.com/ueberdosis/tiptap/issues/1214\n\n\n      if (this.dom.contains(mutation.target) && mutation.type === 'childList' && isiOS()) {\n        var changedNodes = [].concat(_toConsumableArray(Array.from(mutation.addedNodes)), _toConsumableArray(Array.from(mutation.removedNodes))); // weâ€™ll check if every changed node is contentEditable\n        // to make sure itâ€™s probably mutated by ProseMirror\n\n        if (changedNodes.every(function (node) {\n          return node.isContentEditable;\n        })) {\n          return false;\n        }\n      } // we will allow mutation contentDOM with attributes\n      // so we can for example adding classes within our node view\n\n\n      if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n        return true;\n      } // ProseMirror should handle any changes within contentDOM\n\n\n      if (this.contentDOM.contains(mutation.target)) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"updateAttributes\",\n    value: function updateAttributes(attributes) {\n      if (!this.editor.view.editable) {\n        return;\n      }\n\n      var state = this.editor.view.state;\n      var pos = this.getPos();\n      var transaction = state.tr.setNodeMarkup(pos, undefined, _objectSpread(_objectSpread({}, this.node.attrs), attributes));\n      this.editor.view.dispatch(transaction);\n    }\n  }, {\n    key: \"deleteNode\",\n    value: function deleteNode() {\n      var from = this.getPos();\n      var to = from + this.node.nodeSize;\n      this.editor.commands.deleteRange({\n        from: from,\n        to: to\n      });\n    }\n  }]);\n\n  return NodeView;\n}();\n\nfunction nodeInputRule(regexp, type, getAttributes) {\n  return new InputRule(regexp, function (state, match, start, end) {\n    var attributes = getAttributes instanceof Function ? getAttributes(match) : getAttributes;\n    var tr = state.tr;\n\n    if (match[0]) {\n      tr.replaceWith(start - 1, end, type.create(attributes));\n    }\n\n    return tr;\n  });\n}\n\nfunction getMarksBetween(from, to, state) {\n  var marks = [];\n  state.doc.nodesBetween(from, to, function (node, pos) {\n    marks = [].concat(_toConsumableArray(marks), _toConsumableArray(node.marks.map(function (mark) {\n      return {\n        from: pos,\n        to: pos + node.nodeSize,\n        mark: mark\n      };\n    })));\n  });\n  return marks;\n}\n\nfunction markInputRule(regexp, markType, getAttributes) {\n  return new InputRule(regexp, function (state, match, start, end) {\n    var attributes = getAttributes instanceof Function ? getAttributes(match) : getAttributes;\n    var tr = state.tr;\n    var captureGroup = match[match.length - 1];\n    var fullMatch = match[0];\n    var markEnd = end;\n\n    if (captureGroup) {\n      var startSpaces = fullMatch.search(/\\S/);\n      var textStart = start + fullMatch.indexOf(captureGroup);\n      var textEnd = textStart + captureGroup.length;\n      var excludedMarks = getMarksBetween(start, end, state).filter(function (item) {\n        // TODO: PR to add excluded to MarkType\n        // @ts-ignore\n        var excluded = item.mark.type.excluded;\n        return excluded.find(function (type) {\n          return type.name === markType.name;\n        });\n      }).filter(function (item) {\n        return item.to > textStart;\n      });\n\n      if (excludedMarks.length) {\n        return null;\n      }\n\n      if (textEnd < end) {\n        tr.delete(textEnd, end);\n      }\n\n      if (textStart > start) {\n        tr.delete(start + startSpaces, textStart);\n      }\n\n      markEnd = start + startSpaces + captureGroup.length;\n      tr.addMark(start + startSpaces, markEnd, markType.create(attributes));\n      tr.removeStoredMark(markType);\n    }\n\n    return tr;\n  });\n}\n\nfunction markPasteRule(regexp, type, getAttributes) {\n  var handler = function handler(fragment, parent) {\n    var nodes = [];\n    fragment.forEach(function (child) {\n      if (child.isText && child.text) {\n        var text = child.text;\n        var pos = 0;\n        var match; // eslint-disable-next-line\n\n        while ((match = regexp.exec(text)) !== null) {\n          var outerMatch = Math.max(match.length - 2, 0);\n          var innerMatch = Math.max(match.length - 1, 0);\n\n          if (parent === null || parent === void 0 ? void 0 : parent.type.allowsMarkType(type)) {\n            var start = match.index;\n            var matchStart = start + match[0].indexOf(match[outerMatch]);\n            var matchEnd = matchStart + match[outerMatch].length;\n            var textStart = matchStart + match[outerMatch].lastIndexOf(match[innerMatch]);\n            var textEnd = textStart + match[innerMatch].length;\n            var attrs = getAttributes instanceof Function ? getAttributes(match) : getAttributes; // adding text before markdown to nodes\n\n            if (matchStart > 0) {\n              nodes.push(child.cut(pos, matchStart));\n            } // adding the markdown part to nodes\n\n\n            nodes.push(child.cut(textStart, textEnd).mark(type.create(attrs).addToSet(child.marks)));\n            pos = matchEnd;\n          }\n        } // adding rest of text to nodes\n\n\n        if (pos < text.length) {\n          nodes.push(child.cut(pos));\n        }\n      } else {\n        nodes.push(child.copy(handler(child.content, child)));\n      }\n    });\n    return Fragment.fromArray(nodes);\n  };\n\n  return new Plugin({\n    key: new PluginKey('markPasteRule'),\n    props: {\n      transformPasted: function transformPasted(slice) {\n        return new Slice(handler(slice.content), slice.openStart, slice.openEnd);\n      }\n    }\n  });\n}\n\nfunction findChildren(node, predicate) {\n  var nodesWithPos = [];\n  node.descendants(function (child, pos) {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos: pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n/**\r\n * Same as `findChildren` but searches only within a `range`.\r\n */\n\n\nfunction findChildrenInRange(node, range, predicate) {\n  var nodesWithPos = []; // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n\n  node.nodesBetween(range.from, range.to, function (child, pos) {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos: pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\nfunction getSchema(extensions) {\n  var resolvedExtensions = ExtensionManager.resolve(extensions);\n  return getSchemaByResolvedExtensions(resolvedExtensions);\n}\n\nfunction generateHTML(doc, extensions) {\n  var schema = getSchema(extensions);\n  var contentNode = Node$1.fromJSON(schema, doc);\n  return getHTMLFromFragment(contentNode, schema);\n}\n\nfunction generateJSON(html, extensions) {\n  var schema = getSchema(extensions);\n  var dom = elementFromString(html);\n  return DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\n/**\r\n * Returns a node tree with node positions.\r\n */\n\n\nfunction getDebugJSON(node) {\n  var startOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var nodes = [];\n  node.forEach(function (n, offset) {\n    var from = startOffset + offset;\n    var to = from + n.nodeSize;\n    var marks = n.marks.map(function (mark) {\n      return {\n        type: mark.type.name,\n        attrs: _objectSpread({}, mark.attrs)\n      };\n    });\n\n    var attrs = _objectSpread({}, n.attrs);\n\n    var content = getDebugJSON(n, from + 1);\n    var output = {\n      type: n.type.name,\n      from: from,\n      to: to\n    };\n\n    if (Object.keys(attrs).length) {\n      output.attrs = attrs;\n    }\n\n    if (marks.length) {\n      output.marks = marks;\n    }\n\n    if (content.length) {\n      output.content = content;\n    }\n\n    if (n.text) {\n      output.text = n.text;\n    }\n\n    nodes.push(output);\n  });\n  return nodes;\n}\n\nfunction isNodeSelection(value) {\n  return isObject(value) && value instanceof NodeSelection;\n}\n\nfunction posToDOMRect(view, from, to) {\n  var start = view.coordsAtPos(from);\n  var end = view.coordsAtPos(to, -1);\n  var top = Math.min(start.top, end.top);\n  var bottom = Math.max(start.bottom, end.bottom);\n  var left = Math.min(start.left, end.left);\n  var right = Math.max(start.right, end.right);\n  var width = right - left;\n  var height = bottom - top;\n  var x = left;\n  var y = top;\n  var data = {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right,\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n  return _objectSpread(_objectSpread({}, data), {}, {\n    toJSON: function toJSON() {\n      return data;\n    }\n  });\n}\n\nexport { Editor, Extension, Mark, Node, NodeView, callOrReturn, extensions, findChildren, findChildrenInRange, findParentNode, findParentNodeClosestToPos, generateHTML, generateJSON, _getAttributes as getAttributes, getDebugJSON, getExtensionField, getHTMLFromFragment, _getMarkAttributes as getMarkAttributes, getMarkRange, getMarkType, getMarksBetween, _getNodeAttributes as getNodeAttributes, getNodeType, getSchema, _isActive as isActive, isList, isMarkActive, isNodeActive, isNodeEmpty, isNodeSelection, isTextSelection, markInputRule, markPasteRule, mergeAttributes, nodeInputRule, posToDOMRect };","map":{"version":3,"sources":["../src/helpers/getSchemaTypeNameByName.ts","../src/helpers/getNodeType.ts","../src/helpers/getNodeAttributes.ts","../src/helpers/getMarkType.ts","../src/helpers/getMarkAttributes.ts","../src/helpers/getAttributes.ts","../src/utilities/objectIncludes.ts","../src/helpers/isNodeActive.ts","../src/helpers/isMarkActive.ts","../src/helpers/isActive.ts","../src/utilities/removeElement.ts","../src/utilities/elementFromString.ts","../src/helpers/createNodeFromContent.ts","../src/helpers/createDocument.ts","../src/helpers/getHTMLFromFragment.ts","../src/helpers/isNodeEmpty.ts","../src/utilities/createStyleTag.ts","../src/CommandManager.ts","../src/helpers/getExtensionField.ts","../src/helpers/splitExtensions.ts","../src/helpers/getAttributesFromExtensions.ts","../src/utilities/mergeAttributes.ts","../src/helpers/getRenderedAttributes.ts","../src/utilities/isEmptyObject.ts","../src/utilities/fromString.ts","../src/helpers/injectExtensionAttributesToParseRule.ts","../src/utilities/callOrReturn.ts","../src/helpers/getSchemaByResolvedExtensions.ts","../src/helpers/getSchemaTypeByName.ts","../src/ExtensionManager.ts","../src/EventEmitter.ts","../src/utilities/isPlainObject.ts","../src/utilities/mergeDeep.ts","../src/Extension.ts","../src/extensions/clipboardTextSerializer.ts","../src/commands/blur.ts","../src/commands/clearContent.ts","../src/commands/clearNodes.ts","../src/commands/command.ts","../src/commands/createParagraphNear.ts","../src/commands/deleteRange.ts","../src/commands/deleteSelection.ts","../src/commands/enter.ts","../src/commands/exitCode.ts","../src/helpers/getMarkRange.ts","../src/commands/extendMarkRange.ts","../src/commands/first.ts","../src/utilities/minMax.ts","../src/utilities/isClass.ts","../src/utilities/isObject.ts","../src/helpers/isTextSelection.ts","../src/commands/focus.ts","../src/commands/insertContent.ts","../src/helpers/selectionToInsertionEnd.ts","../src/commands/insertContentAt.ts","../src/commands/joinBackward.ts","../src/commands/joinForward.ts","../src/commands/keyboardShortcut.ts","../src/commands/lift.ts","../src/commands/liftEmptyBlock.ts","../src/commands/liftListItem.ts","../src/commands/newlineInCode.ts","../src/commands/replace.ts","../src/commands/replaceRange.ts","../src/utilities/deleteProps.ts","../src/commands/resetAttributes.ts","../src/commands/scrollIntoView.ts","../src/commands/selectAll.ts","../src/commands/selectNodeBackward.ts","../src/commands/selectNodeForward.ts","../src/commands/selectParentNode.ts","../src/commands/setContent.ts","../src/commands/setMark.ts","../src/commands/setMeta.ts","../src/commands/setNode.ts","../src/commands/setNodeSelection.ts","../src/commands/setTextSelection.ts","../src/commands/sinkListItem.ts","../src/helpers/getSplittedAttributes.ts","../src/commands/splitBlock.ts","../src/commands/splitListItem.ts","../src/helpers/findParentNodeClosestToPos.ts","../src/helpers/findParentNode.ts","../src/helpers/isList.ts","../src/commands/toggleList.ts","../src/commands/toggleMark.ts","../src/commands/toggleNode.ts","../src/commands/toggleWrap.ts","../src/commands/undoInputRule.ts","../src/commands/unsetAllMarks.ts","../src/commands/unsetMark.ts","../src/commands/updateAttributes.ts","../src/commands/wrapIn.ts","../src/commands/wrapInList.ts","../src/extensions/commands.ts","../src/extensions/editable.ts","../src/extensions/focusEvents.ts","../src/extensions/keymap.ts","../src/style.ts","../src/Editor.ts","../src/Node.ts","../src/Mark.ts","../src/utilities/isiOS.ts","../src/NodeView.ts","../src/inputRules/nodeInputRule.ts","../src/helpers/getMarksBetween.ts","../src/inputRules/markInputRule.ts","../src/pasteRules/markPasteRule.ts","../src/helpers/findChildren.ts","../src/helpers/findChildrenInRange.ts","../src/helpers/getSchema.ts","../src/helpers/generateHTML.ts","../src/helpers/generateJSON.ts","../src/helpers/getDebugJSON.ts","../src/helpers/isNodeSelection.ts","../src/helpers/posToDOMRect.ts"],"names":["inputRules","inputRulesPlugin","originalCreateParagraphNear","originalDeleteSelection","originalExitCode","originalJoinBackward","originalJoinForward","originalLift","originalLiftEmptyBlock","originalLiftListItem","originalNewlineInCode","originalSelectAll","originalSelectNodeBackward","originalSelectNodeForward","originalSelectParentNode","originalSinkListItem","lift","wrapIn","originalUndoInputRule","originalWrapIn","originalWrapInList","blur","clearContent","clearNodes","command","createParagraphNear","deleteRange","deleteSelection","enter","exitCode","extendMarkRange","first","focus","insertContent","insertContentAt","joinBackward","joinForward","keyboardShortcut","liftEmptyBlock","liftListItem","newlineInCode","replace","replaceRange","resetAttributes","scrollIntoView","selectAll","selectNodeBackward","selectNodeForward","selectParentNode","setContent","setMark","setMeta","setNode","setNodeSelection","setTextSelection","sinkListItem","splitBlock","splitListItem","toggleList","toggleMark","toggleNode","toggleWrap","undoInputRule","unsetAllMarks","unsetMark","updateAttributes","wrapInList","Node"],"mappings":"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","sourcesContent":["import { Schema } from 'prosemirror-model'\n\nexport default function getSchemaTypeNameByName(name: string, schema: Schema): 'node' | 'mark' | null {\n  if (schema.nodes[name]) {\n    return 'node'\n  }\n\n  if (schema.marks[name]) {\n    return 'mark'\n  }\n\n  return null\n}\n","import { NodeType, Schema } from 'prosemirror-model'\n\nexport default function getNodeType(nameOrType: string | NodeType, schema: Schema): NodeType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`)\n    }\n\n    return schema.nodes[nameOrType]\n  }\n\n  return nameOrType\n}\n","import { EditorState } from 'prosemirror-state'\nimport { Node, NodeType } from 'prosemirror-model'\nimport getNodeType from './getNodeType'\n\nexport default function getNodeAttributes(state: EditorState, typeOrName: string | NodeType): Record<string, any> {\n  const type = getNodeType(typeOrName, state.schema)\n  const { from, to } = state.selection\n  let nodes: Node[] = []\n\n  state.doc.nodesBetween(from, to, node => {\n    nodes = [...nodes, node]\n  })\n\n  const node = nodes\n    .reverse()\n    .find(nodeItem => nodeItem.type.name === type.name)\n\n  if (node) {\n    return { ...node.attrs }\n  }\n\n  return {}\n}\n","import { MarkType, Schema } from 'prosemirror-model'\n\nexport default function getMarkType(nameOrType: string | MarkType, schema: Schema): MarkType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`)\n    }\n\n    return schema.marks[nameOrType]\n  }\n\n  return nameOrType\n}\n","import { EditorState } from 'prosemirror-state'\nimport { Mark, MarkType } from 'prosemirror-model'\nimport getMarkType from './getMarkType'\n\nexport default function getMarkAttributes(state: EditorState, typeOrName: string | MarkType): Record<string, any> {\n  const type = getMarkType(typeOrName, state.schema)\n  const { from, to, empty } = state.selection\n  let marks: Mark[] = []\n\n  if (empty) {\n    marks = state.selection.$head.marks()\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks = [...marks, ...node.marks]\n    })\n  }\n\n  const mark = marks.find(markItem => markItem.type.name === type.name)\n\n  if (mark) {\n    return { ...mark.attrs }\n  }\n\n  return {}\n}\n","import { MarkType, NodeType } from 'prosemirror-model'\nimport { EditorState } from 'prosemirror-state'\nimport getSchemaTypeNameByName from './getSchemaTypeNameByName'\nimport getNodeAttributes from './getNodeAttributes'\nimport getMarkAttributes from './getMarkAttributes'\n\nexport default function getAttributes(\n  state: EditorState,\n  typeOrName: string | NodeType | MarkType,\n): Record<string, any> {\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string'\n      ? typeOrName\n      : typeOrName.name,\n    state.schema,\n  )\n\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName as NodeType)\n  }\n\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName as MarkType)\n  }\n\n  return {}\n}\n","/**\n * Check if object1 includes object2\n * @param object1 Object\n * @param object2 Object\n */\nexport default function objectIncludes(object1: Record<string, any>, object2: Record<string, any>): boolean {\n  const keys = Object.keys(object2)\n\n  if (!keys.length) {\n    return true\n  }\n\n  return !!keys\n    .filter(key => object2[key] === object1[key])\n    .length\n}\n","import { EditorState } from 'prosemirror-state'\nimport { NodeType } from 'prosemirror-model'\nimport objectIncludes from '../utilities/objectIncludes'\nimport getNodeType from './getNodeType'\nimport { NodeRange } from '../types'\n\nexport default function isNodeActive(\n  state: EditorState,\n  typeOrName: NodeType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { from, to, empty } = state.selection\n  const type = typeOrName\n    ? getNodeType(typeOrName, state.schema)\n    : null\n\n  let nodeRanges: NodeRange[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isText) {\n      const relativeFrom = Math.max(from, pos)\n      const relativeTo = Math.min(to, pos + node.nodeSize)\n\n      nodeRanges = [...nodeRanges, {\n        node,\n        from: relativeFrom,\n        to: relativeTo,\n      }]\n    }\n  })\n\n  if (empty) {\n    return !!nodeRanges\n      .filter(nodeRange => {\n        if (!type) {\n          return true\n        }\n\n        return type.name === nodeRange.node.type.name\n      })\n      .find(nodeRange => objectIncludes(nodeRange.node.attrs, attributes))\n  }\n\n  const selectionRange = to - from\n\n  const range = nodeRanges\n    .filter(nodeRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === nodeRange.node.type.name\n    })\n    .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes))\n    .reduce((sum, nodeRange) => {\n      const size = nodeRange.to - nodeRange.from\n      return sum + size\n    }, 0)\n\n  return range >= selectionRange\n}\n","import { EditorState } from 'prosemirror-state'\nimport { MarkType } from 'prosemirror-model'\nimport objectIncludes from '../utilities/objectIncludes'\nimport getMarkType from './getMarkType'\nimport { MarkRange } from '../types'\n\nexport default function isMarkActive(\n  state: EditorState,\n  typeOrName: MarkType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { from, to, empty } = state.selection\n  const type = typeOrName\n    ? getMarkType(typeOrName, state.schema)\n    : null\n\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks())\n      .filter(mark => {\n        if (!type) {\n          return true\n        }\n\n        return type.name === mark.type.name\n      })\n      .find(mark => objectIncludes(mark.attrs, attributes))\n  }\n\n  let selectionRange = 0\n  let markRanges: MarkRange[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      const relativeFrom = Math.max(from, pos)\n      const relativeTo = Math.min(to, pos + node.nodeSize)\n      const range = relativeTo - relativeFrom\n\n      selectionRange += range\n\n      markRanges = [...markRanges, ...node.marks.map(mark => ({\n        mark,\n        from: relativeFrom,\n        to: relativeTo,\n      }))]\n    }\n  })\n\n  if (selectionRange === 0) {\n    return false\n  }\n\n  // calculate range of matched mark\n  const matchedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === markRange.mark.type.name\n    })\n    .filter(markRange => objectIncludes(markRange.mark.attrs, attributes))\n    .reduce((sum, markRange) => {\n      const size = markRange.to - markRange.from\n\n      return sum + size\n    }, 0)\n\n  // calculate range of marks that excludes the searched mark\n  // for example `code` doesnâ€™t allow any other marks\n  const excludedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return markRange.mark.type !== type\n        && markRange.mark.type.excludes(type)\n    })\n    .reduce((sum, markRange) => {\n      const size = markRange.to - markRange.from\n\n      return sum + size\n    }, 0)\n\n  // we only include the result of `excludedRange`\n  // if there is a match at all\n  const range = matchedRange > 0\n    ? matchedRange + excludedRange\n    : matchedRange\n\n  return range >= selectionRange\n}\n","import { EditorState } from 'prosemirror-state'\nimport isNodeActive from './isNodeActive'\nimport isMarkActive from './isMarkActive'\nimport getSchemaTypeNameByName from './getSchemaTypeNameByName'\n\nexport default function isActive(state: EditorState, name: string | null, attributes: Record<string, any> = {}): boolean {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes)\n  }\n\n  const schemaType = getSchemaTypeNameByName(name, state.schema)\n\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes)\n  }\n\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes)\n  }\n\n  return false\n}\n","export default function removeElement(element: HTMLElement): void {\n  if (element && element.parentNode) {\n    element.parentNode.removeChild(element)\n  }\n}\n","export default function elementFromString(value: string): HTMLElement {\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = `<body>${value}</body>`\n\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body\n}\n","import {\n  Schema,\n  DOMParser,\n  Node as ProseMirrorNode,\n  Fragment,\n  ParseOptions,\n} from 'prosemirror-model'\nimport elementFromString from '../utilities/elementFromString'\nimport { Content } from '../types'\n\nexport type CreateNodeFromContentOptions = {\n  slice?: boolean,\n  parseOptions?: ParseOptions,\n}\n\nexport default function createNodeFromContent(\n  content: Content,\n  schema: Schema,\n  options?: CreateNodeFromContentOptions,\n): ProseMirrorNode | Fragment {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options,\n  }\n\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content)) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)))\n      }\n\n      return schema.nodeFromJSON(content)\n    } catch (error) {\n      console.warn(\n        '[tiptap warn]: Invalid content.',\n        'Passed value:',\n        content,\n        'Error:',\n        error,\n      )\n\n      return createNodeFromContent('', schema, options)\n    }\n  }\n\n  if (typeof content === 'string') {\n    const parser = DOMParser.fromSchema(schema)\n\n    return options.slice\n      ? parser.parseSlice(elementFromString(content), options.parseOptions).content\n      : parser.parse(elementFromString(content), options.parseOptions)\n  }\n\n  return createNodeFromContent('', schema, options)\n}\n","import { Schema, Node as ProseMirrorNode, ParseOptions } from 'prosemirror-model'\nimport { Content } from '../types'\nimport createNodeFromContent from './createNodeFromContent'\n\nexport default function createDocument(\n  content: Content,\n  schema: Schema,\n  parseOptions: ParseOptions = {},\n): ProseMirrorNode {\n  return createNodeFromContent(content, schema, { slice: false, parseOptions }) as ProseMirrorNode\n}\n","import { Node, DOMSerializer, Schema } from 'prosemirror-model'\n\nexport default function getHTMLFromFragment(doc: Node, schema: Schema): string {\n  const fragment = DOMSerializer\n    .fromSchema(schema)\n    .serializeFragment(doc.content)\n\n  const temporaryDocument = document.implementation.createHTMLDocument()\n  const container = temporaryDocument.createElement('div')\n  container.appendChild(fragment)\n\n  return container.innerHTML\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\n\nexport default function isNodeEmpty(node: ProseMirrorNode): boolean {\n  const defaultContent = node.type.createAndFill()?.toJSON()\n  const content = node.toJSON()\n\n  return JSON.stringify(defaultContent) === JSON.stringify(content)\n}\n","export default function createStyleTag(style: string): HTMLStyleElement {\n  const tipTapStyleTag = (<HTMLStyleElement>document.querySelector('style[data-tiptap-style]'))\n\n  if (tipTapStyleTag !== null) {\n    return tipTapStyleTag\n  }\n\n  const styleNode = document.createElement('style')\n\n  styleNode.setAttribute('data-tiptap-style', '')\n  styleNode.innerHTML = style\n  document.getElementsByTagName('head')[0].appendChild(styleNode)\n\n  return styleNode\n}\n","import { EditorState, Transaction } from 'prosemirror-state'\nimport { Editor } from './Editor'\nimport {\n  SingleCommands,\n  ChainedCommands,\n  CanCommands,\n  RawCommands,\n  CommandProps,\n} from './types'\n\nexport default class CommandManager {\n\n  editor: Editor\n\n  commands: RawCommands\n\n  constructor(editor: Editor, commands: RawCommands) {\n    this.editor = editor\n    this.commands = commands\n  }\n\n  public createCommands(): SingleCommands {\n    const { commands, editor } = this\n    const { state, view } = editor\n    const { tr } = state\n    const props = this.buildProps(tr)\n\n    return Object.fromEntries(Object\n      .entries(commands)\n      .map(([name, command]) => {\n        const method = (...args: never[]) => {\n          const callback = command(...args)(props)\n\n          if (!tr.getMeta('preventDispatch')) {\n            view.dispatch(tr)\n          }\n\n          return callback\n        }\n\n        return [name, method]\n      })) as SingleCommands\n  }\n\n  public createChain(startTr?: Transaction, shouldDispatch = true): ChainedCommands {\n    const { commands, editor } = this\n    const { state, view } = editor\n    const callbacks: boolean[] = []\n    const hasStartTransaction = !!startTr\n    const tr = startTr || state.tr\n\n    const run = () => {\n      if (!hasStartTransaction && shouldDispatch && !tr.getMeta('preventDispatch')) {\n        view.dispatch(tr)\n      }\n\n      return callbacks.every(callback => callback === true)\n    }\n\n    const chain = {\n      ...Object.fromEntries(Object.entries(commands).map(([name, command]) => {\n        const chainedCommand = (...args: never[]) => {\n          const props = this.buildProps(tr, shouldDispatch)\n          const callback = command(...args)(props)\n\n          callbacks.push(callback)\n\n          return chain\n        }\n\n        return [name, chainedCommand]\n      })),\n      run,\n    } as unknown as ChainedCommands\n\n    return chain\n  }\n\n  public createCan(startTr?: Transaction): CanCommands {\n    const { commands, editor } = this\n    const { state } = editor\n    const dispatch = undefined\n    const tr = startTr || state.tr\n    const props = this.buildProps(tr, dispatch)\n    const formattedCommands = Object.fromEntries(Object\n      .entries(commands)\n      .map(([name, command]) => {\n        return [name, (...args: never[]) => command(...args)({ ...props, dispatch })]\n      })) as SingleCommands\n\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch),\n    } as CanCommands\n  }\n\n  public buildProps(tr: Transaction, shouldDispatch = true): CommandProps {\n    const { editor, commands } = this\n    const { state, view } = editor\n\n    if (state.storedMarks) {\n      tr.setStoredMarks(state.storedMarks)\n    }\n\n    const props: CommandProps = {\n      tr,\n      editor,\n      view,\n      state: this.chainableState(tr, state),\n      dispatch: shouldDispatch\n        ? () => undefined\n        : undefined,\n      chain: () => this.createChain(tr),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(Object\n          .entries(commands)\n          .map(([name, command]) => {\n            return [name, (...args: never[]) => command(...args)(props)]\n          })) as SingleCommands\n      },\n    }\n\n    return props\n  }\n\n  public chainableState(tr: Transaction, state: EditorState): EditorState {\n    let { selection } = tr\n    let { doc } = tr\n    let { storedMarks } = tr\n\n    return {\n      ...state,\n      schema: state.schema,\n      plugins: state.plugins,\n      apply: state.apply.bind(state),\n      applyTransaction: state.applyTransaction.bind(state),\n      reconfigure: state.reconfigure.bind(state),\n      toJSON: state.toJSON.bind(state),\n      get storedMarks() {\n        return storedMarks\n      },\n      get selection() {\n        return selection\n      },\n      get doc() {\n        return doc\n      },\n      get tr() {\n        selection = tr.selection\n        doc = tr.doc\n        storedMarks = tr.storedMarks\n\n        return tr\n      },\n    }\n  }\n\n}\n","import { AnyExtension, RemoveThis } from '../types'\n\nexport default function getExtensionField<T = any>(\n  extension: AnyExtension,\n  field: string,\n  context: Record<string, any> = {},\n): RemoveThis<T> {\n\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context)\n  }\n\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent\n        ? getExtensionField(extension.parent, field, context)\n        : null,\n    })\n\n    return value\n  }\n\n  return extension.config[field]\n}\n","import { Extensions } from '../types'\nimport { Extension } from '../Extension'\nimport { Node } from '../Node'\nimport { Mark } from '../Mark'\n\nexport default function splitExtensions(extensions: Extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension') as Extension[]\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node') as Node[]\n  const markExtensions = extensions.filter(extension => extension.type === 'mark') as Mark[]\n\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions,\n  }\n}\n","import splitExtensions from './splitExtensions'\nimport getExtensionField from './getExtensionField'\nimport {\n  Extensions,\n  GlobalAttributes,\n  Attributes,\n  Attribute,\n  ExtensionAttribute,\n  AnyConfig,\n} from '../types'\nimport { NodeConfig, MarkConfig } from '..'\n\n/**\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\n * @param extensions List of extensions\n */\nexport default function getAttributesFromExtensions(extensions: Extensions): ExtensionAttribute[] {\n  const extensionAttributes: ExtensionAttribute[] = []\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions]\n  const defaultAttribute: Required<Attribute> = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n  }\n\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n    }\n\n    const addGlobalAttributes = getExtensionField<AnyConfig['addGlobalAttributes']>(\n      extension,\n      'addGlobalAttributes',\n      context,\n    )\n\n    if (!addGlobalAttributes) {\n      return\n    }\n\n    // TODO: remove `as GlobalAttributes`\n    const globalAttributes = addGlobalAttributes() as GlobalAttributes\n\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object\n          .entries(globalAttribute.attributes)\n          .forEach(([name, attribute]) => {\n            extensionAttributes.push({\n              type,\n              name,\n              attribute: {\n                ...defaultAttribute,\n                ...attribute,\n              },\n            })\n          })\n      })\n    })\n  })\n\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n    }\n\n    const addAttributes = getExtensionField<NodeConfig['addAttributes'] | MarkConfig['addAttributes']>(\n      extension,\n      'addAttributes',\n      context,\n    )\n\n    if (!addAttributes) {\n      return\n    }\n\n    // TODO: remove `as Attributes`\n    const attributes = addAttributes() as Attributes\n\n    Object\n      .entries(attributes)\n      .forEach(([name, attribute]) => {\n        extensionAttributes.push({\n          type: extension.name,\n          name,\n          attribute: {\n            ...defaultAttribute,\n            ...attribute,\n          },\n        })\n      })\n  })\n\n  return extensionAttributes\n}\n","export default function mergeAttributes(...objects: Record<string, any>[]): Record<string, any> {\n  return objects\n    .filter(item => !!item)\n    .reduce((items, item) => {\n      const mergedAttributes = { ...items }\n\n      Object.entries(item).forEach(([key, value]) => {\n        const exists = mergedAttributes[key]\n\n        if (!exists) {\n          mergedAttributes[key] = value\n          return\n        }\n\n        if (key === 'class') {\n          mergedAttributes[key] = [mergedAttributes[key], value].join(' ')\n        } else if (key === 'style') {\n          mergedAttributes[key] = [mergedAttributes[key], value].join('; ')\n        } else {\n          mergedAttributes[key] = value\n        }\n      })\n\n      return mergedAttributes\n    }, {})\n}\n","import { Node, Mark } from 'prosemirror-model'\nimport { ExtensionAttribute } from '../types'\nimport mergeAttributes from '../utilities/mergeAttributes'\n\nexport default function getRenderedAttributes(nodeOrMark: Node | Mark, extensionAttributes: ExtensionAttribute[]): Record<string, any> {\n  return extensionAttributes\n    .filter(item => item.attribute.rendered)\n    .map(item => {\n      if (!item.attribute.renderHTML) {\n        return {\n          [item.name]: nodeOrMark.attrs[item.name],\n        }\n      }\n\n      return item.attribute.renderHTML(nodeOrMark.attrs) || {}\n    })\n    .reduce((attributes, attribute) => {\n      return mergeAttributes(attributes, attribute)\n    }, {})\n}\n","export default function isEmptyObject(object = {}): boolean {\n  return Object.keys(object).length === 0 && object.constructor === Object\n}\n","export default function fromString(value: any): any {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  if (value.match(/^\\d*(\\.\\d+)?$/)) {\n    return Number(value)\n  }\n\n  if (value === 'true') {\n    return true\n  }\n\n  if (value === 'false') {\n    return false\n  }\n\n  return value\n}\n","import { ParseRule } from 'prosemirror-model'\nimport { ExtensionAttribute } from '../types'\nimport fromString from '../utilities/fromString'\n\n/**\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\n * Cancels when `getAttrs` returned `false`.\n * @param parseRule ProseMirror ParseRule\n * @param extensionAttributes List of attributes to inject\n */\nexport default function injectExtensionAttributesToParseRule(parseRule: ParseRule, extensionAttributes: ExtensionAttribute[]): ParseRule {\n  if (parseRule.style) {\n    return parseRule\n  }\n\n  return {\n    ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs\n        ? parseRule.getAttrs(node)\n        : parseRule.attrs\n\n      if (oldAttributes === false) {\n        return false\n      }\n\n      const newAttributes = extensionAttributes\n        .filter(item => item.attribute.rendered)\n        .reduce((items, item) => {\n          const attributes = item.attribute.parseHTML\n            ? item.attribute.parseHTML(node as HTMLElement) || {}\n            : {\n              [item.name]: fromString((node as HTMLElement).getAttribute(item.name)),\n            }\n\n          const filteredAttributes = Object.fromEntries(Object.entries(attributes)\n            .filter(([, value]) => value !== undefined && value !== null))\n\n          return {\n            ...items,\n            ...filteredAttributes,\n          }\n        }, {})\n\n      return { ...oldAttributes, ...newAttributes }\n    },\n  }\n}\n","import { MaybeReturnType } from '../types'\n\n/**\n * Optionally calls `value` as a function.\n * Otherwise it is returned directly.\n * @param value Function or any value.\n * @param context Optional context to bind to function.\n * @param props Optional props to pass to function.\n */\nexport default function callOrReturn<T>(value: T, context: any = undefined, ...props: any[]): MaybeReturnType<T> {\n  if (typeof value === 'function') {\n    if (context) {\n      return value.bind(context)(...props)\n    }\n\n    return value(...props)\n  }\n\n  return value as MaybeReturnType<T>\n}\n","import { NodeSpec, MarkSpec, Schema } from 'prosemirror-model'\nimport { AnyConfig, Extensions } from '../types'\nimport { NodeConfig, MarkConfig } from '..'\nimport splitExtensions from './splitExtensions'\nimport getAttributesFromExtensions from './getAttributesFromExtensions'\nimport getRenderedAttributes from './getRenderedAttributes'\nimport isEmptyObject from '../utilities/isEmptyObject'\nimport injectExtensionAttributesToParseRule from './injectExtensionAttributesToParseRule'\nimport callOrReturn from '../utilities/callOrReturn'\nimport getExtensionField from './getExtensionField'\n\nfunction cleanUpSchemaItem<T>(data: T) {\n  return Object.fromEntries(Object.entries(data).filter(([key, value]) => {\n    if (key === 'attrs' && isEmptyObject(value)) {\n      return false\n    }\n\n    return value !== null && value !== undefined\n  })) as T\n}\n\nexport default function getSchemaByResolvedExtensions(extensions: Extensions): Schema {\n  const allAttributes = getAttributesFromExtensions(extensions)\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const topNode = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))?.name\n\n  const nodes = Object.fromEntries(nodeExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name)\n    const context = {\n      name: extension.name,\n      options: extension.options,\n    }\n\n    const extraNodeFields = extensions.reduce((fields, e) => {\n      const extendNodeSchema = getExtensionField<AnyConfig['extendNodeSchema']>(\n        e,\n        'extendNodeSchema',\n        context,\n      )\n\n      return {\n        ...fields,\n        ...(extendNodeSchema ? extendNodeSchema(extension) : {}),\n      }\n    }, {})\n\n    const schema: NodeSpec = cleanUpSchemaItem({\n      ...extraNodeFields,\n      content: callOrReturn(getExtensionField<NodeConfig['content']>(extension, 'content', context)),\n      marks: callOrReturn(getExtensionField<NodeConfig['marks']>(extension, 'marks', context)),\n      group: callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context)),\n      inline: callOrReturn(getExtensionField<NodeConfig['inline']>(extension, 'inline', context)),\n      atom: callOrReturn(getExtensionField<NodeConfig['atom']>(extension, 'atom', context)),\n      selectable: callOrReturn(getExtensionField<NodeConfig['selectable']>(extension, 'selectable', context)),\n      draggable: callOrReturn(getExtensionField<NodeConfig['draggable']>(extension, 'draggable', context)),\n      code: callOrReturn(getExtensionField<NodeConfig['code']>(extension, 'code', context)),\n      defining: callOrReturn(getExtensionField<NodeConfig['defining']>(extension, 'defining', context)),\n      isolating: callOrReturn(getExtensionField<NodeConfig['isolating']>(extension, 'isolating', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n      })),\n    })\n\n    const parseHTML = callOrReturn(getExtensionField<NodeConfig['parseHTML']>(extension, 'parseHTML', context))\n\n    if (parseHTML) {\n      schema.parseDOM = parseHTML\n        .map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n    }\n\n    const renderHTML = getExtensionField<NodeConfig['renderHTML']>(extension, 'renderHTML', context)\n\n    if (renderHTML) {\n      schema.toDOM = node => renderHTML({\n        node,\n        HTMLAttributes: getRenderedAttributes(node, extensionAttributes),\n      })\n    }\n\n    return [extension.name, schema]\n  }))\n\n  const marks = Object.fromEntries(markExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name)\n    const context = {\n      name: extension.name,\n      options: extension.options,\n    }\n\n    const extraMarkFields = extensions.reduce((fields, e) => {\n      const extendMarkSchema = getExtensionField<AnyConfig['extendMarkSchema']>(\n        e,\n        'extendMarkSchema',\n        context,\n      )\n\n      return {\n        ...fields,\n        ...(extendMarkSchema ? extendMarkSchema(extension) : {}),\n      }\n    }, {})\n\n    const schema: MarkSpec = cleanUpSchemaItem({\n      ...extraMarkFields,\n      inclusive: callOrReturn(getExtensionField<NodeConfig['inclusive']>(extension, 'inclusive', context)),\n      excludes: callOrReturn(getExtensionField<NodeConfig['excludes']>(extension, 'excludes', context)),\n      group: callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context)),\n      spanning: callOrReturn(getExtensionField<NodeConfig['spanning']>(extension, 'spanning', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n      })),\n    })\n\n    const parseHTML = callOrReturn(getExtensionField<MarkConfig['parseHTML']>(extension, 'parseHTML', context))\n\n    if (parseHTML) {\n      schema.parseDOM = parseHTML\n        .map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n    }\n\n    const renderHTML = getExtensionField<MarkConfig['renderHTML']>(extension, 'renderHTML', context)\n\n    if (renderHTML) {\n      schema.toDOM = mark => renderHTML({\n        mark,\n        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),\n      })\n    }\n\n    return [extension.name, schema]\n  }))\n\n  return new Schema({\n    topNode,\n    nodes,\n    marks,\n  })\n}\n","import { MarkType, NodeType, Schema } from 'prosemirror-model'\n\nexport default function getSchemaTypeByName(name: string, schema: Schema): NodeType | MarkType | null {\n  if (schema.nodes[name]) {\n    return schema.nodes[name]\n  }\n\n  if (schema.marks[name]) {\n    return schema.marks[name]\n  }\n\n  return null\n}\n","import { keymap } from 'prosemirror-keymap'\nimport { Schema, Node as ProsemirrorNode } from 'prosemirror-model'\nimport { inputRules as inputRulesPlugin } from 'prosemirror-inputrules'\nimport { EditorView, Decoration } from 'prosemirror-view'\nimport { Plugin } from 'prosemirror-state'\nimport { Editor } from './Editor'\nimport { Extensions, RawCommands, AnyConfig } from './types'\nimport getExtensionField from './helpers/getExtensionField'\nimport getSchemaByResolvedExtensions from './helpers/getSchemaByResolvedExtensions'\nimport getSchemaTypeByName from './helpers/getSchemaTypeByName'\nimport getNodeType from './helpers/getNodeType'\nimport splitExtensions from './helpers/splitExtensions'\nimport getAttributesFromExtensions from './helpers/getAttributesFromExtensions'\nimport getRenderedAttributes from './helpers/getRenderedAttributes'\nimport callOrReturn from './utilities/callOrReturn'\nimport { NodeConfig } from '.'\n\nexport default class ExtensionManager {\n\n  editor: Editor\n\n  schema: Schema\n\n  extensions: Extensions\n\n  splittableMarks: string[] = []\n\n  constructor(extensions: Extensions, editor: Editor) {\n    this.editor = editor\n    this.extensions = ExtensionManager.resolve(extensions)\n    this.schema = getSchemaByResolvedExtensions(this.extensions)\n\n    this.extensions.forEach(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      if (extension.type === 'mark') {\n        const keepOnSplit = callOrReturn(getExtensionField(extension, 'keepOnSplit', context)) ?? true\n\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name)\n        }\n      }\n\n      const onBeforeCreate = getExtensionField<AnyConfig['onBeforeCreate']>(\n        extension,\n        'onBeforeCreate',\n        context,\n      )\n\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate)\n      }\n\n      const onCreate = getExtensionField<AnyConfig['onCreate']>(\n        extension,\n        'onCreate',\n        context,\n      )\n\n      if (onCreate) {\n        this.editor.on('create', onCreate)\n      }\n\n      const onUpdate = getExtensionField<AnyConfig['onUpdate']>(\n        extension,\n        'onUpdate',\n        context,\n      )\n\n      if (onUpdate) {\n        this.editor.on('update', onUpdate)\n      }\n\n      const onSelectionUpdate = getExtensionField<AnyConfig['onSelectionUpdate']>(\n        extension,\n        'onSelectionUpdate',\n        context,\n      )\n\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate)\n      }\n\n      const onTransaction = getExtensionField<AnyConfig['onTransaction']>(\n        extension,\n        'onTransaction',\n        context,\n      )\n\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction)\n      }\n\n      const onFocus = getExtensionField<AnyConfig['onFocus']>(\n        extension,\n        'onFocus',\n        context,\n      )\n\n      if (onFocus) {\n        this.editor.on('focus', onFocus)\n      }\n\n      const onBlur = getExtensionField<AnyConfig['onBlur']>(\n        extension,\n        'onBlur',\n        context,\n      )\n\n      if (onBlur) {\n        this.editor.on('blur', onBlur)\n      }\n\n      const onDestroy = getExtensionField<AnyConfig['onDestroy']>(\n        extension,\n        'onDestroy',\n        context,\n      )\n\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy)\n      }\n    })\n  }\n\n  static resolve(extensions: Extensions): Extensions {\n    return ExtensionManager.sort(ExtensionManager.flatten(extensions))\n  }\n\n  static flatten(extensions: Extensions): Extensions {\n    return extensions\n      .map(extension => {\n        const context = {\n          name: extension.name,\n          options: extension.options,\n        }\n\n        const addExtensions = getExtensionField<AnyConfig['addExtensions']>(\n          extension,\n          'addExtensions',\n          context,\n        )\n\n        if (addExtensions) {\n          return [\n            extension,\n            ...this.flatten(addExtensions()),\n          ]\n        }\n\n        return extension\n      })\n      // `Infinity` will break TypeScript so we set a number that is probably high enough\n      .flat(10)\n  }\n\n  static sort(extensions: Extensions): Extensions {\n    const defaultPriority = 100\n\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField<AnyConfig['priority']>(a, 'priority') || defaultPriority\n      const priorityB = getExtensionField<AnyConfig['priority']>(b, 'priority') || defaultPriority\n\n      if (priorityA > priorityB) {\n        return -1\n      }\n\n      if (priorityA < priorityB) {\n        return 1\n      }\n\n      return 0\n    })\n  }\n\n  get commands(): RawCommands {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      const addCommands = getExtensionField<AnyConfig['addCommands']>(\n        extension,\n        'addCommands',\n        context,\n      )\n\n      if (!addCommands) {\n        return commands\n      }\n\n      return {\n        ...commands,\n        ...addCommands(),\n      }\n    }, {} as RawCommands)\n  }\n\n  get plugins(): Plugin[] {\n    return [...this.extensions]\n      .reverse()\n      .map(extension => {\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          editor: this.editor,\n          type: getSchemaTypeByName(extension.name, this.schema),\n        }\n\n        const plugins: Plugin[] = []\n\n        const addKeyboardShortcuts = getExtensionField<AnyConfig['addKeyboardShortcuts']>(\n          extension,\n          'addKeyboardShortcuts',\n          context,\n        )\n\n        if (addKeyboardShortcuts) {\n          const bindings = Object.fromEntries(\n            Object\n              .entries(addKeyboardShortcuts())\n              .map(([shortcut, method]) => {\n                return [shortcut, () => method({ editor: this.editor })]\n              }),\n          )\n\n          const keyMapPlugin = keymap(bindings)\n\n          plugins.push(keyMapPlugin)\n        }\n\n        const addInputRules = getExtensionField<AnyConfig['addInputRules']>(\n          extension,\n          'addInputRules',\n          context,\n        )\n\n        if (this.editor.options.enableInputRules && addInputRules) {\n          const inputRules = addInputRules()\n          const inputRulePlugins = inputRules.length\n            ? [inputRulesPlugin({ rules: inputRules })]\n            : []\n\n          plugins.push(...inputRulePlugins)\n        }\n\n        const addPasteRules = getExtensionField<AnyConfig['addPasteRules']>(\n          extension,\n          'addPasteRules',\n          context,\n        )\n\n        if (this.editor.options.enablePasteRules && addPasteRules) {\n          const pasteRulePlugins = addPasteRules()\n\n          plugins.push(...pasteRulePlugins)\n        }\n\n        const addProseMirrorPlugins = getExtensionField<AnyConfig['addProseMirrorPlugins']>(\n          extension,\n          'addProseMirrorPlugins',\n          context,\n        )\n\n        if (addProseMirrorPlugins) {\n          const proseMirrorPlugins = addProseMirrorPlugins()\n\n          plugins.push(...proseMirrorPlugins)\n        }\n\n        return plugins\n      })\n      .flat()\n  }\n\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions)\n  }\n\n  get nodeViews() {\n    const { editor } = this\n    const { nodeExtensions } = splitExtensions(this.extensions)\n\n    return Object.fromEntries(nodeExtensions\n      .filter(extension => !!getExtensionField(extension, 'addNodeView'))\n      .map(extension => {\n        const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name)\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          editor,\n          type: getNodeType(extension.name, this.schema),\n        }\n        const addNodeView = getExtensionField<NodeConfig['addNodeView']>(\n          extension,\n          'addNodeView',\n          context,\n        )\n\n        if (!addNodeView) {\n          return []\n        }\n\n        const nodeview = (\n          node: ProsemirrorNode,\n          view: EditorView,\n          getPos: (() => number) | boolean,\n          decorations: Decoration[],\n        ) => {\n          const HTMLAttributes = getRenderedAttributes(node, extensionAttributes)\n\n          return addNodeView()({\n            editor,\n            node,\n            getPos,\n            decorations,\n            HTMLAttributes,\n            extension,\n          })\n        }\n\n        return [extension.name, nodeview]\n      }))\n  }\n\n  get textSerializers() {\n    const { editor } = this\n    const { nodeExtensions } = splitExtensions(this.extensions)\n\n    return Object.fromEntries(nodeExtensions\n      .filter(extension => !!getExtensionField(extension, 'renderText'))\n      .map(extension => {\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          editor,\n          type: getNodeType(extension.name, this.schema),\n        }\n\n        const renderText = getExtensionField<NodeConfig['renderText']>(extension, 'renderText', context)\n\n        if (!renderText) {\n          return []\n        }\n\n        const textSerializer = (props: { node: ProsemirrorNode }) => renderText(props)\n\n        return [extension.name, textSerializer]\n      }))\n  }\n\n}\n","export default class EventEmitter {\n\n  private callbacks: { [key: string]: Function[] } = {}\n\n  public on(event: string, fn: Function): this {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = []\n    }\n\n    this.callbacks[event].push(fn)\n\n    return this\n  }\n\n  protected emit(event: string, ...args: any): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args))\n    }\n\n    return this\n  }\n\n  public off(event: string, fn?: Function): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn)\n      } else {\n        delete this.callbacks[event]\n      }\n    }\n\n    return this\n  }\n\n  protected removeAllListeners(): void {\n    this.callbacks = {}\n  }\n}\n","// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\n\nfunction getType(payload: any): string {\n  return Object.prototype.toString.call(payload).slice(8, -1)\n}\n\nexport default function isPlainObject(payload: any): payload is Record<string, any> {\n  if (getType(payload) !== 'Object') return false\n  return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype\n}\n","import isPlainObject from './isPlainObject'\n\nexport default function mergeDeep(target: Record<string, any>, source: Record<string, any>): Record<string, any> {\n  const output = { ...target }\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, { [key]: source[key] })\n        } else {\n          output[key] = mergeDeep(target[key], source[key])\n        }\n      } else {\n        Object.assign(output, { [key]: source[key] })\n      }\n    })\n  }\n\n  return output\n}\n","import { Plugin, Transaction } from 'prosemirror-state'\nimport { InputRule } from 'prosemirror-inputrules'\nimport { Editor } from './Editor'\nimport { Node } from './Node'\nimport { Mark } from './Mark'\nimport mergeDeep from './utilities/mergeDeep'\nimport {\n  Extensions,\n  GlobalAttributes,\n  RawCommands,\n  ParentConfig,\n  KeyboardShortcutCommand,\n} from './types'\nimport { ExtensionConfig } from '.'\n\ndeclare module '@tiptap/core' {\n  interface ExtensionConfig<Options = any> {\n    [key: string]: any;\n\n    /**\n     * Name\n     */\n    name: string,\n\n    /**\n     * Priority\n     */\n    priority?: number,\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options,\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<ExtensionConfig<Options>>['addGlobalAttributes'],\n    }) => GlobalAttributes | {},\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['addCommands'],\n    }) => Partial<RawCommands>,\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['addKeyboardShortcuts'],\n    }) => {\n      [key: string]: KeyboardShortcutCommand,\n    },\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['addInputRules'],\n    }) => InputRule[],\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['addPasteRules'],\n    }) => Plugin[],\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['addProseMirrorPlugins'],\n    }) => Plugin[],\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<ExtensionConfig<Options>>['addExtensions'],\n    }) => Extensions,\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<ExtensionConfig<Options>>['extendNodeSchema'],\n      },\n      extension: Node,\n    ) => Record<string, any>) | null,\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<ExtensionConfig<Options>>['extendMarkSchema'],\n      },\n      extension: Mark,\n    ) => Record<string, any>) | null,\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['onBeforeCreate'],\n    }) => void) | null,\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['onCreate'],\n    }) => void) | null,\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['onUpdate'],\n    }) => void) | null,\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['onSelectionUpdate'],\n    }) => void) | null,\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        parent: ParentConfig<ExtensionConfig<Options>>['onTransaction'],\n      },\n      props: {\n        transaction: Transaction,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        parent: ParentConfig<ExtensionConfig<Options>>['onFocus'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor isnâ€™t focused anymore.\n     */\n    onBlur?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        parent: ParentConfig<ExtensionConfig<Options>>['onBlur'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options>>['onDestroy'],\n    }) => void) | null,\n  }\n}\n\nexport class Extension<Options = any> {\n  type = 'extension'\n\n  name = 'extension'\n\n  parent: Extension | null = null\n\n  child: Extension | null = null\n\n  options: Options\n\n  config: ExtensionConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<ExtensionConfig<Options>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n    this.options = this.config.defaultOptions\n  }\n\n  static create<O>(config: Partial<ExtensionConfig<O>> = {}) {\n    return new Extension<O>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options, options) as Options\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options>(extendedConfig: Partial<ExtensionConfig<ExtendedOptions>> = {}) {\n    const extension = new Extension<ExtendedOptions>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name\n      ? extendedConfig.name\n      : extension.parent.name\n\n    extension.options = extendedConfig.defaultOptions\n      ? extendedConfig.defaultOptions\n      : extension.parent.options\n\n    return extension\n  }\n}\n","import { Editor } from '@tiptap/core'\nimport { Plugin, PluginKey } from 'prosemirror-state'\nimport { Extension } from '../Extension'\n\nconst textBetween = (\n  editor: Editor,\n  from: number,\n  to: number,\n  blockSeparator?: string,\n  leafText?: string,\n): string => {\n  let text = ''\n  let separated = true\n\n  editor.state.doc.nodesBetween(from, to, (node, pos) => {\n    const textSerializer = editor.extensionManager.textSerializers[node.type.name]\n\n    if (textSerializer) {\n      text += textSerializer({ node })\n      separated = !blockSeparator\n    } else if (node.isText) {\n      text += node?.text?.slice(Math.max(from, pos) - pos, to - pos)\n      separated = !blockSeparator\n    } else if (node.isLeaf && leafText) {\n      text += leafText\n      separated = !blockSeparator\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator\n      separated = true\n    }\n  }, 0)\n\n  return text\n}\n\nexport const ClipboardTextSerializer = Extension.create({\n  name: 'editable',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('clipboardTextSerializer'),\n        props: {\n          clipboardTextSerializer: () => {\n            const { editor } = this\n            const { from, to } = editor.state.selection\n\n            return textBetween(editor, from, to, '\\n')\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    blur: {\n      /**\n       * Removes focus from the editor.\n       */\n      blur: () => Command,\n    }\n  }\n}\n\nexport const blur: RawCommands['blur'] = () => ({ view }) => {\n  const element = view.dom as HTMLElement\n\n  element.blur()\n\n  return true\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    clearContent: {\n      /**\n       * Clear the whole document.\n       */\n      clearContent: (emitUpdate?: boolean) => Command,\n    }\n  }\n}\n\nexport const clearContent: RawCommands['clearContent'] = (emitUpdate = false) => ({ commands }) => {\n  return commands.setContent('', emitUpdate)\n}\n","import { liftTarget } from 'prosemirror-transform'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    clearNodes: {\n      /**\n       * Normalize nodes to a simple paragraph.\n       */\n      clearNodes: () => Command,\n    }\n  }\n}\n\nexport const clearNodes: RawCommands['clearNodes'] = () => ({ state, tr, dispatch }) => {\n  const { selection } = tr\n  const { ranges } = selection\n\n  ranges.forEach(range => {\n    state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return\n      }\n\n      const $fromPos = tr.doc.resolve(tr.mapping.map(pos))\n      const $toPos = tr.doc.resolve(tr.mapping.map(pos + node.nodeSize))\n      const nodeRange = $fromPos.blockRange($toPos)\n\n      if (!nodeRange) {\n        return\n      }\n\n      const targetLiftDepth = liftTarget(nodeRange)\n\n      if (node.type.isTextblock && dispatch) {\n        const { defaultType } = $fromPos.parent.contentMatchAt($fromPos.index())\n\n        tr.setNodeMarkup(nodeRange.start, defaultType)\n      }\n\n      if ((targetLiftDepth || targetLiftDepth === 0) && dispatch) {\n        tr.lift(nodeRange, targetLiftDepth)\n      }\n    })\n  })\n\n  return true\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    command: {\n      /**\n       * Define a command inline.\n       */\n      command: (fn: (props: Parameters<Command>[0]) => boolean) => Command,\n    }\n  }\n}\n\nexport const command: RawCommands['command'] = fn => props => {\n  return fn(props)\n}\n","import { createParagraphNear as originalCreateParagraphNear } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    createParagraphNear: {\n      /**\n       * Create a paragraph nearby.\n       */\n      createParagraphNear: () => Command,\n    }\n  }\n}\n\nexport const createParagraphNear: RawCommands['createParagraphNear'] = () => ({ state, dispatch }) => {\n  return originalCreateParagraphNear(state, dispatch)\n}\n","import { Command, RawCommands, Range } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    deleteRange: {\n      /**\n       * Delete a given range.\n       */\n      deleteRange: (range: Range) => Command,\n    }\n  }\n}\n\nexport const deleteRange: RawCommands['deleteRange'] = range => ({ tr, dispatch }) => {\n  const { from, to } = range\n\n  if (dispatch) {\n    tr.delete(from, to)\n  }\n\n  return true\n}\n","import { deleteSelection as originalDeleteSelection } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    deleteSelection: {\n      /**\n       * Delete the selection, if there is one.\n       */\n      deleteSelection: () => Command,\n    }\n  }\n}\n\nexport const deleteSelection: RawCommands['deleteSelection'] = () => ({ state, dispatch }) => {\n  return originalDeleteSelection(state, dispatch)\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    enter: {\n      /**\n       * Trigger enter.\n       */\n      enter: () => Command,\n    }\n  }\n}\n\nexport const enter: RawCommands['enter'] = () => ({ commands }) => {\n  return commands.keyboardShortcut('Enter')\n}\n","import { exitCode as originalExitCode } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    exitCode: {\n      /**\n       * Exit from a code block.\n       */\n      exitCode: () => Command,\n    }\n  }\n}\n\nexport const exitCode: RawCommands['exitCode'] = () => ({ state, dispatch }) => {\n  return originalExitCode(state, dispatch)\n}\n","import { Mark as ProseMirrorMark, MarkType, ResolvedPos } from 'prosemirror-model'\nimport objectIncludes from '../utilities/objectIncludes'\nimport { Range } from '../types'\n\nfunction findMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): ProseMirrorMark | undefined {\n  return marks.find(item => {\n    return item.type === type && objectIncludes(item.attrs, attributes)\n  })\n}\n\nfunction isMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): boolean {\n  return !!findMarkInSet(marks, type, attributes)\n}\n\nexport default function getMarkRange(\n  $pos: ResolvedPos,\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): Range | void {\n  if (!$pos || !type) {\n    return\n  }\n\n  const start = $pos.parent.childAfter($pos.parentOffset)\n\n  if (!start.node) {\n    return\n  }\n\n  const mark = findMarkInSet(start.node.marks, type, attributes)\n\n  if (!mark) {\n    return\n  }\n\n  let startIndex = $pos.index()\n  let startPos = $pos.start() + start.offset\n  let endIndex = startIndex + 1\n  let endPos = startPos + start.node.nodeSize\n\n  findMarkInSet(start.node.marks, type, attributes)\n\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1\n    startPos -= $pos.parent.child(startIndex).nodeSize\n  }\n\n  while (\n    endIndex < $pos.parent.childCount\n    && isMarkInSet($pos.parent.child(endIndex).marks, type, attributes)\n  ) {\n    endPos += $pos.parent.child(endIndex).nodeSize\n    endIndex += 1\n  }\n\n  return {\n    from: startPos,\n    to: endPos,\n  }\n}\n","import { TextSelection } from 'prosemirror-state'\nimport { MarkType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getMarkType from '../helpers/getMarkType'\nimport getMarkRange from '../helpers/getMarkRange'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    extendMarkRange: {\n      /**\n       * Extends the text selection to the current mark.\n       */\n      extendMarkRange: (typeOrName: string | MarkType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const extendMarkRange: RawCommands['extendMarkRange'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const type = getMarkType(typeOrName, state.schema)\n  const { doc, selection } = tr\n  const { $from, from, to } = selection\n\n  if (dispatch) {\n    const range = getMarkRange($from, type, attributes)\n\n    if (range && range.from <= from && range.to >= to) {\n      const newSelection = TextSelection.create(doc, range.from, range.to)\n\n      tr.setSelection(newSelection)\n    }\n  }\n\n  return true\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    first: {\n      /**\n       * Runs one command after the other and stops at the first which returns true.\n       */\n      first: (commands: Command[] | ((props: Parameters<Command>[0]) => Command[])) => Command,\n    }\n  }\n}\n\nexport const first: RawCommands['first'] = commands => props => {\n  const items = typeof commands === 'function'\n    ? commands(props)\n    : commands\n\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true\n    }\n  }\n\n  return false\n}\n","export default function minMax(value = 0, min = 0, max = 0): number {\n  return Math.min(Math.max(value, min), max)\n}\n","export default function isClass(item: any): boolean {\n  if (item.constructor?.toString().substring(0, 5) !== 'class') {\n    return false\n  }\n\n  return true\n}\n","import isClass from './isClass'\n\nexport default function isObject(item: any): boolean {\n  return (\n    item\n    && typeof item === 'object'\n    && !Array.isArray(item)\n    && !isClass(item)\n  )\n}\n","import { TextSelection } from 'prosemirror-state'\nimport isObject from '../utilities/isObject'\n\nexport default function isTextSelection(value: unknown): value is TextSelection {\n  return isObject(value) && value instanceof TextSelection\n}\n","import { EditorState, TextSelection } from 'prosemirror-state'\nimport { Command, RawCommands, FocusPosition } from '../types'\nimport minMax from '../utilities/minMax'\nimport isTextSelection from '../helpers/isTextSelection'\n\nfunction resolveSelection(state: EditorState, position: FocusPosition = null) {\n  if (!position) {\n    return null\n  }\n\n  if (position === 'start' || position === true) {\n    return {\n      from: 0,\n      to: 0,\n    }\n  }\n\n  if (position === 'end') {\n    const { size } = state.doc.content\n\n    return {\n      from: size,\n      to: size,\n    }\n  }\n\n  return {\n    from: position,\n    to: position,\n  }\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    focus: {\n      /**\n       * Focus the editor at the given position.\n       */\n      focus: (position?: FocusPosition) => Command,\n    }\n  }\n}\n\nexport const focus: RawCommands['focus'] = (position = null) => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  if ((view.hasFocus() && position === null) || position === false) {\n    return true\n  }\n\n  // we donâ€™t try to resolve a NodeSelection or CellSelection\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    view.focus()\n    return true\n  }\n\n  const { from, to } = resolveSelection(editor.state, position) || editor.state.selection\n  const { doc, storedMarks } = tr\n  const resolvedFrom = minMax(from, 0, doc.content.size)\n  const resolvedEnd = minMax(to, 0, doc.content.size)\n  const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd)\n  const isSameSelection = editor.state.selection.eq(selection)\n\n  if (dispatch) {\n    tr.setSelection(selection)\n\n    // `tr.setSelection` resets the stored marks\n    // so weâ€™ll restore them if the selection is the same as before\n    if (isSameSelection && storedMarks) {\n      tr.setStoredMarks(storedMarks)\n    }\n\n    view.focus()\n  }\n\n  return true\n}\n","import { Command, RawCommands, Content } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    insertContent: {\n      /**\n       * Insert a node or string of HTML at the current position.\n       */\n      insertContent: (value: Content) => Command,\n    }\n  }\n}\n\nexport const insertContent: RawCommands['insertContent'] = value => ({ tr, commands }) => {\n  return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value)\n}\n","import { Selection, Transaction } from 'prosemirror-state'\nimport { ReplaceStep, ReplaceAroundStep } from 'prosemirror-transform'\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nexport default function selectionToInsertionEnd(tr: Transaction, startLen: number, bias: number) {\n  const last = tr.steps.length - 1\n\n  if (last < startLen) {\n    return\n  }\n\n  const step = tr.steps[last]\n\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return\n  }\n\n  const map = tr.mapping.maps[last]\n  let end = 0\n\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo\n    }\n  })\n\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import createNodeFromContent from '../helpers/createNodeFromContent'\nimport selectionToInsertionEnd from '../helpers/selectionToInsertionEnd'\nimport {\n  Command,\n  RawCommands,\n  Content,\n  Range,\n} from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    insertContentAt: {\n      /**\n       * Insert a node or string of HTML at a specific position.\n       */\n      insertContentAt: (position: number | Range, value: Content) => Command,\n    }\n  }\n}\n\nexport const insertContentAt: RawCommands['insertContentAt'] = (position, value) => ({ tr, dispatch, editor }) => {\n  if (dispatch) {\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: {\n        preserveWhitespace: 'full',\n      },\n    })\n\n    // donâ€™t dispatch an empty fragment because this can lead to strange errors\n    if (content.toString() === '<>') {\n      return true\n    }\n\n    const { from, to } = typeof position === 'number'\n      ? { from: position, to: position }\n      : position\n\n    tr.replaceWith(from, to, content)\n\n    // set cursor at end of inserted content\n    selectionToInsertionEnd(tr, tr.steps.length - 1, 1)\n  }\n\n  return true\n}\n","import { joinBackward as originalJoinBackward } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    joinBackward: {\n      /**\n       * Join two nodes backward.\n       */\n      joinBackward: () => Command,\n    }\n  }\n}\n\nexport const joinBackward: RawCommands['joinBackward'] = () => ({ state, dispatch }) => {\n  return originalJoinBackward(state, dispatch)\n}\n","import { joinForward as originalJoinForward } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    joinForward: {\n      /**\n       * Join two nodes forward.\n       */\n      joinForward: () => Command,\n    }\n  }\n}\n\nexport const joinForward: RawCommands['joinForward'] = () => ({ state, dispatch }) => {\n  return originalJoinForward(state, dispatch)\n}\n","import { Command, RawCommands } from '../types'\n\nconst mac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false\n\nfunction normalizeKeyName(name: string) {\n  const parts = name.split(/-(?!$)/)\n  let result = parts[parts.length - 1]\n\n  if (result === 'Space') {\n    result = ' '\n  }\n\n  let alt\n  let ctrl\n  let shift\n  let meta\n\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i]\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true\n    } else if (/^mod$/i.test(mod)) {\n      if (mac) {\n        meta = true\n      } else {\n        ctrl = true\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`)\n    }\n  }\n\n  if (alt) {\n    result = `Alt-${result}`\n  }\n\n  if (ctrl) {\n    result = `Ctrl-${result}`\n  }\n\n  if (meta) {\n    result = `Meta-${result}`\n  }\n\n  if (shift) {\n    result = `Shift-${result}`\n  }\n\n  return result\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    keyboardShortcut: {\n      /**\n       * Trigger a keyboard shortcut.\n       */\n      keyboardShortcut: (name: string) => Command,\n    }\n  }\n}\n\nexport const keyboardShortcut: RawCommands['keyboardShortcut'] = name => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/)\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item))\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space'\n      ? ' '\n      : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true,\n  })\n\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event))\n  })\n\n  capturedTransaction?.steps.forEach(step => {\n    const newStep = step.map(tr.mapping)\n\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep)\n    }\n  })\n\n  return true\n}\n","import { lift as originalLift } from 'prosemirror-commands'\nimport { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport isNodeActive from '../helpers/isNodeActive'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    lift: {\n      /**\n       * Removes an existing wrap.\n       */\n      lift: (typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const lift: RawCommands['lift'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (!isActive) {\n    return false\n  }\n\n  return originalLift(state, dispatch)\n}\n","import { liftEmptyBlock as originalLiftEmptyBlock } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    liftEmptyBlock: {\n      /**\n       * Lift block if empty.\n       */\n      liftEmptyBlock: () => Command,\n    }\n  }\n}\n\nexport const liftEmptyBlock: RawCommands['liftEmptyBlock'] = () => ({ state, dispatch }) => {\n  return originalLiftEmptyBlock(state, dispatch)\n}\n","import { liftListItem as originalLiftListItem } from 'prosemirror-schema-list'\nimport { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    liftListItem: {\n      /**\n       * Lift the list item into a wrapping list.\n       */\n      liftListItem: (typeOrName: string | NodeType) => Command,\n    }\n  }\n}\n\nexport const liftListItem: RawCommands['liftListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalLiftListItem(type)(state, dispatch)\n}\n","import { newlineInCode as originalNewlineInCode } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    newlineInCode: {\n      /**\n       * Add a newline character in code.\n       */\n      newlineInCode: () => Command,\n    }\n  }\n}\n\nexport const newlineInCode: RawCommands['newlineInCode'] = () => ({ state, dispatch }) => {\n  return originalNewlineInCode(state, dispatch)\n}\n","import { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    replace: {\n      /**\n       * Replaces text with a node.\n       */\n      replace: (typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const replace: RawCommands['replace'] = (typeOrName, attributes = {}) => ({ state, commands }) => {\n  console.warn('[tiptap warn]: replace() is deprecated. please use insertContent() instead.')\n\n  const { from, to } = state.selection\n  const range = { from, to }\n\n  return commands.replaceRange(range, typeOrName, attributes)\n}\n","import { NodeType } from 'prosemirror-model'\nimport getNodeType from '../helpers/getNodeType'\nimport { Command, RawCommands, Range } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    replaceRange: {\n      /**\n       * Replaces text with a node within a range.\n       */\n      replaceRange: (range: Range, typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const replaceRange: RawCommands['replaceRange'] = (range, typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  console.warn('[tiptap warn]: replaceRange() is deprecated. please use insertContent() instead.')\n\n  const type = getNodeType(typeOrName, state.schema)\n  const { from, to } = range\n  // const $from = tr.doc.resolve(from)\n  // const index = $from.index()\n\n  // if (!$from.parent.canReplaceWith(index, index, type)) {\n  //   return false\n  // }\n\n  if (dispatch) {\n    tr.replaceRangeWith(from, to, type.create(attributes))\n  }\n\n  return true\n}\n","/**\n * Remove a property or an array of properties from an object\n * @param obj Object\n * @param key Key to remove\n */\nexport default function deleteProps(obj: Record<string, any>, propOrProps: string | string[]): Record<string, any> {\n  const props = typeof propOrProps === 'string'\n    ? [propOrProps]\n    : propOrProps\n\n  return Object\n    .keys(obj)\n    .reduce((newObj: Record<string, any>, prop) => {\n      if (!props.includes(prop)) {\n        newObj[prop] = obj[prop]\n      }\n\n      return newObj\n    }, {})\n}\n","import { NodeType, MarkType } from 'prosemirror-model'\nimport getNodeType from '../helpers/getNodeType'\nimport getMarkType from '../helpers/getMarkType'\nimport getSchemaTypeNameByName from '../helpers/getSchemaTypeNameByName'\nimport deleteProps from '../utilities/deleteProps'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    resetAttributes: {\n      /**\n       * Resets some node attributes to the default value.\n       */\n      resetAttributes: (typeOrName: string | NodeType | MarkType, attributes: string | string[]) => Command,\n    }\n  }\n}\n\nexport const resetAttributes: RawCommands['resetAttributes'] = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string'\n      ? typeOrName\n      : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes))\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)))\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    scrollIntoView: {\n      /**\n       * Scroll the selection into view.\n       */\n      scrollIntoView: () => Command,\n    }\n  }\n}\n\nexport const scrollIntoView: RawCommands['scrollIntoView'] = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import { selectAll as originalSelectAll } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    selectAll: {\n      /**\n       * Select the whole document.\n       */\n      selectAll: () => Command,\n    }\n  }\n}\n\nexport const selectAll: RawCommands['selectAll'] = () => ({ state, dispatch }) => {\n  return originalSelectAll(state, dispatch)\n}\n","import { selectNodeBackward as originalSelectNodeBackward } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    selectNodeBackward: {\n      /**\n       * Select a node backward.\n       */\n      selectNodeBackward: () => Command,\n    }\n  }\n}\n\nexport const selectNodeBackward: RawCommands['selectNodeBackward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeBackward(state, dispatch)\n}\n","import { selectNodeForward as originalSelectNodeForward } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    selectNodeForward: {\n      /**\n       * Select a node forward.\n       */\n      selectNodeForward: () => Command,\n    }\n  }\n}\n\nexport const selectNodeForward: RawCommands['selectNodeForward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeForward(state, dispatch)\n}\n","import { selectParentNode as originalSelectParentNode } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    selectParentNode: {\n      /**\n       * Select the parent node.\n       */\n      selectParentNode: () => Command,\n    }\n  }\n}\n\nexport const selectParentNode: RawCommands['selectParentNode'] = () => ({ state, dispatch }) => {\n  return originalSelectParentNode(state, dispatch)\n}\n","import { TextSelection } from 'prosemirror-state'\nimport { ParseOptions } from 'prosemirror-model'\nimport createDocument from '../helpers/createDocument'\nimport { Command, RawCommands, Content } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    setContent: {\n      /**\n       * Replace the whole document with new content.\n       */\n      setContent: (\n        content: Content,\n        emitUpdate?: boolean,\n        parseOptions?: ParseOptions,\n      ) => Command,\n    }\n  }\n}\n\nexport const setContent: RawCommands['setContent'] = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {\n  const { doc } = tr\n  const document = createDocument(content, editor.schema, parseOptions)\n  const selection = TextSelection.create(doc, 0, doc.content.size)\n\n  if (dispatch) {\n    tr.setSelection(selection)\n      .replaceSelectionWith(document, false)\n      .setMeta('preventUpdate', !emitUpdate)\n  }\n\n  return true\n}\n","import { MarkType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getMarkType from '../helpers/getMarkType'\nimport getMarkAttributes from '../helpers/getMarkAttributes'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    setMark: {\n      /**\n       * Add a mark with new attributes.\n       */\n      setMark: (typeOrName: string | MarkType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const setMark: RawCommands['setMark'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n  const type = getMarkType(typeOrName, state.schema)\n\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type)\n\n      tr.addStoredMark(type.create({\n        ...oldAttributes,\n        ...attributes,\n      }))\n    } else {\n      ranges.forEach(range => {\n        const from = range.$from.pos\n        const to = range.$to.pos\n\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from)\n          const trimmedTo = Math.min(pos + node.nodeSize, to)\n          const someHasMark = node.marks.find(mark => mark.type === type)\n\n          // if there is already a mark of this type\n          // we know that we have to merge its attributes\n          // otherwise we add a fresh new mark\n          if (someHasMark) {\n            node.marks.forEach(mark => {\n              if (type === mark.type) {\n                tr.addMark(trimmedFrom, trimmedTo, type.create({\n                  ...mark.attrs,\n                  ...attributes,\n                }))\n              }\n            })\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes))\n          }\n        })\n      })\n    }\n  }\n\n  return true\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    setMeta: {\n      /**\n       * Store a metadata property in the current transaction.\n       */\n      setMeta: (key: string, value: any) => Command,\n    }\n  }\n}\n\nexport const setMeta: RawCommands['setMeta'] = (key, value) => ({ tr }) => {\n  tr.setMeta(key, value)\n\n  return true\n}\n","import { NodeType } from 'prosemirror-model'\nimport { setBlockType } from 'prosemirror-commands'\nimport { Command, RawCommands } from '../types'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    setNode: {\n      /**\n       * Replace a given range with a node.\n       */\n      setNode: (typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const setNode: RawCommands['setNode'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return setBlockType(type, attributes)(state, dispatch)\n}\n","import { NodeSelection } from 'prosemirror-state'\nimport minMax from '../utilities/minMax'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    setNodeSelection: {\n      /**\n       * Creates a NodeSelection.\n       */\n      setNodeSelection: (position: number) => Command,\n    }\n  }\n}\n\nexport const setNodeSelection: RawCommands['setNodeSelection'] = position => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr\n    const from = minMax(position, 0, doc.content.size)\n    const selection = NodeSelection.create(doc, from)\n\n    tr.setSelection(selection)\n  }\n\n  return true\n}\n","import { TextSelection } from 'prosemirror-state'\nimport minMax from '../utilities/minMax'\nimport { Command, RawCommands, Range } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    setTextSelection: {\n      /**\n       * Creates a TextSelection.\n       */\n      setTextSelection: (position: number | Range) => Command,\n    }\n  }\n}\n\nexport const setTextSelection: RawCommands['setTextSelection'] = position => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr\n    const { from, to } = typeof position === 'number'\n      ? { from: position, to: position }\n      : position\n    const boundedFrom = minMax(from, 0, doc.content.size)\n    const boundedTo = minMax(to, 0, doc.content.size)\n    const selection = TextSelection.create(doc, boundedFrom, boundedTo)\n\n    tr.setSelection(selection)\n  }\n\n  return true\n}\n","import { sinkListItem as originalSinkListItem } from 'prosemirror-schema-list'\nimport { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    sinkListItem: {\n      /**\n       * Sink the list item down into an inner list.\n       */\n      sinkListItem: (typeOrName: string | NodeType) => Command,\n    }\n  }\n}\n\nexport const sinkListItem: RawCommands['sinkListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalSinkListItem(type)(state, dispatch)\n}\n","import { ExtensionAttribute } from '../types'\n\nexport default function getSplittedAttributes(\n  extensionAttributes: ExtensionAttribute[],\n  typeName: string,\n  attributes: Record<string, any>,\n): Record<string, any> {\n  return Object.fromEntries(Object\n    .entries(attributes)\n    .filter(([name]) => {\n      const extensionAttribute = extensionAttributes.find(item => {\n        return item.type === typeName && item.name === name\n      })\n\n      if (!extensionAttribute) {\n        return false\n      }\n\n      return extensionAttribute.attribute.keepOnSplit\n    }))\n}\n","import { canSplit } from 'prosemirror-transform'\nimport { ContentMatch } from 'prosemirror-model'\nimport { EditorState, NodeSelection, TextSelection } from 'prosemirror-state'\nimport { Command, RawCommands } from '../types'\nimport getSplittedAttributes from '../helpers/getSplittedAttributes'\n\nfunction defaultBlockAt(match: ContentMatch) {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const { type } = match.edge(i)\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type\n    }\n  }\n  return null\n}\n\nfunction ensureMarks(state: EditorState, splittableMarks?: string[]) {\n  const marks = state.storedMarks\n    || (state.selection.$to.parentOffset && state.selection.$from.marks())\n\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks?.includes(mark.type.name))\n\n    state.tr.ensureMarks(filteredMarks)\n  }\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    splitBlock: {\n      /**\n       * Forks a new node from an existing node.\n       */\n      splitBlock: (options?: { keepMarks?: boolean }) => Command,\n    }\n  }\n}\n\nexport const splitBlock: RawCommands['splitBlock'] = ({ keepMarks = true } = {}) => ({\n  tr,\n  state,\n  dispatch,\n  editor,\n}) => {\n  const { selection, doc } = tr\n  const { $from, $to } = selection\n  const extensionAttributes = editor.extensionManager.attributes\n  const newAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  if (selection instanceof NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n      return false\n    }\n\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks)\n      }\n\n      tr.split($from.pos).scrollIntoView()\n    }\n\n    return true\n  }\n\n  if (!$from.parent.isBlock) {\n    return false\n  }\n\n  if (dispatch) {\n    const atEnd = $to.parentOffset === $to.parent.content.size\n\n    if (selection instanceof TextSelection) {\n      tr.deleteSelection()\n    }\n\n    const deflt = $from.depth === 0\n      ? undefined\n      : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n\n    let types = atEnd && deflt\n      ? [{\n        type: deflt,\n        attrs: newAttributes,\n      }]\n      : undefined\n\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n\n    if (\n      !types\n      && !can\n      && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)\n    ) {\n      can = true\n      types = deflt\n        ? [{\n          type: deflt,\n          attrs: newAttributes,\n        }]\n        : undefined\n    }\n\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n\n      if (\n        deflt\n        && !atEnd\n        && !$from.parentOffset\n        && $from.parent.type !== deflt\n      ) {\n        const first = tr.mapping.map($from.before())\n        const $first = tr.doc.resolve(first)\n\n        if ($from.parent.canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n        }\n      }\n    }\n\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks)\n    }\n\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import {\n  NodeType,\n  Node as ProseMirrorNode,\n  Fragment,\n  Slice,\n} from 'prosemirror-model'\nimport { canSplit } from 'prosemirror-transform'\nimport { TextSelection } from 'prosemirror-state'\nimport { Command, RawCommands } from '../types'\nimport getNodeType from '../helpers/getNodeType'\nimport getSplittedAttributes from '../helpers/getSplittedAttributes'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    splitListItem: {\n      /**\n       * Splits one list item into two list items.\n       */\n      splitListItem: (typeOrName: string | NodeType) => Command,\n    }\n  }\n}\n\nexport const splitListItem: RawCommands['splitListItem'] = typeOrName => ({\n  tr, state, dispatch, editor,\n}) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const { $from, $to } = state.selection\n\n  // @ts-ignore\n  // eslint-disable-next-line\n  const node: ProseMirrorNode = state.selection.node\n\n  if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n    return false\n  }\n\n  const grandParent = $from.node(-1)\n\n  if (grandParent.type !== type) {\n    return false\n  }\n\n  const extensionAttributes = editor.extensionManager.attributes\n\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if (\n      $from.depth === 2\n      || $from.node(-3).type !== type\n      || $from.index(-2) !== $from.node(-2).childCount - 1\n    ) {\n      return false\n    }\n\n    if (dispatch) {\n      let wrap = Fragment.empty\n      const keepItem = $from.index(-1) > 0\n\n      // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n      for (let d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap))\n      }\n\n      // Add a second list item with an empty default start node\n      const newNextTypeAttributes = getSplittedAttributes(\n        extensionAttributes,\n        $from.node().type.name,\n        $from.node().attrs,\n      )\n      const nextType = type.contentMatch.defaultType?.createAndFill(newNextTypeAttributes) || undefined\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined))\n\n      tr\n        .replace(\n          $from.before(keepItem ? undefined : -1),\n          $from.after(-3),\n          new Slice(wrap, keepItem ? 3 : 2, 2),\n        )\n        .setSelection(TextSelection.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))))\n        .scrollIntoView()\n    }\n\n    return true\n  }\n\n  const nextType = $to.pos === $from.end()\n    ? grandParent.contentMatchAt(0).defaultType\n    : null\n\n  const newTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    grandParent.type.name,\n    grandParent.attrs,\n  )\n  const newNextTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  tr.delete($from.pos, $to.pos)\n\n  const types = nextType\n    ? [{ type, attrs: newTypeAttributes }, { type: nextType, attrs: newNextTypeAttributes }]\n    : [{ type, attrs: newTypeAttributes }]\n\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false\n  }\n\n  if (dispatch) {\n    tr.split($from.pos, 2, types).scrollIntoView()\n  }\n\n  return true\n}\n","import { ResolvedPos, Node as ProseMirrorNode } from 'prosemirror-model'\nimport { Predicate } from '../types'\n\nexport default function findParentNodeClosestToPos($pos: ResolvedPos, predicate: Predicate): ({\n  pos: number,\n  start: number,\n  depth: number,\n  node: ProseMirrorNode,\n} | undefined) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i)\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node,\n      }\n    }\n  }\n}\n","import { Selection } from 'prosemirror-state'\nimport findParentNodeClosestToPos from './findParentNodeClosestToPos'\nimport { Predicate } from '../types'\n\nexport default function findParentNode(predicate: Predicate) {\n  return (selection: Selection) => findParentNodeClosestToPos(selection.$from, predicate)\n}\n","import { Extensions } from '../types'\nimport { NodeConfig } from '..'\nimport splitExtensions from './splitExtensions'\nimport callOrReturn from '../utilities/callOrReturn'\nimport getExtensionField from '../helpers/getExtensionField'\n\nexport default function isList(name: string, extensions: Extensions): boolean {\n  const { nodeExtensions } = splitExtensions(extensions)\n  const extension = nodeExtensions.find(item => item.name === name)\n\n  if (!extension) {\n    return false\n  }\n\n  const context = {\n    name: extension.name,\n    options: extension.options,\n  }\n  const group = callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context))\n\n  if (typeof group !== 'string') {\n    return false\n  }\n\n  return group.split(' ').includes('list')\n}\n","import { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getNodeType from '../helpers/getNodeType'\nimport findParentNode from '../helpers/findParentNode'\nimport isList from '../helpers/isList'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    toggleList: {\n      /**\n       * Toggle between different list types.\n       */\n      toggleList: (listTypeOrName: string | NodeType, itemTypeOrName: string | NodeType) => Command,\n    }\n  }\n}\n\nexport const toggleList: RawCommands['toggleList'] = (listTypeOrName, itemTypeOrName) => ({\n  editor, tr, state, dispatch, chain, commands, can,\n}) => {\n  const { extensions } = editor.extensionManager\n  const listType = getNodeType(listTypeOrName, state.schema)\n  const itemType = getNodeType(itemTypeOrName, state.schema)\n  const { selection } = state\n  const { $from, $to } = selection\n  const range = $from.blockRange($to)\n\n  if (!range) {\n    return false\n  }\n\n  const parentList = findParentNode(node => isList(node.type.name, extensions))(selection)\n\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    // remove list\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType)\n    }\n\n    // change list type\n    if (\n      isList(parentList.node.type.name, extensions)\n      && listType.validContent(parentList.node.content)\n      && dispatch\n    ) {\n      tr.setNodeMarkup(parentList.pos, listType)\n\n      return true\n    }\n  }\n\n  const canWrapInList = can().wrapInList(listType)\n\n  // try to convert node to paragraph if needed\n  if (!canWrapInList) {\n    return chain()\n      .clearNodes()\n      .wrapInList(listType)\n      .run()\n  }\n\n  return commands.wrapInList(listType)\n}\n","import { MarkType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getMarkType from '../helpers/getMarkType'\nimport isMarkActive from '../helpers/isMarkActive'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    toggleMark: {\n      /**\n       * Toggle a mark on and off.\n       */\n      toggleMark: (typeOrName: string | MarkType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const toggleMark: RawCommands['toggleMark'] = (typeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getMarkType(typeOrName, state.schema)\n  const isActive = isMarkActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.unsetMark(type)\n  }\n\n  return commands.setMark(type, attributes)\n}\n","import { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport isNodeActive from '../helpers/isNodeActive'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    toggleNode: {\n      /**\n       * Toggle a node with another node.\n       */\n      toggleNode: (typeOrName: string | NodeType, toggleTypeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const toggleNode: RawCommands['toggleNode'] = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const toggleType = getNodeType(toggleTypeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.setNode(toggleType)\n  }\n\n  return commands.setNode(type, attributes)\n}\n","import { wrapIn, lift } from 'prosemirror-commands'\nimport { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport isNodeActive from '../helpers/isNodeActive'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    toggleWrap: {\n      /**\n       * Wraps nodes in another node, or removes an existing wrap.\n       */\n      toggleWrap: (typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const toggleWrap: RawCommands['toggleWrap'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return lift(state, dispatch)\n  }\n\n  return wrapIn(type, attributes)(state, dispatch)\n}\n","import { undoInputRule as originalUndoInputRule } from 'prosemirror-inputrules'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    undoInputRule: {\n      /**\n       * Undo an input rule.\n       */\n      undoInputRule: () => Command,\n    }\n  }\n}\n\nexport const undoInputRule: RawCommands['undoInputRule'] = () => ({ state, dispatch }) => {\n  return originalUndoInputRule(state, dispatch)\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    unsetAllMarks: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetAllMarks: () => Command,\n    }\n  }\n}\n\nexport const unsetAllMarks: RawCommands['unsetAllMarks'] = () => ({ tr, state, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n\n  if (empty) {\n    return true\n  }\n\n  if (dispatch) {\n    Object\n      .entries(state.schema.marks)\n      .forEach(([, mark]) => {\n        ranges.forEach(range => {\n          tr.removeMark(range.$from.pos, range.$to.pos, mark as any)\n        })\n      })\n  }\n\n  return true\n}\n","import { MarkType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getMarkType from '../helpers/getMarkType'\nimport getMarkRange from '../helpers/getMarkRange'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    unsetMark: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetMark: (typeOrName: string | MarkType) => Command,\n    }\n  }\n}\n\nexport const unsetMark: RawCommands['unsetMark'] = typeOrName => ({ tr, state, dispatch }) => {\n  const { selection } = tr\n  const type = getMarkType(typeOrName, state.schema)\n  const { $from, empty, ranges } = selection\n\n  if (dispatch) {\n    if (empty) {\n      let { from, to } = selection\n      const range = getMarkRange($from, type)\n\n      if (range) {\n        from = range.from\n        to = range.to\n      }\n\n      tr.removeMark(from, to, type)\n    } else {\n      ranges.forEach(range => {\n        tr.removeMark(range.$from.pos, range.$to.pos, type)\n      })\n    }\n\n    tr.removeStoredMark(type)\n  }\n\n  return true\n}\n","import { NodeType, MarkType } from 'prosemirror-model'\nimport getNodeType from '../helpers/getNodeType'\nimport getMarkType from '../helpers/getMarkType'\nimport getSchemaTypeNameByName from '../helpers/getSchemaTypeNameByName'\nimport { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    updateAttributes: {\n      /**\n       * Update attributes of a node or mark.\n       */\n      updateAttributes: (typeOrName: string | NodeType | MarkType, attributes: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const updateAttributes: RawCommands['updateAttributes'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string'\n      ? typeOrName\n      : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      const from = range.$from.pos\n      const to = range.$to.pos\n\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, {\n            ...node.attrs,\n            ...attributes,\n          })\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              const trimmedFrom = Math.max(pos, from)\n              const trimmedTo = Math.min(pos + node.nodeSize, to)\n\n              tr.addMark(trimmedFrom, trimmedTo, markType.create({\n                ...mark.attrs,\n                ...attributes,\n              }))\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { wrapIn as originalWrapIn } from 'prosemirror-commands'\nimport { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport isNodeActive from '../helpers/isNodeActive'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    wrapIn: {\n      /**\n       * Wraps nodes in another node.\n       */\n      wrapIn: (typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const wrapIn: RawCommands['wrapIn'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return false\n  }\n\n  return originalWrapIn(type, attributes)(state, dispatch)\n}\n","import { wrapInList as originalWrapInList } from 'prosemirror-schema-list'\nimport { NodeType } from 'prosemirror-model'\nimport { Command, RawCommands } from '../types'\nimport getNodeType from '../helpers/getNodeType'\n\ndeclare module '@tiptap/core' {\n  interface Commands {\n    wrapInList: {\n      /**\n       * Wrap a node in a list.\n       */\n      wrapInList: (typeOrName: string | NodeType, attributes?: Record<string, any>) => Command,\n    }\n  }\n}\n\nexport const wrapInList: RawCommands['wrapInList'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalWrapInList(type, attributes)(state, dispatch)\n}\n","import { Extension } from '../Extension'\nimport * as blur from '../commands/blur'\nimport * as clearContent from '../commands/clearContent'\nimport * as clearNodes from '../commands/clearNodes'\nimport * as command from '../commands/command'\nimport * as createParagraphNear from '../commands/createParagraphNear'\nimport * as deleteRange from '../commands/deleteRange'\nimport * as deleteSelection from '../commands/deleteSelection'\nimport * as enter from '../commands/enter'\nimport * as exitCode from '../commands/exitCode'\nimport * as extendMarkRange from '../commands/extendMarkRange'\nimport * as first from '../commands/first'\nimport * as focus from '../commands/focus'\nimport * as insertContent from '../commands/insertContent'\nimport * as insertContentAt from '../commands/insertContentAt'\nimport * as joinBackward from '../commands/joinBackward'\nimport * as joinForward from '../commands/joinForward'\nimport * as keyboardShortcut from '../commands/keyboardShortcut'\nimport * as lift from '../commands/lift'\nimport * as liftEmptyBlock from '../commands/liftEmptyBlock'\nimport * as liftListItem from '../commands/liftListItem'\nimport * as newlineInCode from '../commands/newlineInCode'\nimport * as replace from '../commands/replace'\nimport * as replaceRange from '../commands/replaceRange'\nimport * as resetAttributes from '../commands/resetAttributes'\nimport * as scrollIntoView from '../commands/scrollIntoView'\nimport * as selectAll from '../commands/selectAll'\nimport * as selectNodeBackward from '../commands/selectNodeBackward'\nimport * as selectNodeForward from '../commands/selectNodeForward'\nimport * as selectParentNode from '../commands/selectParentNode'\nimport * as setContent from '../commands/setContent'\nimport * as setMark from '../commands/setMark'\nimport * as setMeta from '../commands/setMeta'\nimport * as setNode from '../commands/setNode'\nimport * as setNodeSelection from '../commands/setNodeSelection'\nimport * as setTextSelection from '../commands/setTextSelection'\nimport * as sinkListItem from '../commands/sinkListItem'\nimport * as splitBlock from '../commands/splitBlock'\nimport * as splitListItem from '../commands/splitListItem'\nimport * as toggleList from '../commands/toggleList'\nimport * as toggleMark from '../commands/toggleMark'\nimport * as toggleNode from '../commands/toggleNode'\nimport * as toggleWrap from '../commands/toggleWrap'\nimport * as undoInputRule from '../commands/undoInputRule'\nimport * as unsetAllMarks from '../commands/unsetAllMarks'\nimport * as unsetMark from '../commands/unsetMark'\nimport * as updateAttributes from '../commands/updateAttributes'\nimport * as wrapIn from '../commands/wrapIn'\nimport * as wrapInList from '../commands/wrapInList'\n\nexport { blur }\nexport { clearContent }\nexport { clearNodes }\nexport { command }\nexport { createParagraphNear }\nexport { deleteRange }\nexport { deleteSelection }\nexport { enter }\nexport { exitCode }\nexport { extendMarkRange }\nexport { first }\nexport { focus }\nexport { insertContent }\nexport { insertContentAt }\nexport { joinBackward }\nexport { joinForward }\nexport { keyboardShortcut }\nexport { lift }\nexport { liftEmptyBlock }\nexport { liftListItem }\nexport { newlineInCode }\nexport { replace }\nexport { replaceRange }\nexport { resetAttributes }\nexport { scrollIntoView }\nexport { selectAll }\nexport { selectNodeBackward }\nexport { selectNodeForward }\nexport { selectParentNode }\nexport { setContent }\nexport { setMark }\nexport { setMeta }\nexport { setNode }\nexport { setNodeSelection }\nexport { setTextSelection }\nexport { sinkListItem }\nexport { splitBlock }\nexport { splitListItem }\nexport { toggleList }\nexport { toggleMark }\nexport { toggleNode }\nexport { toggleWrap }\nexport { undoInputRule }\nexport { unsetAllMarks }\nexport { unsetMark }\nexport { updateAttributes }\nexport { wrapIn }\nexport { wrapInList }\n\nexport const Commands = Extension.create({\n  name: 'commands',\n\n  addCommands() {\n    return {\n      ...blur,\n      ...clearContent,\n      ...clearNodes,\n      ...command,\n      ...createParagraphNear,\n      ...deleteRange,\n      ...deleteSelection,\n      ...enter,\n      ...exitCode,\n      ...extendMarkRange,\n      ...first,\n      ...focus,\n      ...insertContent,\n      ...insertContentAt,\n      ...joinBackward,\n      ...joinForward,\n      ...keyboardShortcut,\n      ...lift,\n      ...liftEmptyBlock,\n      ...liftListItem,\n      ...newlineInCode,\n      ...replace,\n      ...replaceRange,\n      ...resetAttributes,\n      ...scrollIntoView,\n      ...selectAll,\n      ...selectNodeBackward,\n      ...selectNodeForward,\n      ...selectParentNode,\n      ...setContent,\n      ...setMark,\n      ...setMeta,\n      ...setNode,\n      ...setNodeSelection,\n      ...setTextSelection,\n      ...sinkListItem,\n      ...splitBlock,\n      ...splitListItem,\n      ...toggleList,\n      ...toggleMark,\n      ...toggleNode,\n      ...toggleWrap,\n      ...undoInputRule,\n      ...unsetAllMarks,\n      ...unsetMark,\n      ...updateAttributes,\n      ...wrapIn,\n      ...wrapInList,\n    }\n  },\n})\n","import { Plugin, PluginKey } from 'prosemirror-state'\nimport { Extension } from '../Extension'\n\nexport const Editable = Extension.create({\n  name: 'editable',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('editable'),\n        props: {\n          editable: () => this.editor.options.editable,\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from 'prosemirror-state'\nimport { Extension } from '../Extension'\n\nexport const FocusEvents = Extension.create({\n  name: 'focusEvents',\n\n  addProseMirrorPlugins() {\n    const { editor } = this\n\n    return [\n      new Plugin({\n        key: new PluginKey('focusEvents'),\n        props: {\n          attributes: {\n            tabindex: '0',\n          },\n          handleDOMEvents: {\n            focus: (view, event) => {\n              editor.isFocused = true\n\n              const transaction = editor.state.tr\n                .setMeta('focus', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n            blur: (view, event) => {\n              editor.isFocused = false\n\n              const transaction = editor.state.tr\n                .setMeta('blur', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Extension } from '../Extension'\n\nexport const Keymap = Extension.create({\n  name: 'keymap',\n\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({ commands }) => [\n      () => commands.undoInputRule(),\n      () => commands.deleteSelection(),\n      () => commands.joinBackward(),\n      () => commands.selectNodeBackward(),\n    ])\n\n    const handleDelete = () => this.editor.commands.first(({ commands }) => [\n      () => commands.deleteSelection(),\n      () => commands.joinForward(),\n      () => commands.selectNodeForward(),\n    ])\n\n    return {\n      Enter: () => this.editor.commands.first(({ commands }) => [\n        () => commands.newlineInCode(),\n        () => commands.createParagraphNear(),\n        () => commands.liftEmptyBlock(),\n        () => commands.splitBlock(),\n      ]),\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: () => handleBackspace(),\n      'Mod-Backspace': () => handleBackspace(),\n      Delete: () => handleDelete(),\n      'Mod-Delete': () => handleDelete(),\n      // we donâ€™t need a custom `selectAll` for now\n      // 'Mod-a': () => this.editor.commands.selectAll(),\n    }\n  },\n})\n","const style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`\n\nexport default style\n","import {\n  EditorState,\n  Plugin,\n  PluginKey,\n  Transaction,\n} from 'prosemirror-state'\nimport { EditorView } from 'prosemirror-view'\nimport { Schema, MarkType, NodeType } from 'prosemirror-model'\nimport getAttributes from './helpers/getAttributes'\nimport getNodeAttributes from './helpers/getNodeAttributes'\nimport getMarkAttributes from './helpers/getMarkAttributes'\nimport isActive from './helpers/isActive'\nimport removeElement from './utilities/removeElement'\nimport createDocument from './helpers/createDocument'\nimport getHTMLFromFragment from './helpers/getHTMLFromFragment'\nimport isNodeEmpty from './helpers/isNodeEmpty'\nimport createStyleTag from './utilities/createStyleTag'\nimport CommandManager from './CommandManager'\nimport ExtensionManager from './ExtensionManager'\nimport EventEmitter from './EventEmitter'\nimport {\n  EditorOptions,\n  CanCommands,\n  ChainedCommands,\n  SingleCommands,\n} from './types'\nimport * as extensions from './extensions'\nimport style from './style'\n\nexport { extensions }\n\nexport interface HTMLElement {\n  editor?: Editor\n}\n\nexport class Editor extends EventEmitter {\n\n  private commandManager!: CommandManager\n\n  public extensionManager!: ExtensionManager\n\n  private css!: HTMLStyleElement\n\n  public schema!: Schema\n\n  public view!: EditorView\n\n  public isFocused = false\n\n  public options: EditorOptions = {\n    element: document.createElement('div'),\n    content: '',\n    injectCSS: true,\n    extensions: [],\n    autofocus: false,\n    editable: true,\n    editorProps: {},\n    parseOptions: {},\n    enableInputRules: true,\n    enablePasteRules: true,\n    onBeforeCreate: () => null,\n    onCreate: () => null,\n    onUpdate: () => null,\n    onSelectionUpdate: () => null,\n    onTransaction: () => null,\n    onFocus: () => null,\n    onBlur: () => null,\n    onDestroy: () => null,\n  }\n\n  constructor(options: Partial<EditorOptions> = {}) {\n    super()\n    this.setOptions(options)\n    this.createExtensionManager()\n    this.createCommandManager()\n    this.createSchema()\n    this.on('beforeCreate', this.options.onBeforeCreate)\n    this.emit('beforeCreate', { editor: this })\n    this.createView()\n    this.injectCSS()\n    this.on('create', this.options.onCreate)\n    this.on('update', this.options.onUpdate)\n    this.on('selectionUpdate', this.options.onSelectionUpdate)\n    this.on('transaction', this.options.onTransaction)\n    this.on('focus', this.options.onFocus)\n    this.on('blur', this.options.onBlur)\n    this.on('destroy', this.options.onDestroy)\n\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return\n      }\n\n      this.commands.focus(this.options.autofocus)\n      this.emit('create', { editor: this })\n    }, 0)\n  }\n\n  /**\n   * An object of all registered commands.\n   */\n  public get commands(): SingleCommands {\n    return this.commandManager.createCommands()\n  }\n\n  /**\n   * Create a command chain to call multiple commands at once.\n   */\n  public chain(): ChainedCommands {\n    return this.commandManager.createChain()\n  }\n\n  /**\n   * Check if a command or a command chain can be executed. Without executing it.\n   */\n  public can(): CanCommands {\n    return this.commandManager.createCan()\n  }\n\n  /**\n   * Inject CSS styles.\n   */\n  private injectCSS(): void {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style)\n    }\n  }\n\n  /**\n   * Update editor options.\n   *\n   * @param options A list of options\n   */\n  public setOptions(options: Partial<EditorOptions> = {}): void {\n    this.options = { ...this.options, ...options }\n  }\n\n  /**\n   * Update editable state of the editor.\n   */\n  public setEditable(editable: boolean): void {\n    this.setOptions({ editable })\n\n    if (this.view && this.state && !this.isDestroyed) {\n      this.view.updateState(this.state)\n    }\n  }\n\n  /**\n   * Returns whether the editor is editable.\n   */\n  public get isEditable(): boolean {\n    return this.view && this.view.editable\n  }\n\n  /**\n   * Returns the editor state.\n   */\n  public get state(): EditorState {\n    return this.view.state\n  }\n\n  /**\n   * Register a ProseMirror plugin.\n   *\n   * @param plugin A ProseMirror plugin\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\n   */\n  public registerPlugin(plugin: Plugin, handlePlugins?: (newPlugin: Plugin, plugins: Plugin[]) => Plugin[]): void {\n    const plugins = typeof handlePlugins === 'function'\n      ? handlePlugins(plugin, this.state.plugins)\n      : [...this.state.plugins, plugin]\n\n    const state = this.state.reconfigure({ plugins })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Unregister a ProseMirror plugin.\n   *\n   * @param name The plugins name\n   */\n  public unregisterPlugin(nameOrPluginKey: string | PluginKey): void {\n    if (this.isDestroyed) {\n      return\n    }\n\n    const name = typeof nameOrPluginKey === 'string'\n      ? `${nameOrPluginKey}$`\n      // @ts-ignore\n      : nameOrPluginKey.key\n\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name)),\n    })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Creates an extension manager.\n   */\n  private createExtensionManager(): void {\n    const coreExtensions = Object.entries(extensions).map(([, extension]) => extension)\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension?.type)\n    })\n\n    this.extensionManager = new ExtensionManager(allExtensions, this)\n  }\n\n  /**\n   * Creates an command manager.\n   */\n  private createCommandManager(): void {\n    this.commandManager = new CommandManager(this, this.extensionManager.commands)\n  }\n\n  /**\n   * Creates a ProseMirror schema.\n   */\n  private createSchema(): void {\n    this.schema = this.extensionManager.schema\n  }\n\n  /**\n   * Creates a ProseMirror view.\n   */\n  private createView(): void {\n    this.view = new EditorView(this.options.element, {\n      ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc: createDocument(this.options.content, this.schema, this.options.parseOptions),\n      }),\n    })\n\n    // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins,\n    })\n\n    this.view.updateState(newState)\n\n    this.createNodeViews()\n\n    // Letâ€™s store the editor instance in the DOM element.\n    // So weâ€™ll have access to it for tests.\n    const dom = this.view.dom as HTMLElement\n    dom.editor = this\n  }\n\n  /**\n   * Creates all node views.\n   */\n  public createNodeViews(): void {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews,\n    })\n  }\n\n  public isCapturingTransaction = false\n\n  private capturedTransaction: Transaction | null = null\n\n  public captureTransaction(fn: Function) {\n    this.isCapturingTransaction = true\n    fn()\n    this.isCapturingTransaction = false\n\n    const tr = this.capturedTransaction\n\n    this.capturedTransaction = null\n\n    return tr\n  }\n\n  /**\n   * The callback over which to send transactions (state updates) produced by the view.\n   *\n   * @param transaction An editor state transaction\n   */\n  private dispatchTransaction(transaction: Transaction): void {\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction\n\n        return\n      }\n\n      transaction.steps.forEach(step => this.capturedTransaction?.step(step))\n\n      return\n    }\n\n    const state = this.state.apply(transaction)\n    const selectionHasChanged = !this.state.selection.eq(state.selection)\n\n    this.view.updateState(state)\n    this.emit('transaction', {\n      editor: this,\n      transaction,\n    })\n\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n      })\n    }\n\n    const focus = transaction.getMeta('focus')\n    const blur = transaction.getMeta('blur')\n\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n      })\n    }\n\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n      })\n    }\n\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return\n    }\n\n    this.emit('update', {\n      editor: this,\n      transaction,\n    })\n  }\n\n  /**\n   * Get attributes of the currently selected node or mark.\n   */\n  public getAttributes(nameOrType: string | NodeType | MarkType): Record<string, any> {\n    return getAttributes(this.state, nameOrType)\n  }\n\n  /**\n   * Get attributes of the currently selected node.\n   *\n   * @param name Name of the node\n   */\n  public getNodeAttributes(name: string): Record<string, any> {\n    console.warn('[tiptap warn]: editor.getNodeAttributes() is deprecated. please use editor.getAttributes() instead.')\n\n    return getNodeAttributes(this.state, name)\n  }\n\n  /**\n   * Get attributes of the currently selected mark.\n   *\n   * @param name Name of the mark\n   */\n  public getMarkAttributes(name: string): Record<string, any> {\n    console.warn('[tiptap warn]: editor.getMarkAttributes() is deprecated. please use editor.getAttributes() instead.')\n\n    return getMarkAttributes(this.state, name)\n  }\n\n  /**\n   * Returns if the currently selected node or mark is active.\n   *\n   * @param name Name of the node or mark\n   * @param attributes Attributes of the node or mark\n   */\n  public isActive(name: string, attributes?: {}): boolean;\n  public isActive(attributes: {}): boolean;\n  public isActive(nameOrAttributes: string, attributesOrUndefined?: {}): boolean {\n    const name = typeof nameOrAttributes === 'string'\n      ? nameOrAttributes\n      : null\n\n    const attributes = typeof nameOrAttributes === 'string'\n      ? attributesOrUndefined\n      : nameOrAttributes\n\n    return isActive(this.state, name, attributes)\n  }\n\n  /**\n   * Get the document as JSON.\n   */\n  public getJSON(): Record<string, any> {\n    return this.state.doc.toJSON()\n  }\n\n  /**\n   * Get the document as HTML.\n   */\n  public getHTML(): string {\n    return getHTMLFromFragment(this.state.doc, this.schema)\n  }\n\n  /**\n   * Check if there is no content.\n   */\n  public get isEmpty(): boolean {\n    return isNodeEmpty(this.state.doc)\n  }\n\n  /**\n   * Get the number of characters for the current document.\n   */\n  public getCharacterCount(): number {\n    return this.state.doc.content.size - 2\n  }\n\n  /**\n   * Destroy the editor.\n   */\n  public destroy(): void {\n    this.emit('destroy')\n\n    if (this.view) {\n      this.view.destroy()\n    }\n\n    this.removeAllListeners()\n    removeElement(this.css)\n  }\n\n  /**\n   * Check if the editor is already destroyed.\n   */\n  public get isDestroyed(): boolean {\n    // @ts-ignore\n    return !this.view?.docView\n  }\n\n}\n","import {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  NodeType,\n} from 'prosemirror-model'\nimport { Plugin, Transaction } from 'prosemirror-state'\nimport { InputRule } from 'prosemirror-inputrules'\nimport mergeDeep from './utilities/mergeDeep'\nimport {\n  Extensions,\n  Attributes,\n  NodeViewRenderer,\n  GlobalAttributes,\n  RawCommands,\n  ParentConfig,\n  KeyboardShortcutCommand,\n} from './types'\nimport { NodeConfig } from '.'\nimport { Editor } from './Editor'\n\ndeclare module '@tiptap/core' {\n  interface NodeConfig<Options = any> {\n    [key: string]: any;\n\n    /**\n     * Name\n     */\n    name: string,\n\n    /**\n     * Priority\n     */\n    priority?: number,\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options,\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['addGlobalAttributes'],\n    }) => GlobalAttributes | {},\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['addCommands'],\n    }) => Partial<RawCommands>,\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['addKeyboardShortcuts'],\n    }) => {\n      [key: string]: KeyboardShortcutCommand,\n    },\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['addInputRules'],\n    }) => InputRule[],\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['addPasteRules'],\n    }) => Plugin[],\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['addProseMirrorPlugins'],\n    }) => Plugin[],\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['addExtensions'],\n    }) => Extensions,\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<NodeConfig<Options>>['extendNodeSchema'],\n      },\n      extension: Node,\n    ) => Record<string, any>) | null,\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<NodeConfig<Options>>['extendMarkSchema'],\n      },\n      extension: Node,\n    ) => Record<string, any>) | null,\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['onBeforeCreate'],\n    }) => void) | null,\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['onCreate'],\n    }) => void) | null,\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['onUpdate'],\n    }) => void) | null,\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['onSelectionUpdate'],\n    }) => void) | null,\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        type: NodeType,\n        parent: ParentConfig<NodeConfig<Options>>['onTransaction'],\n      },\n      props: {\n        transaction: Transaction,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        type: NodeType,\n        parent: ParentConfig<NodeConfig<Options>>['onFocus'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor isnâ€™t focused anymore.\n     */\n    onBlur?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        type: NodeType,\n        parent: ParentConfig<NodeConfig<Options>>['onBlur'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['onDestroy'],\n    }) => void) | null,\n\n    /**\n     * Node View\n     */\n    addNodeView?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options>>['addNodeView'],\n    }) => NodeViewRenderer) | null,\n\n    /**\n     * TopNode\n     */\n    topNode?: boolean,\n\n    /**\n     * Content\n     */\n    content?: NodeSpec['content'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['content'],\n    }) => NodeSpec['content']),\n\n    /**\n     * Marks\n     */\n    marks?: NodeSpec['marks'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['marks'],\n    }) => NodeSpec['marks']),\n\n    /**\n     * Group\n     */\n    group?: NodeSpec['group'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['group'],\n    }) => NodeSpec['group']),\n\n    /**\n     * Inline\n     */\n    inline?: NodeSpec['inline'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['inline'],\n    }) => NodeSpec['inline']),\n\n    /**\n     * Atom\n     */\n    atom?: NodeSpec['atom'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['atom'],\n    }) => NodeSpec['atom']),\n\n    /**\n     * Selectable\n     */\n    selectable?: NodeSpec['selectable'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['selectable'],\n    }) => NodeSpec['selectable']),\n\n    /**\n     * Draggable\n     */\n    draggable?: NodeSpec['draggable'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['draggable'],\n    }) => NodeSpec['draggable']),\n\n    /**\n     * Code\n     */\n    code?: NodeSpec['code'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['code'],\n    }) => NodeSpec['code']),\n\n    /**\n     * Defining\n     */\n    defining?: NodeSpec['defining'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['defining'],\n    }) => NodeSpec['defining']),\n\n    /**\n     * Isolating\n     */\n    isolating?: NodeSpec['isolating'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<NodeConfig<Options>>['isolating'],\n    }) => NodeSpec['isolating']),\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<NodeConfig<Options>>['parseHTML'],\n      },\n    ) => NodeSpec['parseDOM'],\n\n    /**\n     * Render HTML\n     */\n    renderHTML?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<NodeConfig<Options>>['renderHTML'],\n      },\n      props: {\n        node: ProseMirrorNode,\n        HTMLAttributes: Record<string, any>,\n      }\n    ) => DOMOutputSpec) | null,\n\n    /**\n     * Render Text\n     */\n    renderText?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        type: NodeType,\n        parent: ParentConfig<NodeConfig<Options>>['renderText'],\n      },\n      props: {\n        node: ProseMirrorNode,\n      }\n    ) => string) | null,\n\n    /**\n     * Add Attributes\n     */\n    addAttributes?: (\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<NodeConfig<Options>>['addAttributes'],\n      },\n    ) => Attributes | {},\n  }\n}\n\nexport class Node<Options = any> {\n  type = 'node'\n\n  name = 'node'\n\n  parent: Node | null = null\n\n  child: Node | null = null\n\n  options: Options\n\n  config: NodeConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<NodeConfig<Options>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n    this.options = this.config.defaultOptions\n  }\n\n  static create<O>(config: Partial<NodeConfig<O>> = {}) {\n    return new Node<O>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options, options) as Options\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options>(extendedConfig: Partial<NodeConfig<ExtendedOptions>> = {}) {\n    const extension = new Node<ExtendedOptions>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name\n      ? extendedConfig.name\n      : extension.parent.name\n\n    extension.options = extendedConfig.defaultOptions\n      ? extendedConfig.defaultOptions\n      : extension.parent.options\n\n    return extension\n  }\n}\n","import {\n  DOMOutputSpec,\n  MarkSpec,\n  Mark as ProseMirrorMark,\n  MarkType,\n} from 'prosemirror-model'\nimport { Plugin, Transaction } from 'prosemirror-state'\nimport { InputRule } from 'prosemirror-inputrules'\nimport mergeDeep from './utilities/mergeDeep'\nimport {\n  Extensions,\n  Attributes,\n  RawCommands,\n  GlobalAttributes,\n  ParentConfig,\n  KeyboardShortcutCommand,\n} from './types'\nimport { Node } from './Node'\nimport { MarkConfig } from '.'\nimport { Editor } from './Editor'\n\ndeclare module '@tiptap/core' {\n  export interface MarkConfig<Options = any> {\n    [key: string]: any;\n\n    /**\n     * Name\n     */\n    name: string,\n\n    /**\n     * Priority\n     */\n    priority?: number,\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options,\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<MarkConfig<Options>>['addGlobalAttributes'],\n    }) => GlobalAttributes | {},\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['addCommands'],\n    }) => Partial<RawCommands>,\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['addKeyboardShortcuts'],\n    }) => {\n      [key: string]: KeyboardShortcutCommand,\n    },\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['addInputRules'],\n    }) => InputRule[],\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['addPasteRules'],\n    }) => Plugin[],\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['addProseMirrorPlugins'],\n    }) => Plugin[],\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<MarkConfig<Options>>['addExtensions'],\n    }) => Extensions,\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<MarkConfig<Options>>['extendNodeSchema'],\n      },\n      extension: Node,\n    ) => Record<string, any>) | null,\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<MarkConfig<Options>>['extendMarkSchema'],\n      },\n      extension: Mark,\n    ) => Record<string, any>) | null,\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['onBeforeCreate'],\n    }) => void) | null,\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['onCreate'],\n    }) => void) | null,\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['onUpdate'],\n    }) => void) | null,\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['onSelectionUpdate'],\n    }) => void) | null,\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        type: MarkType,\n        parent: ParentConfig<MarkConfig<Options>>['onTransaction'],\n      },\n      props: {\n        transaction: Transaction,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        type: MarkType,\n        parent: ParentConfig<MarkConfig<Options>>['onFocus'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor isnâ€™t focused anymore.\n     */\n    onBlur?: ((\n      this: {\n        name: string,\n        options: Options,\n        editor: Editor,\n        type: MarkType,\n        parent: ParentConfig<MarkConfig<Options>>['onBlur'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?: ((this: {\n      name: string,\n      options: Options,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options>>['onDestroy'],\n    }) => void) | null,\n\n    /**\n     * Keep mark after split node\n     */\n    keepOnSplit?: boolean | (() => boolean),\n\n    /**\n     * Inclusive\n     */\n    inclusive?: MarkSpec['inclusive'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<MarkConfig<Options>>['inclusive'],\n    }) => MarkSpec['inclusive']),\n\n    /**\n     * Excludes\n     */\n    excludes?: MarkSpec['excludes'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<MarkConfig<Options>>['excludes'],\n    }) => MarkSpec['excludes']),\n\n    /**\n     * Group\n     */\n    group?: MarkSpec['group'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<MarkConfig<Options>>['group'],\n    }) => MarkSpec['group']),\n\n    /**\n     * Spanning\n     */\n    spanning?: MarkSpec['spanning'] | ((this: {\n      name: string,\n      options: Options,\n      parent: ParentConfig<MarkConfig<Options>>['spanning'],\n    }) => MarkSpec['spanning']),\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<MarkConfig<Options>>['parseHTML'],\n      },\n    ) => MarkSpec['parseDOM'],\n\n    /**\n     * Render HTML\n     */\n    renderHTML?: ((\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<MarkConfig<Options>>['renderHTML'],\n      },\n      props: {\n        mark: ProseMirrorMark,\n        HTMLAttributes: Record<string, any>,\n      },\n    ) => DOMOutputSpec) | null,\n\n    /**\n     * Attributes\n     */\n    addAttributes?: (\n      this: {\n        name: string,\n        options: Options,\n        parent: ParentConfig<MarkConfig<Options>>['addAttributes'],\n      },\n    ) => Attributes | {},\n  }\n}\n\nexport class Mark<Options = any> {\n  type = 'mark'\n\n  name = 'mark'\n\n  parent: Mark | null = null\n\n  child: Mark | null = null\n\n  options: Options\n\n  config: MarkConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<MarkConfig<Options>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n    this.options = this.config.defaultOptions\n  }\n\n  static create<O>(config: Partial<MarkConfig<O>> = {}) {\n    return new Mark<O>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options, options) as Options\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options>(extendedConfig: Partial<MarkConfig<ExtendedOptions>> = {}) {\n    const extension = new Mark<ExtendedOptions>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name\n      ? extendedConfig.name\n      : extension.parent.name\n\n    extension.options = extendedConfig.defaultOptions\n      ? extendedConfig.defaultOptions\n      : extension.parent.options\n\n    return extension\n  }\n}\n","export default function isiOS(): boolean {\n  return [\n    'iPad Simulator',\n    'iPhone Simulator',\n    'iPod Simulator',\n    'iPad',\n    'iPhone',\n    'iPod',\n  ].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || (navigator.userAgent.includes('Mac') && 'ontouchend' in document)\n}\n","import { Decoration, NodeView as ProseMirrorNodeView } from 'prosemirror-view'\nimport { NodeSelection } from 'prosemirror-state'\nimport { Node as ProseMirrorNode } from 'prosemirror-model'\nimport { Editor as CoreEditor } from './Editor'\nimport { Node } from './Node'\nimport isiOS from './utilities/isiOS'\nimport { NodeViewRendererProps } from './types'\n\ninterface NodeViewRendererOptions {\n  stopEvent: ((event: Event) => boolean) | null,\n  update: ((node: ProseMirrorNode, decorations: Decoration[]) => boolean) | null,\n}\n\nexport class NodeView<Component, Editor extends CoreEditor = CoreEditor> implements ProseMirrorNodeView {\n\n  component: Component\n\n  editor: Editor\n\n  extension: Node\n\n  node: ProseMirrorNode\n\n  decorations: Decoration[]\n\n  getPos: any\n\n  isDragging = false\n\n  options: NodeViewRendererOptions = {\n    stopEvent: null,\n    update: null,\n  }\n\n  constructor(component: Component, props: NodeViewRendererProps, options?: Partial<NodeViewRendererOptions>) {\n    this.component = component\n    this.options = { ...this.options, ...options }\n    this.editor = props.editor as Editor\n    this.extension = props.extension\n    this.node = props.node\n    this.decorations = props.decorations\n    this.getPos = props.getPos\n    this.mount()\n  }\n\n  mount() {\n    // eslint-disable-next-line\n    return\n  }\n\n  get dom(): Element | null {\n    return null\n  }\n\n  get contentDOM(): Element | null {\n    return null\n  }\n\n  onDragStart(event: DragEvent) {\n    const { view } = this.editor\n    const target = (event.target as HTMLElement)\n\n    // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n    const dragHandle = target.nodeType === 3\n      ? target.parentElement?.closest('[data-drag-handle]')\n      : target.closest('[data-drag-handle]')\n\n    if (\n      !this.dom\n      || this.contentDOM?.contains(target)\n      || !dragHandle\n    ) {\n      return\n    }\n\n    let x = 0\n    let y = 0\n\n    // calculate offset for drag element if we use a different drag handle element\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect()\n      const handleBox = dragHandle.getBoundingClientRect()\n\n      x = handleBox.x - domBox.x + event.offsetX\n      y = handleBox.y - domBox.y + event.offsetY\n    }\n\n    event.dataTransfer?.setDragImage(this.dom, x, y)\n\n    // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n    const selection = NodeSelection.create(view.state.doc, this.getPos())\n    const transaction = view.state.tr.setSelection(selection)\n\n    view.dispatch(transaction)\n  }\n\n  stopEvent(event: Event) {\n    if (!this.dom) {\n      return false\n    }\n\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent(event)\n    }\n\n    const target = (event.target as HTMLElement)\n    const isInElement = this.dom.contains(target) && !this.contentDOM?.contains(target)\n\n    // any event from child nodes should be handled by ProseMirror\n    if (!isInElement) {\n      return false\n    }\n\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName)\n      || target.isContentEditable\n\n    // any input event within node views should be ignored by ProseMirror\n    if (isInput) {\n      return true\n    }\n\n    const { isEditable } = this.editor\n    const { isDragging } = this\n    const isDraggable = !!this.node.type.spec.draggable\n    const isSelectable = NodeSelection.isSelectable(this.node)\n    const isCopyEvent = event.type === 'copy'\n    const isPasteEvent = event.type === 'paste'\n    const isCutEvent = event.type === 'cut'\n    const isClickEvent = event.type === 'mousedown'\n    const isDragEvent = event.type.startsWith('drag') || event.type === 'drop'\n\n    // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault()\n    }\n\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault()\n      return false\n    }\n\n    // we have to store that dragging started\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]')\n      const isValidDragHandle = dragHandle\n        && (this.dom === dragHandle || (this.dom.contains(dragHandle)))\n\n      if (isValidDragHandle) {\n        this.isDragging = true\n\n        document.addEventListener('dragend', () => {\n          this.isDragging = false\n        }, { once: true })\n\n        document.addEventListener('mouseup', () => {\n          this.isDragging = false\n        }, { once: true })\n      }\n    }\n\n    // these events are handled by prosemirror\n    if (\n      isDragging\n      || isCopyEvent\n      || isPasteEvent\n      || isCutEvent\n      || (isClickEvent && isSelectable)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  ignoreMutation(mutation: MutationRecord | { type: 'selection', target: Element }) {\n    if (!this.dom || !this.contentDOM) {\n      return true\n    }\n\n    // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n    if (this.node.isLeaf) {\n      return true\n    }\n\n    // ProseMirror should handle any selections\n    if (mutation.type === 'selection') {\n      return false\n    }\n\n    // try to prevent a bug on iOS that will break node views on enter\n    // this is because ProseMirror canâ€™t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n    if (this.dom.contains(mutation.target) && mutation.type === 'childList' && isiOS()) {\n      const changedNodes = [\n        ...Array.from(mutation.addedNodes),\n        ...Array.from(mutation.removedNodes),\n      ] as HTMLElement[]\n\n      // weâ€™ll check if every changed node is contentEditable\n      // to make sure itâ€™s probably mutated by ProseMirror\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false\n      }\n    }\n\n    // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true\n    }\n\n    // ProseMirror should handle any changes within contentDOM\n    if (this.contentDOM.contains(mutation.target)) {\n      return false\n    }\n\n    return true\n  }\n\n  updateAttributes(attributes: {}) {\n    if (!this.editor.view.editable) {\n      return\n    }\n\n    const { state } = this.editor.view\n    const pos = this.getPos()\n    const transaction = state.tr.setNodeMarkup(pos, undefined, {\n      ...this.node.attrs,\n      ...attributes,\n    })\n\n    this.editor.view.dispatch(transaction)\n  }\n\n  deleteNode(): void {\n    const from = this.getPos()\n    const to = from + this.node.nodeSize\n\n    this.editor.commands.deleteRange({ from, to })\n  }\n}\n","import { InputRule } from 'prosemirror-inputrules'\nimport { NodeType } from 'prosemirror-model'\n\nexport default function (regexp: RegExp, type: NodeType, getAttributes?: (match: any) => any): InputRule {\n  return new InputRule(regexp, (state, match, start, end) => {\n    const attributes = getAttributes instanceof Function\n      ? getAttributes(match)\n      : getAttributes\n    const { tr } = state\n\n    if (match[0]) {\n      tr.replaceWith(start - 1, end, type.create(attributes))\n    }\n\n    return tr\n  })\n}\n","import { EditorState } from 'prosemirror-state'\nimport { MarkRange } from '../types'\n\nexport default function getMarksBetween(from: number, to: number, state: EditorState): MarkRange[] {\n  let marks: MarkRange[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    marks = [...marks, ...node.marks.map(mark => ({\n      from: pos,\n      to: pos + node.nodeSize,\n      mark,\n    }))]\n  })\n\n  return marks\n}\n","import { InputRule } from 'prosemirror-inputrules'\nimport { MarkType } from 'prosemirror-model'\nimport getMarksBetween from '../helpers/getMarksBetween'\n\nexport default function (regexp: RegExp, markType: MarkType, getAttributes?: Function): InputRule {\n  return new InputRule(regexp, (state, match, start, end) => {\n    const attributes = getAttributes instanceof Function\n      ? getAttributes(match)\n      : getAttributes\n    const { tr } = state\n    const captureGroup = match[match.length - 1]\n    const fullMatch = match[0]\n    let markEnd = end\n\n    if (captureGroup) {\n      const startSpaces = fullMatch.search(/\\S/)\n      const textStart = start + fullMatch.indexOf(captureGroup)\n      const textEnd = textStart + captureGroup.length\n\n      const excludedMarks = getMarksBetween(start, end, state)\n        .filter(item => {\n          // TODO: PR to add excluded to MarkType\n          // @ts-ignore\n          const { excluded } = item.mark.type\n          return excluded.find((type: MarkType) => type.name === markType.name)\n        })\n        .filter(item => item.to > textStart)\n\n      if (excludedMarks.length) {\n        return null\n      }\n\n      if (textEnd < end) {\n        tr.delete(textEnd, end)\n      }\n\n      if (textStart > start) {\n        tr.delete(start + startSpaces, textStart)\n      }\n\n      markEnd = start + startSpaces + captureGroup.length\n\n      tr.addMark(start + startSpaces, markEnd, markType.create(attributes))\n\n      tr.removeStoredMark(markType)\n    }\n\n    return tr\n  })\n}\n","import { Plugin, PluginKey } from 'prosemirror-state'\nimport { Slice, Fragment, MarkType } from 'prosemirror-model'\n\nexport default function (\n  regexp: RegExp,\n  type: MarkType,\n  getAttributes?: Record<string, any> | ((match: RegExpExecArray) => Record<string, any>),\n): Plugin {\n  const handler = (fragment: Fragment, parent?: any) => {\n    const nodes: any[] = []\n\n    fragment.forEach(child => {\n      if (child.isText && child.text) {\n        const { text } = child\n        let pos = 0\n        let match\n\n        // eslint-disable-next-line\n        while ((match = regexp.exec(text)) !== null) {\n          const outerMatch = Math.max(match.length - 2, 0)\n          const innerMatch = Math.max(match.length - 1, 0)\n\n          if (parent?.type.allowsMarkType(type)) {\n            const start = match.index\n            const matchStart = start + match[0].indexOf(match[outerMatch])\n            const matchEnd = matchStart + match[outerMatch].length\n            const textStart = matchStart + match[outerMatch].lastIndexOf(match[innerMatch])\n            const textEnd = textStart + match[innerMatch].length\n            const attrs = getAttributes instanceof Function\n              ? getAttributes(match)\n              : getAttributes\n\n            // adding text before markdown to nodes\n            if (matchStart > 0) {\n              nodes.push(child.cut(pos, matchStart))\n            }\n\n            // adding the markdown part to nodes\n            nodes.push(child\n              .cut(textStart, textEnd)\n              .mark(type.create(attrs).addToSet(child.marks)))\n\n            pos = matchEnd\n          }\n        }\n\n        // adding rest of text to nodes\n        if (pos < text.length) {\n          nodes.push(child.cut(pos))\n        }\n      } else {\n        nodes.push(child.copy(handler(child.content, child)))\n      }\n    })\n\n    return Fragment.fromArray(nodes)\n  }\n\n  return new Plugin({\n    key: new PluginKey('markPasteRule'),\n    props: {\n      transformPasted: slice => {\n        return new Slice(handler(slice.content), slice.openStart, slice.openEnd)\n      },\n    },\n  })\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\nimport { Predicate, NodeWithPos } from '../types'\n\nexport default function findChildren(node: ProseMirrorNode, predicate: Predicate): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\nimport { Predicate, Range, NodeWithPos } from '../types'\n\n/**\n * Same as `findChildren` but searches only within a `range`.\n */\nexport default function findChildrenInRange(node: ProseMirrorNode, range: Range, predicate: Predicate): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Schema } from 'prosemirror-model'\nimport getSchemaByResolvedExtensions from './getSchemaByResolvedExtensions'\nimport ExtensionManager from '../ExtensionManager'\nimport { Extensions } from '../types'\n\nexport default function getSchema(extensions: Extensions): Schema {\n  const resolvedExtensions = ExtensionManager.resolve(extensions)\n\n  return getSchemaByResolvedExtensions(resolvedExtensions)\n}\n","import { Node } from 'prosemirror-model'\nimport getSchema from './getSchema'\nimport getHTMLFromFragment from './getHTMLFromFragment'\nimport { Extensions } from '../types'\n\nexport default function generateHTML(doc: object, extensions: Extensions): string {\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode, schema)\n}\n","import { DOMParser } from 'prosemirror-model'\nimport getSchema from './getSchema'\nimport elementFromString from '../utilities/elementFromString'\nimport { Extensions } from '../types'\n\nexport default function generateJSON(html: string, extensions: Extensions): Record<string, any> {\n  const schema = getSchema(extensions)\n  const dom = elementFromString(html)\n\n  return DOMParser.fromSchema(schema)\n    .parse(dom)\n    .toJSON()\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\nimport { JSONContent } from '../types'\n\ninterface DebugJSONContent extends JSONContent {\n  from: number,\n  to: number,\n}\n\n/**\n * Returns a node tree with node positions.\n */\nexport default function getDebugJSON(node: ProseMirrorNode, startOffset = 0) {\n  const nodes: DebugJSONContent[] = []\n\n  node.forEach((n, offset) => {\n    const from = startOffset + offset\n    const to = from + n.nodeSize\n    const marks = n.marks.map(mark => ({\n      type: mark.type.name,\n      attrs: { ...mark.attrs },\n    }))\n    const attrs = { ...n.attrs }\n    const content = getDebugJSON(n, from + 1)\n    const output: DebugJSONContent = {\n      type: n.type.name,\n      from,\n      to,\n    }\n\n    if (Object.keys(attrs).length) {\n      output.attrs = attrs\n    }\n\n    if (marks.length) {\n      output.marks = marks\n    }\n\n    if (content.length) {\n      output.content = content\n    }\n\n    if (n.text) {\n      output.text = n.text\n    }\n\n    nodes.push(output)\n  })\n\n  return nodes\n}\n","import { NodeSelection } from 'prosemirror-state'\nimport isObject from '../utilities/isObject'\n\nexport default function isNodeSelection(value: unknown): value is NodeSelection {\n  return isObject(value) && value instanceof NodeSelection\n}\n","import { EditorView } from 'prosemirror-view'\n\nexport default function posToDOMRect(view: EditorView, from: number, to: number): DOMRect {\n  const start = view.coordsAtPos(from)\n  const end = view.coordsAtPos(to, -1)\n  const top = Math.min(start.top, end.top)\n  const bottom = Math.max(start.bottom, end.bottom)\n  const left = Math.min(start.left, end.left)\n  const right = Math.max(start.right, end.right)\n  const width = right - left\n  const height = bottom - top\n  const x = left\n  const y = top\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y,\n  }\n\n  return {\n    ...data,\n    toJSON: () => data,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}